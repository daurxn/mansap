import "./chunk-PZ5AY32C.js";

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset3 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset3, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/vue/dist/floating-ui.vue.mjs
import { unref, computed, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly } from "vue-demi";
function isComponentPublicInstance(target) {
  return target != null && typeof target === "object" && "$el" in target;
}
function unwrapElement2(target) {
  if (isComponentPublicInstance(target)) {
    const element = target.$el;
    return isNode(element) && getNodeName(element) === "#comment" ? null : element;
  }
  return target;
}
function toValue(source) {
  return typeof source === "function" ? source() : unref(source);
}
function arrow3(options) {
  return {
    name: "arrow",
    options,
    fn(args) {
      const element = unwrapElement2(toValue(options.element));
      if (element == null) {
        return {};
      }
      return arrow2({
        element,
        padding: options.padding
      }).fn(args);
    }
  };
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useFloating(reference, floating, options) {
  if (options === void 0) {
    options = {};
  }
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = computed(() => {
    var _toValue;
    return (_toValue = toValue(options.open)) != null ? _toValue : true;
  });
  const middlewareOption = computed(() => toValue(options.middleware));
  const placementOption = computed(() => {
    var _toValue2;
    return (_toValue2 = toValue(options.placement)) != null ? _toValue2 : "bottom";
  });
  const strategyOption = computed(() => {
    var _toValue3;
    return (_toValue3 = toValue(options.strategy)) != null ? _toValue3 : "absolute";
  });
  const transformOption = computed(() => {
    var _toValue4;
    return (_toValue4 = toValue(options.transform)) != null ? _toValue4 : true;
  });
  const referenceElement = computed(() => unwrapElement2(reference.value));
  const floatingElement = computed(() => unwrapElement2(floating.value));
  const x = ref(0);
  const y = ref(0);
  const strategy = ref(strategyOption.value);
  const placement = ref(placementOption.value);
  const middlewareData = shallowRef({});
  const isPositioned = ref(false);
  const floatingStyles = computed(() => {
    const initialStyles = {
      position: strategy.value,
      left: "0",
      top: "0"
    };
    if (!floatingElement.value) {
      return initialStyles;
    }
    const xVal = roundByDPR(floatingElement.value, x.value);
    const yVal = roundByDPR(floatingElement.value, y.value);
    if (transformOption.value) {
      return {
        ...initialStyles,
        transform: "translate(" + xVal + "px, " + yVal + "px)",
        ...getDPR(floatingElement.value) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy.value,
      left: xVal + "px",
      top: yVal + "px"
    };
  });
  let whileElementsMountedCleanup;
  function update() {
    if (referenceElement.value == null || floatingElement.value == null) {
      return;
    }
    const open = openOption.value;
    computePosition2(referenceElement.value, floatingElement.value, {
      middleware: middlewareOption.value,
      placement: placementOption.value,
      strategy: strategyOption.value
    }).then((position) => {
      x.value = position.x;
      y.value = position.y;
      strategy.value = position.strategy;
      placement.value = position.placement;
      middlewareData.value = position.middlewareData;
      isPositioned.value = open !== false;
    });
  }
  function cleanup() {
    if (typeof whileElementsMountedCleanup === "function") {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (whileElementsMountedOption === void 0) {
      update();
      return;
    }
    if (referenceElement.value != null && floatingElement.value != null) {
      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
      return;
    }
  }
  function reset() {
    if (!openOption.value) {
      isPositioned.value = false;
    }
  }
  watch([middlewareOption, placementOption, strategyOption, openOption], update, {
    flush: "sync"
  });
  watch([referenceElement, floatingElement], attach, {
    flush: "sync"
  });
  watch(openOption, reset, {
    flush: "sync"
  });
  if (getCurrentScope()) {
    onScopeDispose(cleanup);
  }
  return {
    x: shallowReadonly(x),
    y: shallowReadonly(y),
    strategy: shallowReadonly(strategy),
    placement: shallowReadonly(placement),
    middlewareData: shallowReadonly(middlewareData),
    isPositioned: shallowReadonly(isPositioned),
    floatingStyles,
    update
  };
}

// node_modules/reka-ui/dist/VisuallyHidden/VisuallyHidden.js
import { defineComponent as defineComponent3, createBlock, openBlock, unref as unref2, withCtx, renderSlot } from "vue";

// node_modules/reka-ui/dist/Primitive/Primitive.js
import { defineComponent as defineComponent2, h } from "vue";

// node_modules/reka-ui/dist/Primitive/Slot.js
import { defineComponent, Comment, mergeProps, cloneVNode } from "vue";

// node_modules/reka-ui/dist/shared/renderSlotFragments.js
import { Fragment } from "vue";
function renderSlotFragments(children) {
  if (!children)
    return [];
  return children.flatMap((child) => {
    if (child.type === Fragment)
      return renderSlotFragments(child.children);
    return [child];
  });
}

// node_modules/reka-ui/dist/Primitive/Slot.js
var Slot = defineComponent({
  name: "PrimitiveSlot",
  inheritAttrs: false,
  setup(_, { attrs, slots }) {
    return () => {
      if (!slots.default)
        return null;
      const childrens = renderSlotFragments(slots.default());
      const firstNonCommentChildrenIndex = childrens.findIndex((child) => child.type !== Comment);
      if (firstNonCommentChildrenIndex === -1)
        return childrens;
      const firstNonCommentChildren = childrens[firstNonCommentChildrenIndex];
      delete firstNonCommentChildren.props?.ref;
      const mergedProps = firstNonCommentChildren.props ? mergeProps(attrs, firstNonCommentChildren.props) : attrs;
      if (attrs.class && firstNonCommentChildren.props?.class)
        delete firstNonCommentChildren.props.class;
      const cloned = cloneVNode(firstNonCommentChildren, mergedProps);
      for (const prop in mergedProps) {
        if (prop.startsWith("on")) {
          cloned.props ||= {};
          cloned.props[prop] = mergedProps[prop];
        }
      }
      if (childrens.length === 1)
        return cloned;
      childrens[firstNonCommentChildrenIndex] = cloned;
      return childrens;
    };
  }
});

// node_modules/reka-ui/dist/Primitive/Primitive.js
var SELF_CLOSING_TAGS = ["area", "img", "input"];
var Primitive = defineComponent2({
  name: "Primitive",
  inheritAttrs: false,
  props: {
    asChild: {
      type: Boolean,
      default: false
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(props2, { attrs, slots }) {
    const asTag = props2.asChild ? "template" : props2.as;
    if (typeof asTag === "string" && SELF_CLOSING_TAGS.includes(asTag))
      return () => h(asTag, attrs);
    if (asTag !== "template")
      return () => h(props2.as, attrs, { default: slots.default });
    return () => h(Slot, attrs, { default: slots.default });
  }
});

// node_modules/reka-ui/dist/VisuallyHidden/VisuallyHidden.js
var _sfc_main = defineComponent3({
  __name: "VisuallyHidden",
  props: {
    feature: { default: "focusable" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref2(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "aria-hidden": _ctx.feature === "focusable" ? "true" : void 0,
        "data-hidden": _ctx.feature === "fully-hidden" ? "" : void 0,
        tabindex: _ctx.feature === "fully-hidden" ? "-1" : void 0,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
          position: "absolute",
          border: 0,
          width: "1px",
          height: "1px",
          padding: 0,
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          clipPath: "inset(50%)",
          whiteSpace: "nowrap",
          wordWrap: "normal"
        }
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "aria-hidden", "data-hidden", "tabindex"]);
    };
  }
});

// node_modules/reka-ui/node_modules/@vueuse/shared/index.mjs
import { shallowRef as shallowRef2, watchEffect, readonly, watch as watch2, customRef, getCurrentScope as getCurrentScope2, onScopeDispose as onScopeDispose2, effectScope, getCurrentInstance, hasInjectionContext, inject, provide, ref as ref2, isRef, unref as unref3, toValue as toValue$1, computed as computed2, reactive, toRefs as toRefs$1, toRef as toRef$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from "vue";
function computedEager(fn, options) {
  var _a;
  const result = shallowRef2();
  watchEffect(() => {
    result.value = fn();
  }, {
    ...options,
    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : "sync"
  });
  return readonly(result);
}
function computedWithControl(source, fn) {
  let v = void 0;
  let track;
  let trigger;
  const dirty = shallowRef2(true);
  const update = () => {
    dirty.value = true;
    trigger();
  };
  watch2(source, update, { flush: "sync" });
  const get = typeof fn === "function" ? fn : fn.get;
  const set = typeof fn === "function" ? void 0 : fn.set;
  const result = customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        if (dirty.value) {
          v = get(v);
          dirty.value = false;
        }
        track();
        return v;
      },
      set(v2) {
        set == null ? void 0 : set(v2);
      }
    };
  });
  if (Object.isExtensible(result))
    result.trigger = update;
  return result;
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope2()) {
    onScopeDispose2(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = (fn) => {
    fns.delete(fn);
  };
  const clear = () => {
    fns.clear();
  };
  const on = (fn) => {
    fns.add(fn);
    const offFn = () => off(fn);
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (...args) => {
    return Promise.all(Array.from(fns).map((fn) => fn(...args)));
  };
  return {
    on,
    off,
    trigger,
    clear
  };
}
function createGlobalState(stateFactory) {
  let initialized = false;
  let state;
  const scope = effectScope(true);
  return (...args) => {
    if (!initialized) {
      state = scope.run(() => stateFactory(...args));
      initialized = true;
    }
    return state;
  };
}
function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;
  const dispose = () => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state = void 0;
      scope = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!scope) {
      scope = effectScope(true);
      state = scope.run(() => composable(...args));
    }
    tryOnScopeDispose(dispose);
    return state;
  };
}
function toReactive(objectRef) {
  if (!isRef(objectRef))
    return reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_, p, receiver) {
      return unref3(Reflect.get(objectRef.value, p, receiver));
    },
    set(_, p, value) {
      if (isRef(objectRef.value[p]) && !isRef(value))
        objectRef.value[p].value = value;
      else
        objectRef.value[p] = value;
      return true;
    },
    deleteProperty(_, p) {
      return Reflect.deleteProperty(objectRef.value, p);
    },
    has(_, p) {
      return Reflect.has(objectRef.value, p);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
}
function reactiveComputed(fn) {
  return toReactive(computed2(fn));
}
function reactiveOmit(obj, ...keys2) {
  const flatKeys = keys2.flat();
  const predicate = flatKeys[0];
  return reactiveComputed(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue$1(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var isDef = (val) => typeof val !== "undefined";
var notNullish = (val) => val != null;
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
var bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  let lastInvoker;
  const filter = (invoke) => {
    const duration = toValue$1(ms);
    const maxDuration = toValue$1(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      lastInvoker = invoke;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(lastInvoker());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke());
      }, duration);
    });
  };
  return filter;
}
function pausableFilter(extendFilter = bypassFilter, options = {}) {
  const {
    initialState = "active"
  } = options;
  const isActive = toRef(initialState === "active");
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
function cacheStringFunction(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
});
function identity(arg) {
  return arg;
}
function getLifeCycleTarget(target) {
  return target || getCurrentInstance();
}
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function toRef(...args) {
  if (args.length !== 1)
    return toRef$1(...args);
  const r = args[0];
  return typeof r === "function" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref2(r);
}
function refAutoReset(defaultValue, afterMs = 1e4) {
  return customRef((track, trigger) => {
    let value = toValue$1(defaultValue);
    let timer;
    const resetAfter = () => setTimeout(() => {
      value = toValue$1(defaultValue);
      trigger();
    }, toValue$1(afterMs));
    tryOnScopeDispose(() => {
      clearTimeout(timer);
    });
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        value = newValue;
        trigger();
        clearTimeout(timer);
        timer = resetAfter();
      }
    };
  });
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options),
    fn
  );
}
function watchWithFilter(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options;
  return watch2(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable(source, cb, options = {}) {
  const {
    eventFilter: filter,
    initialState = "active",
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter, { initialState });
  const stop = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop, pause, resume, isActive };
}
function syncRef(left, right, ...[options]) {
  const {
    flush = "sync",
    deep = false,
    immediate = true,
    direction = "both",
    transform: transform2 = {}
  } = options || {};
  const watchers = [];
  const transformLTR = "ltr" in transform2 && transform2.ltr || ((v) => v);
  const transformRTL = "rtl" in transform2 && transform2.rtl || ((v) => v);
  if (direction === "both" || direction === "ltr") {
    watchers.push(watchPausable(
      left,
      (newValue) => {
        watchers.forEach((w) => w.pause());
        right.value = transformLTR(newValue);
        watchers.forEach((w) => w.resume());
      },
      { flush, deep, immediate }
    ));
  }
  if (direction === "both" || direction === "rtl") {
    watchers.push(watchPausable(
      right,
      (newValue) => {
        watchers.forEach((w) => w.pause());
        left.value = transformRTL(newValue);
        watchers.forEach((w) => w.resume());
      },
      { flush, deep, immediate }
    ));
  }
  const stop = () => {
    watchers.forEach((w) => w.stop());
  };
  return stop;
}
var toValue2 = toValue$1;
function tryOnBeforeUnmount(fn, target) {
  const instance = getLifeCycleTarget(target);
  if (instance)
    onBeforeUnmount(fn, target);
}
function tryOnMounted(fn, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  const isPending = shallowRef2(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear();
  }
  function start(...args) {
    if (immediateCallback)
      cb();
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, toValue$1(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start();
  }
  tryOnScopeDispose(stop);
  return {
    isPending: readonly(isPending),
    start,
    stop
  };
}
function useTimeout(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    callback
  } = options;
  const controls = useTimeoutFn(
    callback != null ? callback : noop,
    interval,
    options
  );
  const ready = computed2(() => !controls.isPending.value);
  if (exposeControls) {
    return {
      ready,
      ...controls
    };
  } else {
    return ready;
  }
}
function watchImmediate(source, cb, options) {
  return watch2(
    source,
    cb,
    {
      ...options,
      immediate: true
    }
  );
}
function watchOnce(source, cb, options) {
  const stop = watch2(source, (...args) => {
    nextTick(() => stop());
    return cb(...args);
  }, options);
  return stop;
}

// node_modules/reka-ui/node_modules/@vueuse/core/index.mjs
import { isRef as isRef2, shallowRef as shallowRef3, ref as ref3, watchEffect as watchEffect2, computed as computed3, inject as inject2, defineComponent as defineComponent4, h as h2, TransitionGroup, shallowReactive, Fragment as Fragment2, toValue as toValue3, unref as unref4, getCurrentInstance as getCurrentInstance2, onMounted as onMounted2, watch as watch3, customRef as customRef2, onUpdated, readonly as readonly2, reactive as reactive2, hasInjectionContext as hasInjectionContext2, toRaw, nextTick as nextTick2, markRaw, getCurrentScope as getCurrentScope3, isReadonly, onBeforeUpdate } from "vue";
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function unrefElement(elRef) {
  var _a;
  const plain = toValue3(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function useEventListener(...args) {
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed3(() => {
    const test = toArray(toValue3(args[0])).filter((e) => e != null);
    return test.every((e) => typeof e !== "string") ? test : void 0;
  });
  const stopWatch = watchImmediate(
    () => {
      var _a, _b;
      return [
        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),
        toArray(toValue3(firstParamTargets.value ? args[1] : args[0])),
        toArray(unref4(firstParamTargets.value ? args[2] : args[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue3(firstParamTargets.value ? args[3] : args[2])
      ];
    },
    ([raw_targets, raw_events, raw_listeners, raw_options]) => {
      cleanup();
      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
        return;
      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
      cleanups.push(
        ...raw_targets.flatMap(
          (el) => raw_events.flatMap(
            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))
          )
        )
      );
    },
    { flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(cleanup);
  return stop;
}
function useMounted() {
  const isMounted = shallowRef3(false);
  const instance = getCurrentInstance2();
  if (instance) {
    onMounted2(() => {
      isMounted.value = true;
    }, instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed3(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed3(() => {
    const value = toValue3(target);
    const items = toArray(value).map(unrefElement).filter(notNullish);
    return new Set(items);
  });
  const stopWatch = watch3(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported.value && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = () => {
    return observer == null ? void 0 : observer.takeRecords();
  };
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop,
    takeRecords
  };
}
function onElementRemoval(target, callback, options = {}) {
  const {
    window: window2 = defaultWindow,
    document: document2 = window2 == null ? void 0 : window2.document,
    flush = "sync"
  } = options;
  if (!window2 || !document2)
    return noop;
  let stopFn;
  const cleanupAndUpdate = (fn) => {
    stopFn == null ? void 0 : stopFn();
    stopFn = fn;
  };
  const stopWatch = watchEffect2(() => {
    const el = unrefElement(target);
    if (el) {
      const { stop } = useMutationObserver(
        document2,
        (mutationsList) => {
          const targetRemoved = mutationsList.map((mutation) => [...mutation.removedNodes]).flat().some((node) => node === el || node.contains(el));
          if (targetRemoved) {
            callback(mutationsList);
          }
        },
        {
          window: window2,
          childList: true,
          subtree: true
        }
      );
      cleanupAndUpdate(stop);
    }
  }, { flush });
  const stopHandle = () => {
    stopWatch();
    cleanupAndUpdate();
  };
  tryOnScopeDispose(stopHandle);
  return stopHandle;
}
function createKeyPredicate(keyFilter) {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  return () => true;
}
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const {
    target = defaultWindow,
    eventName = "keydown",
    passive = false,
    dedupe = false
  } = options;
  const predicate = createKeyPredicate(key);
  const listener = (e) => {
    if (e.repeat && toValue3(dedupe))
      return;
    if (predicate(e))
      handler(e);
  };
  return useEventListener(target, eventName, listener, passive);
}
function useActiveElement(options = {}) {
  var _a;
  const {
    window: window2 = defaultWindow,
    deep = true,
    triggerOnRemoval = false
  } = options;
  const document2 = (_a = options.document) != null ? _a : window2 == null ? void 0 : window2.document;
  const getDeepActiveElement = () => {
    var _a2;
    let element = document2 == null ? void 0 : document2.activeElement;
    if (deep) {
      while (element == null ? void 0 : element.shadowRoot)
        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;
    }
    return element;
  };
  const activeElement = shallowRef3();
  const trigger = () => {
    activeElement.value = getDeepActiveElement();
  };
  if (window2) {
    const listenerOptions = {
      capture: true,
      passive: true
    };
    useEventListener(
      window2,
      "blur",
      (event) => {
        if (event.relatedTarget !== null)
          return;
        trigger();
      },
      listenerOptions
    );
    useEventListener(
      window2,
      "focus",
      trigger,
      listenerOptions
    );
  }
  if (triggerOnRemoval) {
    onElementRemoval(activeElement, trigger, { document: document2 });
  }
  trigger();
  return activeElement;
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow,
    once = false
  } = options;
  const isActive = shallowRef3(false);
  const intervalLimit = computed3(() => {
    return fpsLimit ? 1e3 / toValue3(fpsLimit) : null;
  });
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta = timestamp2 - previousFrameTimestamp;
    if (intervalLimit.value && delta < intervalLimit.value) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta, timestamp: timestamp2 });
    if (once) {
      isActive.value = false;
      rafId = null;
      return;
    }
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly2(isActive),
    pause,
    resume
  };
}
var ssrWidthSymbol = Symbol("vueuse-ssr-width");
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function useCurrentElement(rootComponent) {
  const vm = getCurrentInstance2();
  const currentElement = computedWithControl(
    () => null,
    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el
  );
  onUpdated(currentElement.trigger);
  onMounted2(currentElement.trigger);
  return currentElement;
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed3(() => {
    const _targets = toValue3(target);
    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];
  });
  const stopWatch = watch3(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
var EVENT_FOCUS_IN = "focusin";
var EVENT_FOCUS_OUT = "focusout";
var PSEUDO_CLASS_FOCUS_WITHIN = ":focus-within";
function useFocusWithin(target, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const targetElement = computed3(() => unrefElement(target));
  const _focused = shallowRef3(false);
  const focused = computed3(() => _focused.value);
  const activeElement = useActiveElement(options);
  if (!window2 || !activeElement.value) {
    return { focused };
  }
  const listenerOptions = { passive: true };
  useEventListener(targetElement, EVENT_FOCUS_IN, () => _focused.value = true, listenerOptions);
  useEventListener(targetElement, EVENT_FOCUS_OUT, () => {
    var _a, _b, _c;
    return _focused.value = (_c = (_b = (_a = targetElement.value) == null ? void 0 : _a.matches) == null ? void 0 : _b.call(_a, PSEUDO_CLASS_FOCUS_WITHIN)) != null ? _c : false;
  }, listenerOptions);
  return { focused };
}
function useParentElement(element = useCurrentElement()) {
  const parentElement = shallowRef3();
  const update = () => {
    const el = unrefElement(element);
    if (el)
      parentElement.value = el.parentElement;
  };
  tryOnMounted(update);
  watch3(() => toValue3(element), update);
  return parentElement;
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);
function useVModel(props2, key, emit, options = {}) {
  var _a, _b, _c;
  const {
    clone = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue,
    shouldEmit
  } = options;
  const vm = getCurrentInstance2();
  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event = eventName;
  if (!key) {
    key = "modelValue";
  }
  event = event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
  const getValue = () => isDef(props2[key]) ? cloneFn(props2[key]) : defaultValue;
  const triggerEmit = (value) => {
    if (shouldEmit) {
      if (shouldEmit(value))
        _emit(event, value);
    } else {
      _emit(event, value);
    }
  };
  if (passive) {
    const initialValue = getValue();
    const proxy = ref3(initialValue);
    let isUpdating = false;
    watch3(
      () => props2[key],
      (v) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = cloneFn(v);
          nextTick2(() => isUpdating = false);
        }
      }
    );
    watch3(
      proxy,
      (v) => {
        if (!isUpdating && (v !== props2[key] || deep))
          triggerEmit(v);
      },
      { deep }
    );
    return proxy;
  } else {
    return computed3({
      get() {
        return getValue();
      },
      set(value) {
        triggerEmit(value);
      }
    });
  }
}

// node_modules/reka-ui/dist/Accordion/AccordionContent.js
import { defineComponent as defineComponent11, createBlock as createBlock6, openBlock as openBlock6, unref as unref9, withCtx as withCtx6, renderSlot as renderSlot7 } from "vue";

// node_modules/reka-ui/dist/Accordion/AccordionItem.js
import { defineComponent as defineComponent8, computed as computed7, createBlock as createBlock4, openBlock as openBlock4, unref as unref7, withKeys, withCtx as withCtx4, renderSlot as renderSlot5 } from "vue";

// node_modules/reka-ui/dist/shared/createContext.js
import { inject as inject3, provide as provide2 } from "vue";
function createContext(providerComponentName, contextName) {
  const symbolDescription = typeof providerComponentName === "string" && !contextName ? `${providerComponentName}Context` : contextName;
  const injectionKey = Symbol(symbolDescription);
  const injectContext = (fallback) => {
    const context2 = inject3(injectionKey, fallback);
    if (context2)
      return context2;
    if (context2 === null)
      return context2;
    throw new Error(
      `Injection \`${injectionKey.toString()}\` not found. Component must be used within ${Array.isArray(providerComponentName) ? `one of the following components: ${providerComponentName.join(
        ", "
      )}` : `\`${providerComponentName}\``}`
    );
  };
  const provideContext = (contextValue) => {
    provide2(injectionKey, contextValue);
    return contextValue;
  };
  return [injectContext, provideContext];
}

// node_modules/reka-ui/dist/Accordion/AccordionRoot.js
import { defineComponent as defineComponent6, toRefs as toRefs3, createBlock as createBlock2, openBlock as openBlock2, unref as unref5, withCtx as withCtx2, renderSlot as renderSlot3 } from "vue";

// node_modules/ohash/dist/shared/ohash.D__AXeF1.mjs
function serialize(o) {
  return typeof o == "string" ? `'${o}'` : new c().serialize(o);
}
var c = function() {
  class o {
    #t = /* @__PURE__ */ new Map();
    compare(t, r) {
      const e = typeof t, n = typeof r;
      return e === "string" && n === "string" ? t.localeCompare(r) : e === "number" && n === "number" ? t - r : String.prototype.localeCompare.call(this.serialize(t, true), this.serialize(r, true));
    }
    serialize(t, r) {
      if (t === null) return "null";
      switch (typeof t) {
        case "string":
          return r ? t : `'${t}'`;
        case "bigint":
          return `${t}n`;
        case "object":
          return this.$object(t);
        case "function":
          return this.$function(t);
      }
      return String(t);
    }
    serializeObject(t) {
      const r = Object.prototype.toString.call(t);
      if (r !== "[object Object]") return this.serializeBuiltInType(r.length < 10 ? `unknown:${r}` : r.slice(8, -1), t);
      const e = t.constructor, n = e === Object || e === void 0 ? "" : e.name;
      if (n !== "" && globalThis[n] === e) return this.serializeBuiltInType(n, t);
      if (typeof t.toJSON == "function") {
        const i = t.toJSON();
        return n + (i !== null && typeof i == "object" ? this.$object(i) : `(${this.serialize(i)})`);
      }
      return this.serializeObjectEntries(n, Object.entries(t));
    }
    serializeBuiltInType(t, r) {
      const e = this["$" + t];
      if (e) return e.call(this, r);
      if (typeof r?.entries == "function") return this.serializeObjectEntries(t, r.entries());
      throw new Error(`Cannot serialize ${t}`);
    }
    serializeObjectEntries(t, r) {
      const e = Array.from(r).sort((i, a) => this.compare(i[0], a[0]));
      let n = `${t}{`;
      for (let i = 0; i < e.length; i++) {
        const [a, l] = e[i];
        n += `${this.serialize(a, true)}:${this.serialize(l)}`, i < e.length - 1 && (n += ",");
      }
      return n + "}";
    }
    $object(t) {
      let r = this.#t.get(t);
      return r === void 0 && (this.#t.set(t, `#${this.#t.size}`), r = this.serializeObject(t), this.#t.set(t, r)), r;
    }
    $function(t) {
      const r = Function.prototype.toString.call(t);
      return r.slice(-15) === "[native code] }" ? `${t.name || ""}()[native]` : `${t.name}(${t.length})${r.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(t) {
      let r = "[";
      for (let e = 0; e < t.length; e++) r += this.serialize(t[e]), e < t.length - 1 && (r += ",");
      return r + "]";
    }
    $Date(t) {
      try {
        return `Date(${t.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(t) {
      return `ArrayBuffer[${new Uint8Array(t).join(",")}]`;
    }
    $Set(t) {
      return `Set${this.$Array(Array.from(t).sort((r, e) => this.compare(r, e)))}`;
    }
    $Map(t) {
      return this.serializeObjectEntries("Map", t.entries());
    }
  }
  for (const s of ["Error", "RegExp", "URL"]) o.prototype["$" + s] = function(t) {
    return `${s}(${t})`;
  };
  for (const s of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) o.prototype["$" + s] = function(t) {
    return `${s}[${t.join(",")}]`;
  };
  for (const s of ["BigInt64Array", "BigUint64Array"]) o.prototype["$" + s] = function(t) {
    return `${s}[${t.join("n,")}${t.length > 0 ? "n" : ""}]`;
  };
  return o;
}();
function isEqual(object1, object2) {
  if (object1 === object2) {
    return true;
  }
  if (serialize(object1) === serialize(object2)) {
    return true;
  }
  return false;
}

// node_modules/reka-ui/dist/shared/useSingleOrMultipleValue.js
import { computed as computed4 } from "vue";

// node_modules/reka-ui/dist/shared/nullish.js
function isNullish(value) {
  return value === null || value === void 0;
}

// node_modules/reka-ui/dist/shared/isValueEqualOrExist.js
function isValueEqualOrExist(base, current) {
  if (isNullish(base))
    return false;
  if (Array.isArray(base)) {
    return base.some((val) => isEqual(val, current));
  } else {
    return isEqual(base, current);
  }
}

// node_modules/reka-ui/dist/shared/useSingleOrMultipleValue.js
function validateProps({ type, defaultValue, modelValue }) {
  const value = modelValue || defaultValue;
  const canTypeBeInferred = modelValue !== void 0 || defaultValue !== void 0;
  if (canTypeBeInferred)
    return Array.isArray(value) ? "multiple" : "single";
  else
    return type ?? "single";
}
function getDefaultType({ type, defaultValue, modelValue }) {
  if (type)
    return type;
  return validateProps({ type, defaultValue, modelValue });
}
function getDefaultValue({ type, defaultValue }) {
  if (defaultValue !== void 0)
    return defaultValue;
  return type === "single" ? void 0 : [];
}
function useSingleOrMultipleValue(props2, emits) {
  const type = computed4(() => getDefaultType(props2));
  const modelValue = useVModel(props2, "modelValue", emits, {
    defaultValue: getDefaultValue(props2),
    passive: props2.modelValue === void 0,
    deep: true
  });
  function changeModelValue(value) {
    if (type.value === "single") {
      modelValue.value = isEqual(value, modelValue.value) ? void 0 : value;
    } else {
      const modelValueArray = Array.isArray(modelValue.value) ? [...modelValue.value || []] : [modelValue.value].filter(Boolean);
      if (isValueEqualOrExist(modelValueArray, value)) {
        const index = modelValueArray.findIndex((i) => isEqual(i, value));
        modelValueArray.splice(index, 1);
      } else {
        modelValueArray.push(value);
      }
      modelValue.value = modelValueArray;
    }
  }
  const isSingle = computed4(() => type.value === "single");
  return {
    modelValue,
    changeModelValue,
    isSingle
  };
}

// node_modules/reka-ui/dist/shared/useDirection.js
import { ref as ref4, computed as computed5 } from "vue";

// node_modules/reka-ui/dist/ConfigProvider/ConfigProvider.js
import { defineComponent as defineComponent5, toRefs as toRefs2, renderSlot as renderSlot2 } from "vue";
var [injectConfigProviderContext, provideConfigProviderContext] = createContext("ConfigProvider");
var _sfc_main2 = defineComponent5({
  ...{
    inheritAttrs: false
  },
  __name: "ConfigProvider",
  props: {
    dir: { default: "ltr" },
    locale: { default: "en" },
    scrollBody: { type: [Boolean, Object], default: true },
    nonce: { default: void 0 },
    useId: { type: Function, default: void 0 }
  },
  setup(__props) {
    const props2 = __props;
    const { dir, locale, scrollBody, nonce } = toRefs2(props2);
    provideConfigProviderContext({
      dir,
      locale,
      scrollBody,
      nonce,
      useId: props2.useId
    });
    return (_ctx, _cache) => {
      return renderSlot2(_ctx.$slots, "default");
    };
  }
});

// node_modules/reka-ui/dist/shared/useDirection.js
function useDirection(dir) {
  const context2 = injectConfigProviderContext({
    dir: ref4("ltr")
  });
  return computed5(() => dir?.value || context2.dir?.value || "ltr");
}

// node_modules/reka-ui/dist/shared/useForwardExpose.js
import { getCurrentInstance as getCurrentInstance3, ref as ref5, computed as computed6 } from "vue";
function useForwardExpose() {
  const instance = getCurrentInstance3();
  const currentRef = ref5();
  const currentElement = computed6(() => {
    return ["#text", "#comment"].includes(currentRef.value?.$el.nodeName) ? currentRef.value?.$el.nextElementSibling : unrefElement(currentRef);
  });
  const localExpose = Object.assign({}, instance.exposed);
  const ret = {};
  for (const key in instance.props) {
    Object.defineProperty(ret, key, {
      enumerable: true,
      configurable: true,
      get: () => instance.props[key]
    });
  }
  if (Object.keys(localExpose).length > 0) {
    for (const key in localExpose) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        configurable: true,
        get: () => localExpose[key]
      });
    }
  }
  Object.defineProperty(ret, "$el", {
    enumerable: true,
    configurable: true,
    get: () => instance.vnode.el
  });
  instance.exposed = ret;
  function forwardRef(ref210) {
    currentRef.value = ref210;
    if (!ref210)
      return;
    Object.defineProperty(ret, "$el", {
      enumerable: true,
      configurable: true,
      get: () => ref210 instanceof Element ? ref210 : ref210.$el
    });
    instance.exposed = ret;
  }
  return { forwardRef, currentRef, currentElement };
}

// node_modules/reka-ui/dist/Accordion/AccordionRoot.js
var [injectAccordionRootContext, provideAccordionRootContext] = createContext("AccordionRoot");
var _sfc_main3 = defineComponent6({
  __name: "AccordionRoot",
  props: {
    collapsible: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    dir: {},
    orientation: { default: "vertical" },
    unmountOnHide: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { dir, disabled, unmountOnHide } = toRefs3(props2);
    const direction = useDirection(dir);
    const { modelValue, changeModelValue, isSingle } = useSingleOrMultipleValue(props2, emits);
    const { forwardRef, currentElement: parentElement } = useForwardExpose();
    provideAccordionRootContext({
      disabled,
      direction,
      orientation: props2.orientation,
      parentElement,
      isSingle,
      collapsible: props2.collapsible,
      modelValue,
      changeModelValue,
      unmountOnHide
    });
    return (_ctx, _cache) => {
      return openBlock2(), createBlock2(unref5(Primitive), {
        ref: unref5(forwardRef),
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx2(() => [
          renderSlot3(_ctx.$slots, "default", { modelValue: unref5(modelValue) })
        ]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});

// node_modules/reka-ui/dist/Collapsible/CollapsibleRoot.js
import { defineComponent as defineComponent7, toRefs as toRefs4, createBlock as createBlock3, openBlock as openBlock3, unref as unref6, withCtx as withCtx3, renderSlot as renderSlot4 } from "vue";
var [injectCollapsibleRootContext, provideCollapsibleRootContext] = createContext("CollapsibleRoot");
var _sfc_main4 = defineComponent7({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    unmountOnHide: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const { disabled, unmountOnHide } = toRefs4(props2);
    provideCollapsibleRootContext({
      contentId: "",
      disabled,
      open,
      unmountOnHide,
      onOpenToggle: () => {
        open.value = !open.value;
      }
    });
    __expose({ open });
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock3(), createBlock3(unref6(Primitive), {
        as: _ctx.as,
        "as-child": props2.asChild,
        "data-state": unref6(open) ? "open" : "closed",
        "data-disabled": unref6(disabled) ? "" : void 0
      }, {
        default: withCtx3(() => [
          renderSlot4(_ctx.$slots, "default", { open: unref6(open) })
        ]),
        _: 3
      }, 8, ["as", "as-child", "data-state", "data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/shared/useArrowNavigation.js
var ignoredElement = ["INPUT", "TEXTAREA"];
function useArrowNavigation(e, currentElement, parentElement, options = {}) {
  if (!currentElement || options.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName))
    return null;
  const {
    arrowKeyOptions = "both",
    attributeName = "[data-reka-collection-item]",
    itemsArray = [],
    loop = true,
    dir = "ltr",
    preventScroll = true,
    focus: focus2 = false
  } = options;
  const [right, left, up, down, home, end] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ];
  const goingVertical = up || down;
  const goingHorizontal = right || left;
  if (!home && !end && (!goingVertical && !goingHorizontal || arrowKeyOptions === "vertical" && goingHorizontal || arrowKeyOptions === "horizontal" && goingVertical)) {
    return null;
  }
  const allCollectionItems = parentElement ? Array.from(parentElement.querySelectorAll(attributeName)) : itemsArray;
  if (!allCollectionItems.length)
    return null;
  if (preventScroll)
    e.preventDefault();
  let item = null;
  if (goingHorizontal || goingVertical) {
    const goForward = goingVertical ? down : dir === "ltr" ? right : left;
    item = findNextFocusableElement(allCollectionItems, currentElement, {
      goForward,
      loop
    });
  } else if (home) {
    item = allCollectionItems.at(0) || null;
  } else if (end) {
    item = allCollectionItems.at(-1) || null;
  }
  if (focus2)
    item?.focus();
  return item;
}
function findNextFocusableElement(elements, currentElement, options, iterations = elements.length) {
  if (--iterations === 0)
    return null;
  const index = elements.indexOf(currentElement);
  const newIndex = options.goForward ? index + 1 : index - 1;
  if (!options.loop && (newIndex < 0 || newIndex >= elements.length))
    return null;
  const adjustedNewIndex = (newIndex + elements.length) % elements.length;
  const candidate = elements[adjustedNewIndex];
  if (!candidate)
    return null;
  const isDisabled = candidate.hasAttribute("disabled") && candidate.getAttribute("disabled") !== "false";
  if (isDisabled) {
    return findNextFocusableElement(
      elements,
      candidate,
      options,
      iterations
    );
  }
  return candidate;
}

// node_modules/reka-ui/dist/Accordion/AccordionItem.js
var [injectAccordionItemContext, provideAccordionItemContext] = createContext("AccordionItem");
var _sfc_main5 = defineComponent8({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props, { expose: __expose }) {
    const props2 = __props;
    const rootContext = injectAccordionRootContext();
    const open = computed7(
      () => rootContext.isSingle.value ? props2.value === rootContext.modelValue.value : Array.isArray(rootContext.modelValue.value) && rootContext.modelValue.value.includes(props2.value)
    );
    const disabled = computed7(() => {
      return rootContext.disabled.value || props2.disabled;
    });
    const dataDisabled = computed7(() => disabled.value ? "" : void 0);
    const dataState = computed7(
      () => open.value ? "open" : "closed"
      /* Closed */
    );
    __expose({ open, dataDisabled });
    const { currentRef, currentElement } = useForwardExpose();
    provideAccordionItemContext({
      open,
      dataState,
      disabled,
      dataDisabled,
      triggerId: "",
      currentRef,
      currentElement,
      value: computed7(() => props2.value)
    });
    function handleArrowKey(e) {
      const target = e.target;
      const allCollectionItems = Array.from(rootContext.parentElement.value?.querySelectorAll("[data-reka-collection-item]") ?? []);
      const collectionItemIndex = allCollectionItems.findIndex((item) => item === target);
      if (collectionItemIndex === -1)
        return null;
      useArrowNavigation(
        e,
        currentElement.value,
        rootContext.parentElement.value,
        {
          arrowKeyOptions: rootContext.orientation,
          dir: rootContext.direction.value,
          focus: true
        }
      );
    }
    return (_ctx, _cache) => {
      return openBlock4(), createBlock4(unref7(_sfc_main4), {
        "data-orientation": unref7(rootContext).orientation,
        "data-disabled": dataDisabled.value,
        "data-state": dataState.value,
        disabled: disabled.value,
        open: open.value,
        as: props2.as,
        "as-child": props2.asChild,
        "unmount-on-hide": unref7(rootContext).unmountOnHide.value,
        onKeydown: withKeys(handleArrowKey, ["up", "down", "left", "right", "home", "end"])
      }, {
        default: withCtx4(() => [
          renderSlot5(_ctx.$slots, "default", { open: open.value })
        ]),
        _: 3
      }, 8, ["data-orientation", "data-disabled", "data-state", "disabled", "open", "as", "as-child", "unmount-on-hide"]);
    };
  }
});

// node_modules/reka-ui/dist/Collapsible/CollapsibleContent.js
import { defineComponent as defineComponent10, ref as ref9, computed as computed9, watch as watch5, nextTick as nextTick4, onMounted as onMounted3, createBlock as createBlock5, openBlock as openBlock5, unref as unref8, withCtx as withCtx5, createVNode, mergeProps as mergeProps2, renderSlot as renderSlot6, createCommentVNode } from "vue";

// node_modules/reka-ui/dist/shared/useId.js
import * as vue from "vue";
var count = 0;
function useId2(deterministicId, prefix = "reka") {
  if (deterministicId)
    return deterministicId;
  const configProviderContext = injectConfigProviderContext({ useId: void 0 });
  if (vue.useId) {
    return `${prefix}-${vue.useId()}`;
  } else if (configProviderContext.useId) {
    return `${prefix}-${configProviderContext.useId()}`;
  }
  return `${prefix}-${++count}`;
}

// node_modules/reka-ui/dist/Presence/Presence.js
import { defineComponent as defineComponent9, toRefs as toRefs5, ref as ref8, getCurrentInstance as getCurrentInstance4, h as h3 } from "vue";

// node_modules/reka-ui/dist/Presence/usePresence.js
import { ref as ref7, watch as watch4, nextTick as nextTick3, onUnmounted as onUnmounted2, computed as computed8 } from "vue";

// node_modules/reka-ui/dist/shared/useStateMachine.js
import { ref as ref6 } from "vue";
function useStateMachine(initialState, machine) {
  const state = ref6(initialState);
  function reducer(event) {
    const nextState = machine[state.value][event];
    return nextState ?? state.value;
  }
  const dispatch = (event) => {
    state.value = reducer(event);
  };
  return {
    state,
    dispatch
  };
}

// node_modules/reka-ui/dist/Presence/usePresence.js
function usePresence(present, node) {
  const stylesRef = ref7({});
  const prevAnimationNameRef = ref7("none");
  const prevPresentRef = ref7(present);
  const initialState = present.value ? "mounted" : "unmounted";
  let timeoutId;
  const ownerWindow = node.value?.ownerDocument.defaultView ?? defaultWindow;
  const { state, dispatch } = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  const dispatchCustomEvent = (name) => {
    if (isClient) {
      const customEvent = new CustomEvent(name, { bubbles: false, cancelable: false });
      node.value?.dispatchEvent(customEvent);
    }
  };
  watch4(
    present,
    async (currentPresent, prevPresent) => {
      const hasPresentChanged = prevPresent !== currentPresent;
      await nextTick3();
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.value;
        const currentAnimationName = getAnimationName(node.value);
        if (currentPresent) {
          dispatch("MOUNT");
          dispatchCustomEvent("enter");
          if (currentAnimationName === "none")
            dispatchCustomEvent("after-enter");
        } else if (currentAnimationName === "none" || currentAnimationName === "undefined" || stylesRef.value?.display === "none") {
          dispatch("UNMOUNT");
          dispatchCustomEvent("leave");
          dispatchCustomEvent("after-leave");
        } else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (prevPresent && isAnimating) {
            dispatch("ANIMATION_OUT");
            dispatchCustomEvent("leave");
          } else {
            dispatch("UNMOUNT");
            dispatchCustomEvent("after-leave");
          }
        }
      }
    },
    { immediate: true }
  );
  const handleAnimationEnd = (event) => {
    const currentAnimationName = getAnimationName(node.value);
    const isCurrentAnimation = currentAnimationName.includes(
      event.animationName
    );
    const directionName = state.value === "mounted" ? "enter" : "leave";
    if (event.target === node.value && isCurrentAnimation) {
      dispatchCustomEvent(`after-${directionName}`);
      dispatch("ANIMATION_END");
      if (!prevPresentRef.value) {
        const currentFillMode = node.value.style.animationFillMode;
        node.value.style.animationFillMode = "forwards";
        timeoutId = ownerWindow?.setTimeout(() => {
          if (node.value?.style.animationFillMode === "forwards") {
            node.value.style.animationFillMode = currentFillMode;
          }
        });
      }
    }
    if (event.target === node.value && currentAnimationName === "none")
      dispatch("ANIMATION_END");
  };
  const handleAnimationStart = (event) => {
    if (event.target === node.value) {
      prevAnimationNameRef.value = getAnimationName(node.value);
    }
  };
  const watcher = watch4(
    node,
    (newNode, oldNode) => {
      if (newNode) {
        stylesRef.value = getComputedStyle(newNode);
        newNode.addEventListener("animationstart", handleAnimationStart);
        newNode.addEventListener("animationcancel", handleAnimationEnd);
        newNode.addEventListener("animationend", handleAnimationEnd);
      } else {
        dispatch("ANIMATION_END");
        if (timeoutId !== void 0)
          ownerWindow?.clearTimeout(timeoutId);
        oldNode?.removeEventListener("animationstart", handleAnimationStart);
        oldNode?.removeEventListener("animationcancel", handleAnimationEnd);
        oldNode?.removeEventListener("animationend", handleAnimationEnd);
      }
    },
    { immediate: true }
  );
  const stateWatcher = watch4(state, () => {
    const currentAnimationName = getAnimationName(node.value);
    prevAnimationNameRef.value = state.value === "mounted" ? currentAnimationName : "none";
  });
  onUnmounted2(() => {
    watcher();
    stateWatcher();
  });
  const isPresent = computed8(
    () => ["mounted", "unmountSuspended"].includes(state.value)
  );
  return {
    isPresent
  };
}
function getAnimationName(node) {
  return node ? getComputedStyle(node).animationName || "none" : "none";
}

// node_modules/reka-ui/dist/Presence/Presence.js
var Presence = defineComponent9({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: true
    },
    forceMount: {
      type: Boolean
    }
  },
  slots: {},
  setup(props2, { slots, expose }) {
    const { present, forceMount } = toRefs5(props2);
    const node = ref8();
    const { isPresent } = usePresence(present, node);
    expose({ present: isPresent });
    let children = slots.default({ present: isPresent.value });
    children = renderSlotFragments(children || []);
    const instance = getCurrentInstance4();
    if (children && children?.length > 1) {
      const componentName = instance?.parent?.type.name ? `<${instance.parent.type.name} />` : "component";
      throw new Error(
        [
          `Detected an invalid children for \`${componentName}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((line) => `  - ${line}`).join("\n")
        ].join("\n")
      );
    }
    return () => {
      if (forceMount.value || present.value || isPresent.value) {
        return h3(slots.default({ present: isPresent.value })[0], {
          ref: (v) => {
            const el = unrefElement(v);
            if (typeof el?.hasAttribute === "undefined")
              return el;
            if (el?.hasAttribute("data-reka-popper-content-wrapper"))
              node.value = el.firstElementChild;
            else
              node.value = el;
            return el;
          }
        });
      } else {
        return null;
      }
    };
  }
});

// node_modules/reka-ui/dist/Collapsible/CollapsibleContent.js
var _sfc_main6 = defineComponent10({
  ...{
    inheritAttrs: false
  },
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["contentFound"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectCollapsibleRootContext();
    rootContext.contentId ||= useId2(void 0, "reka-collapsible-content");
    const presentRef = ref9();
    const { forwardRef, currentElement } = useForwardExpose();
    const width = ref9(0);
    const height = ref9(0);
    const isOpen = computed9(() => rootContext.open.value);
    const isMountAnimationPrevented = ref9(isOpen.value);
    const currentStyle = ref9();
    watch5(
      () => [isOpen.value, presentRef.value?.present],
      async () => {
        await nextTick4();
        const node = currentElement.value;
        if (!node)
          return;
        currentStyle.value = currentStyle.value || {
          transitionDuration: node.style.transitionDuration,
          animationName: node.style.animationName
        };
        node.style.transitionDuration = "0s";
        node.style.animationName = "none";
        const rect = node.getBoundingClientRect();
        height.value = rect.height;
        width.value = rect.width;
        if (!isMountAnimationPrevented.value) {
          node.style.transitionDuration = currentStyle.value.transitionDuration;
          node.style.animationName = currentStyle.value.animationName;
        }
      },
      {
        immediate: true
      }
    );
    const skipAnimation = computed9(() => isMountAnimationPrevented.value && rootContext.open.value);
    onMounted3(() => {
      requestAnimationFrame(() => {
        isMountAnimationPrevented.value = false;
      });
    });
    useEventListener(currentElement, "beforematch", (ev) => {
      requestAnimationFrame(() => {
        rootContext.onOpenToggle();
        emits("contentFound");
      });
    });
    return (_ctx, _cache) => {
      return openBlock5(), createBlock5(unref8(Presence), {
        ref_key: "presentRef",
        ref: presentRef,
        present: _ctx.forceMount || unref8(rootContext).open.value,
        "force-mount": true
      }, {
        default: withCtx5(({ present }) => [
          createVNode(unref8(Primitive), mergeProps2(_ctx.$attrs, {
            id: unref8(rootContext).contentId,
            ref: unref8(forwardRef),
            "as-child": props2.asChild,
            as: _ctx.as,
            hidden: !present ? unref8(rootContext).unmountOnHide.value ? "" : "until-found" : void 0,
            "data-state": skipAnimation.value ? void 0 : unref8(rootContext).open.value ? "open" : "closed",
            "data-disabled": unref8(rootContext).disabled?.value ? "" : void 0,
            style: {
              [`--reka-collapsible-content-height`]: `${height.value}px`,
              [`--reka-collapsible-content-width`]: `${width.value}px`
            }
          }), {
            default: withCtx5(() => [
              (unref8(rootContext).unmountOnHide.value ? present : true) ? renderSlot6(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
            ]),
            _: 2
          }, 1040, ["id", "as-child", "as", "hidden", "data-state", "data-disabled", "style"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/Accordion/AccordionContent.js
var _sfc_main7 = defineComponent11({
  __name: "AccordionContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock6(), createBlock6(unref9(_sfc_main6), {
        role: "region",
        "as-child": props2.asChild,
        as: _ctx.as,
        "force-mount": props2.forceMount,
        "aria-labelledby": unref9(itemContext).triggerId,
        "data-state": unref9(itemContext).dataState.value,
        "data-disabled": unref9(itemContext).dataDisabled.value,
        "data-orientation": unref9(rootContext).orientation,
        style: { "--reka-accordion-content-width": "var(--reka-collapsible-content-width)", "--reka-accordion-content-height": "var(--reka-collapsible-content-height)" },
        onContentFound: _cache[0] || (_cache[0] = ($event) => unref9(rootContext).changeModelValue(unref9(itemContext).value.value))
      }, {
        default: withCtx6(() => [
          renderSlot7(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as", "force-mount", "aria-labelledby", "data-state", "data-disabled", "data-orientation"]);
    };
  }
});

// node_modules/reka-ui/dist/Accordion/AccordionHeader.js
import { defineComponent as defineComponent12, createBlock as createBlock7, openBlock as openBlock7, unref as unref10, withCtx as withCtx7, renderSlot as renderSlot8 } from "vue";
var _sfc_main8 = defineComponent12({
  __name: "AccordionHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "h3" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock7(), createBlock7(unref10(Primitive), {
        as: props2.as,
        "as-child": props2.asChild,
        "data-orientation": unref10(rootContext).orientation,
        "data-state": unref10(itemContext).dataState.value,
        "data-disabled": unref10(itemContext).dataDisabled.value
      }, {
        default: withCtx7(() => [
          renderSlot8(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "data-orientation", "data-state", "data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Accordion/AccordionTrigger.js
import { defineComponent as defineComponent14, createBlock as createBlock9, openBlock as openBlock9, unref as unref12, withCtx as withCtx9, renderSlot as renderSlot10 } from "vue";

// node_modules/reka-ui/dist/Collapsible/CollapsibleTrigger.js
import { defineComponent as defineComponent13, createBlock as createBlock8, openBlock as openBlock8, unref as unref11, withCtx as withCtx8, renderSlot as renderSlot9 } from "vue";
var _sfc_main9 = defineComponent13({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectCollapsibleRootContext();
    return (_ctx, _cache) => {
      return openBlock8(), createBlock8(unref11(Primitive), {
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "as-child": props2.asChild,
        "aria-controls": unref11(rootContext).contentId,
        "aria-expanded": unref11(rootContext).open.value,
        "data-state": unref11(rootContext).open.value ? "open" : "closed",
        "data-disabled": unref11(rootContext).disabled?.value ? "" : void 0,
        disabled: unref11(rootContext).disabled?.value,
        onClick: unref11(rootContext).onOpenToggle
      }, {
        default: withCtx8(() => [
          renderSlot9(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child", "aria-controls", "aria-expanded", "data-state", "data-disabled", "disabled", "onClick"]);
    };
  }
});

// node_modules/reka-ui/dist/Accordion/AccordionTrigger.js
var _sfc_main10 = defineComponent14({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    itemContext.triggerId ||= useId2(void 0, "reka-accordion-trigger");
    function changeItem() {
      const triggerDisabled = rootContext.isSingle.value && itemContext.open.value && !rootContext.collapsible;
      if (itemContext.disabled.value || triggerDisabled)
        return;
      rootContext.changeModelValue(itemContext.value.value);
    }
    return (_ctx, _cache) => {
      return openBlock9(), createBlock9(unref12(_sfc_main9), {
        id: unref12(itemContext).triggerId,
        ref: unref12(itemContext).currentRef,
        "data-reka-collection-item": "",
        as: props2.as,
        "as-child": props2.asChild,
        "aria-disabled": unref12(itemContext).disabled.value || void 0,
        "aria-expanded": unref12(itemContext).open.value || false,
        "data-disabled": unref12(itemContext).dataDisabled.value,
        "data-orientation": unref12(rootContext).orientation,
        "data-state": unref12(itemContext).dataState.value,
        disabled: unref12(itemContext).disabled.value,
        onClick: changeItem
      }, {
        default: withCtx9(() => [
          renderSlot10(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "as", "as-child", "aria-disabled", "aria-expanded", "data-disabled", "data-orientation", "data-state", "disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogAction.js
import { defineComponent as defineComponent17, createBlock as createBlock11, openBlock as openBlock11, unref as unref15, normalizeProps, guardReactiveProps, withCtx as withCtx11, renderSlot as renderSlot13 } from "vue";

// node_modules/reka-ui/dist/Dialog/DialogClose.js
import { defineComponent as defineComponent16, createBlock as createBlock10, openBlock as openBlock10, unref as unref14, mergeProps as mergeProps3, withCtx as withCtx10, renderSlot as renderSlot12 } from "vue";

// node_modules/reka-ui/dist/Dialog/DialogRoot.js
import { defineComponent as defineComponent15, ref as ref10, toRefs as toRefs6, renderSlot as renderSlot11, unref as unref13 } from "vue";
var [injectDialogRootContext, provideDialogRootContext] = createContext("DialogRoot");
var _sfc_main11 = defineComponent15({
  ...{
    inheritAttrs: false
  },
  __name: "DialogRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: false },
    modal: { type: Boolean, default: true }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const triggerElement = ref10();
    const contentElement = ref10();
    const { modal } = toRefs6(props2);
    provideDialogRootContext({
      open,
      modal,
      openModal: () => {
        open.value = true;
      },
      onOpenChange: (value) => {
        open.value = value;
      },
      onOpenToggle: () => {
        open.value = !open.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement,
      contentElement
    });
    return (_ctx, _cache) => {
      return renderSlot11(_ctx.$slots, "default", { open: unref13(open) });
    };
  }
});

// node_modules/reka-ui/dist/Dialog/DialogClose.js
var _sfc_main12 = defineComponent16({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectDialogRootContext();
    return (_ctx, _cache) => {
      return openBlock10(), createBlock10(unref14(Primitive), mergeProps3(props2, {
        type: _ctx.as === "button" ? "button" : void 0,
        onClick: _cache[0] || (_cache[0] = ($event) => unref14(rootContext).onOpenChange(false))
      }), {
        default: withCtx10(() => [
          renderSlot12(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["type"]);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogAction.js
var _sfc_main13 = defineComponent17({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock11(), createBlock11(unref15(_sfc_main12), normalizeProps(guardReactiveProps(props2)), {
        default: withCtx11(() => [
          renderSlot13(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogCancel.js
import { defineComponent as defineComponent25, onMounted as onMounted6, createBlock as createBlock19, openBlock as openBlock19, unref as unref23, mergeProps as mergeProps9, withCtx as withCtx19, renderSlot as renderSlot21 } from "vue";

// node_modules/reka-ui/dist/AlertDialog/AlertDialogContent.js
import { defineComponent as defineComponent24, ref as ref15, createBlock as createBlock18, openBlock as openBlock18, unref as unref22, mergeProps as mergeProps8, withModifiers, nextTick as nextTick8, withCtx as withCtx18, renderSlot as renderSlot20 } from "vue";

// node_modules/reka-ui/dist/shared/useEmitAsProps.js
import { getCurrentInstance as getCurrentInstance5, toHandlerKey, camelize as camelize2 } from "vue";
function useEmitAsProps(emit) {
  const vm = getCurrentInstance5();
  const events = vm?.type.emits;
  const result = {};
  if (!events?.length) {
    console.warn(
      `No emitted event found. Please check component: ${vm?.type.__name}`
    );
  }
  events?.forEach((ev) => {
    result[toHandlerKey(camelize2(ev))] = (...arg) => emit(ev, ...arg);
  });
  return result;
}

// node_modules/reka-ui/dist/Dialog/DialogContent.js
import { defineComponent as defineComponent23, createBlock as createBlock17, openBlock as openBlock17, unref as unref21, withCtx as withCtx17, mergeProps as mergeProps7, renderSlot as renderSlot19 } from "vue";

// node_modules/reka-ui/dist/Dialog/DialogContentModal.js
import { defineComponent as defineComponent21, createBlock as createBlock15, openBlock as openBlock15, mergeProps as mergeProps5, unref as unref19, withCtx as withCtx15, renderSlot as renderSlot17 } from "vue";

// node_modules/reka-ui/dist/Dialog/DialogContentImpl.js
import { defineComponent as defineComponent20, onMounted as onMounted5, createBlock as createBlock14, openBlock as openBlock14, unref as unref18, withCtx as withCtx14, createVNode as createVNode2, mergeProps as mergeProps4, renderSlot as renderSlot16 } from "vue";

// node_modules/reka-ui/dist/DismissableLayer/DismissableLayer.js
import { defineComponent as defineComponent18, computed as computed10, reactive as reactive3, watchEffect as watchEffect4, createBlock as createBlock12, openBlock as openBlock12, unref as unref16, normalizeStyle, withCtx as withCtx12, renderSlot as renderSlot14, nextTick as nextTick6 } from "vue";

// node_modules/reka-ui/dist/DismissableLayer/utils.js
import { ref as ref11, watchEffect as watchEffect3, nextTick as nextTick5 } from "vue";

// node_modules/reka-ui/dist/shared/handleAndDispatchCustomEvent.js
function handleAndDispatchCustomEvent(name, handler, detail) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  target.dispatchEvent(event);
}

// node_modules/reka-ui/dist/DismissableLayer/utils.js
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
function isLayerExist(layerElement, targetElement) {
  const targetLayer = targetElement.closest(
    "[data-dismissable-layer]"
  );
  const mainLayer = layerElement.dataset.dismissableLayer === "" ? layerElement : layerElement.querySelector(
    "[data-dismissable-layer]"
  );
  const nodeList = Array.from(
    layerElement.ownerDocument.querySelectorAll("[data-dismissable-layer]")
  );
  if (targetLayer && (mainLayer === targetLayer || nodeList.indexOf(mainLayer) < nodeList.indexOf(targetLayer))) {
    return true;
  } else {
    return false;
  }
}
function usePointerDownOutside(onPointerDownOutside, element) {
  const ownerDocument = element?.value?.ownerDocument ?? globalThis?.document;
  const isPointerInsideDOMTree = ref11(false);
  const handleClickRef = ref11(() => {
  });
  watchEffect3((cleanupFn) => {
    if (!isClient)
      return;
    const handlePointerDown2 = async (event) => {
      const target = event.target;
      if (!element?.value || !target)
        return;
      if (isLayerExist(element.value, target)) {
        isPointerInsideDOMTree.value = false;
        return;
      }
      if (event.target && !isPointerInsideDOMTree.value) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            onPointerDownOutside,
            eventDetail
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.value);
          handleClickRef.value = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClickRef.value, {
            once: true
          });
        } else {
          handleAndDispatchPointerDownOutsideEvent();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.value);
      }
      isPointerInsideDOMTree.value = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown2);
    }, 0);
    cleanupFn(() => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown2);
      ownerDocument.removeEventListener("click", handleClickRef.value);
    });
  });
  return {
    onPointerDownCapture: () => isPointerInsideDOMTree.value = true
  };
}
function useFocusOutside(onFocusOutside, element) {
  const ownerDocument = element?.value?.ownerDocument ?? globalThis?.document;
  const isFocusInsideDOMTree = ref11(false);
  watchEffect3((cleanupFn) => {
    if (!isClient)
      return;
    const handleFocus = async (event) => {
      if (!element?.value)
        return;
      await nextTick5();
      await nextTick5();
      const target = event.target;
      if (!element.value || !target || isLayerExist(element.value, target))
        return;
      if (event.target && !isFocusInsideDOMTree.value) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(
          FOCUS_OUTSIDE,
          onFocusOutside,
          eventDetail
        );
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    cleanupFn(() => ownerDocument.removeEventListener("focusin", handleFocus));
  });
  return {
    onFocusCapture: () => isFocusInsideDOMTree.value = true,
    onBlurCapture: () => isFocusInsideDOMTree.value = false
  };
}

// node_modules/reka-ui/dist/DismissableLayer/DismissableLayer.js
var context = reactive3({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var _sfc_main14 = defineComponent18({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement: layerElement } = useForwardExpose();
    const ownerDocument = computed10(
      () => layerElement.value?.ownerDocument ?? globalThis.document
    );
    const layers = computed10(() => context.layersRoot);
    const index = computed10(() => {
      return layerElement.value ? Array.from(layers.value).indexOf(layerElement.value) : -1;
    });
    const isBodyPointerEventsDisabled = computed10(() => {
      return context.layersWithOutsidePointerEventsDisabled.size > 0;
    });
    const isPointerEventsEnabled = computed10(() => {
      const localLayers = Array.from(layers.value);
      const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
      const highestLayerWithOutsidePointerEventsDisabledIndex = localLayers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
      return index.value >= highestLayerWithOutsidePointerEventsDisabledIndex;
    });
    const pointerDownOutside = usePointerDownOutside(async (event) => {
      const isPointerDownOnBranch = [...context.branches].some(
        (branch) => branch?.contains(event.target)
      );
      if (!isPointerEventsEnabled.value || isPointerDownOnBranch)
        return;
      emits("pointerDownOutside", event);
      emits("interactOutside", event);
      await nextTick6();
      if (!event.defaultPrevented)
        emits("dismiss");
    }, layerElement);
    const focusOutside = useFocusOutside((event) => {
      const isFocusInBranch = [...context.branches].some(
        (branch) => branch?.contains(event.target)
      );
      if (isFocusInBranch)
        return;
      emits("focusOutside", event);
      emits("interactOutside", event);
      if (!event.defaultPrevented)
        emits("dismiss");
    }, layerElement);
    onKeyStroke("Escape", (event) => {
      const isHighestLayer = index.value === layers.value.size - 1;
      if (!isHighestLayer)
        return;
      emits("escapeKeyDown", event);
      if (!event.defaultPrevented)
        emits("dismiss");
    });
    let originalBodyPointerEvents;
    watchEffect4((cleanupFn) => {
      if (!layerElement.value)
        return;
      if (props2.disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.value.body.style.pointerEvents;
          ownerDocument.value.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(layerElement.value);
      }
      layers.value.add(layerElement.value);
      cleanupFn(() => {
        if (props2.disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.value.body.style.pointerEvents = originalBodyPointerEvents;
        }
      });
    });
    watchEffect4((cleanupFn) => {
      cleanupFn(() => {
        if (!layerElement.value)
          return;
        layers.value.delete(layerElement.value);
        context.layersWithOutsidePointerEventsDisabled.delete(layerElement.value);
      });
    });
    return (_ctx, _cache) => {
      return openBlock12(), createBlock12(unref16(Primitive), {
        ref: unref16(forwardRef),
        "as-child": _ctx.asChild,
        as: _ctx.as,
        "data-dismissable-layer": "",
        style: normalizeStyle({
          pointerEvents: isBodyPointerEventsDisabled.value ? isPointerEventsEnabled.value ? "auto" : "none" : void 0
        }),
        onFocusCapture: unref16(focusOutside).onFocusCapture,
        onBlurCapture: unref16(focusOutside).onBlurCapture,
        onPointerdownCapture: unref16(pointerDownOutside).onPointerDownCapture
      }, {
        default: withCtx12(() => [
          renderSlot14(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]);
    };
  }
});

// node_modules/reka-ui/dist/shared/getActiveElement.js
function getActiveElement() {
  let activeElement = document.activeElement;
  if (activeElement == null) {
    return null;
  }
  while (activeElement != null && activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement != null) {
    activeElement = activeElement.shadowRoot.activeElement;
  }
  return activeElement;
}

// node_modules/reka-ui/dist/Menu/utils.js
var ITEM_SELECT = "menu.itemSelect";
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement();
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon(cursorPos, area);
}
function isMouseEvent(event) {
  return event.pointerType === "mouse";
}

// node_modules/reka-ui/dist/Dialog/utils.js
import { onMounted as onMounted4 } from "vue";
var DEFAULT_TITLE_NAME = "DialogTitle";
var DEFAULT_CONTENT_NAME = "DialogContent";
function useWarning({
  titleName = DEFAULT_TITLE_NAME,
  contentName = DEFAULT_CONTENT_NAME,
  componentLink = "dialog.html#title",
  titleId,
  descriptionId,
  contentElement
}) {
  const TITLE_MESSAGE = `Warning: \`${contentName}\` requires a \`${titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.reka-ui.com/docs/components/${componentLink}`;
  const DESCRIPTION_MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${contentName}.`;
  onMounted4(() => {
    const hasTitle = document.getElementById(titleId);
    if (!hasTitle)
      console.warn(TITLE_MESSAGE);
    const describedById = contentElement.value?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(DESCRIPTION_MESSAGE);
    }
  });
}

// node_modules/reka-ui/dist/FocusScope/FocusScope.js
import { defineComponent as defineComponent19, ref as ref13, reactive as reactive4, watchEffect as watchEffect5, nextTick as nextTick7, createBlock as createBlock13, openBlock as openBlock13, unref as unref17, withCtx as withCtx13, renderSlot as renderSlot15 } from "vue";

// node_modules/reka-ui/dist/FocusScope/stack.js
import { ref as ref12 } from "vue";
var useFocusStackState = createGlobalState(() => {
  const stack = ref12([]);
  return stack;
});
function createFocusScopesStack() {
  const stack = useFocusStackState();
  return {
    add(focusScope) {
      const activeFocusScope = stack.value[0];
      if (focusScope !== activeFocusScope)
        activeFocusScope?.pause();
      stack.value = arrayRemove(stack.value, focusScope);
      stack.value.unshift(focusScope);
    },
    remove(focusScope) {
      stack.value = arrayRemove(stack.value, focusScope);
      stack.value[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1)
    updatedArray.splice(index, 1);
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// node_modules/reka-ui/dist/FocusScope/utils.js
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
function focusFirst2(candidates, { select = false } = {}) {
  const previouslyFocusedElement = getActiveElement();
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (getActiveElement() !== previouslyFocusedElement)
      return true;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = getActiveElement();
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select) {
      element.select();
    }
  }
}

// node_modules/reka-ui/dist/FocusScope/FocusScope.js
var _sfc_main15 = defineComponent19({
  __name: "FocusScope",
  props: {
    loop: { type: Boolean, default: false },
    trapped: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { currentRef, currentElement } = useForwardExpose();
    const lastFocusedElementRef = ref13(null);
    const focusScopesStack = createFocusScopesStack();
    const focusScope = reactive4({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    });
    watchEffect5((cleanupFn) => {
      if (!isClient)
        return;
      const container = currentElement.value;
      if (!props2.trapped)
        return;
      function handleFocusIn(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target))
          lastFocusedElementRef.value = target;
        else focus(lastFocusedElementRef.value, { select: true });
      }
      function handleFocusOut(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget))
          focus(lastFocusedElementRef.value, { select: true });
      }
      function handleMutations(mutations) {
        const isLastFocusedElementExist = container.contains(lastFocusedElementRef.value);
        if (!isLastFocusedElementExist)
          focus(container);
      }
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      const mutationObserver = new MutationObserver(handleMutations);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      cleanupFn(() => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
        mutationObserver.disconnect();
      });
    });
    watchEffect5(async (cleanupFn) => {
      const container = currentElement.value;
      await nextTick7();
      if (!container)
        return;
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = getActiveElement();
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst2(removeLinks(getTabbableCandidates(container)), {
            select: true
          });
          if (getActiveElement() === previouslyFocusedElement)
            focus(container);
        }
      }
      cleanupFn(() => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
        const unmountEventHandler = (ev) => {
          emits("unmountAutoFocus", ev);
        };
        container.addEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
        container.dispatchEvent(unmountEvent);
        setTimeout(() => {
          if (!unmountEvent.defaultPrevented)
            focus(previouslyFocusedElement ?? document.body, { select: true });
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
          focusScopesStack.remove(focusScope);
        }, 0);
      });
    });
    function handleKeyDown(event) {
      if (!props2.loop && !props2.trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = getActiveElement();
      if (isTabKey && focusedElement) {
        const container = event.currentTarget;
        const [first, last] = getTabbableEdges(container);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (props2.loop)
              focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (props2.loop)
              focus(last, { select: true });
          }
        }
      }
    }
    return (_ctx, _cache) => {
      return openBlock13(), createBlock13(unref17(Primitive), {
        ref_key: "currentRef",
        ref: currentRef,
        tabindex: "-1",
        "as-child": _ctx.asChild,
        as: _ctx.as,
        onKeydown: handleKeyDown
      }, {
        default: withCtx13(() => [
          renderSlot15(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});

// node_modules/reka-ui/dist/Dialog/DialogContentImpl.js
var _sfc_main16 = defineComponent20({
  __name: "DialogContentImpl",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectDialogRootContext();
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    rootContext.titleId ||= useId2(void 0, "reka-dialog-title");
    rootContext.descriptionId ||= useId2(void 0, "reka-dialog-description");
    onMounted5(() => {
      rootContext.contentElement = contentElement;
      if (getActiveElement() !== document.body)
        rootContext.triggerElement.value = getActiveElement();
    });
    if (true) {
      useWarning({
        titleName: "DialogTitle",
        contentName: "DialogContent",
        componentLink: "dialog.html#title",
        titleId: rootContext.titleId,
        descriptionId: rootContext.descriptionId,
        contentElement
      });
    }
    return (_ctx, _cache) => {
      return openBlock14(), createBlock14(unref18(_sfc_main15), {
        "as-child": "",
        loop: "",
        trapped: props2.trapFocus,
        onMountAutoFocus: _cache[5] || (_cache[5] = ($event) => emits("openAutoFocus", $event)),
        onUnmountAutoFocus: _cache[6] || (_cache[6] = ($event) => emits("closeAutoFocus", $event))
      }, {
        default: withCtx14(() => [
          createVNode2(unref18(_sfc_main14), mergeProps4({
            id: unref18(rootContext).contentId,
            ref: unref18(forwardRef),
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "disable-outside-pointer-events": _ctx.disableOutsidePointerEvents,
            role: "dialog",
            "aria-describedby": unref18(rootContext).descriptionId,
            "aria-labelledby": unref18(rootContext).titleId,
            "data-state": unref18(getOpenState)(unref18(rootContext).open.value)
          }, _ctx.$attrs, {
            onDismiss: _cache[0] || (_cache[0] = ($event) => unref18(rootContext).onOpenChange(false)),
            onEscapeKeyDown: _cache[1] || (_cache[1] = ($event) => emits("escapeKeyDown", $event)),
            onFocusOutside: _cache[2] || (_cache[2] = ($event) => emits("focusOutside", $event)),
            onInteractOutside: _cache[3] || (_cache[3] = ($event) => emits("interactOutside", $event)),
            onPointerDownOutside: _cache[4] || (_cache[4] = ($event) => emits("pointerDownOutside", $event))
          }), {
            default: withCtx14(() => [
              renderSlot16(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["id", "as", "as-child", "disable-outside-pointer-events", "aria-describedby", "aria-labelledby", "data-state"])
        ]),
        _: 3
      }, 8, ["trapped"]);
    };
  }
});

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/reka-ui/dist/shared/useHideOthers.js
import { watch as watch6, onUnmounted as onUnmounted3 } from "vue";
function useHideOthers(target) {
  let undo;
  watch6(() => unrefElement(target), (el) => {
    if (el)
      undo = hideOthers(el);
    else if (undo)
      undo();
  });
  onUnmounted3(() => {
    if (undo)
      undo();
  });
}

// node_modules/reka-ui/dist/Dialog/DialogContentModal.js
var _sfc_main17 = defineComponent21({
  __name: "DialogContentModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectDialogRootContext();
    const emitsAsProps = useEmitAsProps(emits);
    const { forwardRef, currentElement } = useForwardExpose();
    useHideOthers(currentElement);
    return (_ctx, _cache) => {
      return openBlock15(), createBlock15(_sfc_main16, mergeProps5({ ...props2, ...unref19(emitsAsProps) }, {
        ref: unref19(forwardRef),
        "trap-focus": unref19(rootContext).open.value,
        "disable-outside-pointer-events": true,
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          if (!event.defaultPrevented) {
            event.preventDefault();
            unref19(rootContext).triggerElement.value?.focus();
          }
        }),
        onPointerDownOutside: _cache[1] || (_cache[1] = (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: _cache[2] || (_cache[2] = (event) => {
          event.preventDefault();
        })
      }), {
        default: withCtx15(() => [
          renderSlot17(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["trap-focus"]);
    };
  }
});

// node_modules/reka-ui/dist/Dialog/DialogContentNonModal.js
import { defineComponent as defineComponent22, ref as ref14, createBlock as createBlock16, openBlock as openBlock16, mergeProps as mergeProps6, unref as unref20, withCtx as withCtx16, renderSlot as renderSlot18 } from "vue";
var _sfc_main18 = defineComponent22({
  __name: "DialogContentNonModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    const rootContext = injectDialogRootContext();
    const hasInteractedOutsideRef = ref14(false);
    const hasPointerDownOutsideRef = ref14(false);
    return (_ctx, _cache) => {
      return openBlock16(), createBlock16(_sfc_main16, mergeProps6({ ...props2, ...unref20(emitsAsProps) }, {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.value) unref20(rootContext).triggerElement.value?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.value = false;
          hasPointerDownOutsideRef.value = false;
        }),
        onInteractOutside: _cache[1] || (_cache[1] = (event) => {
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.value = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.value = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = unref20(rootContext).triggerElement.value?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.value) {
            event.preventDefault();
          }
        })
      }), {
        default: withCtx16(() => [
          renderSlot18(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Dialog/DialogContent.js
var _sfc_main19 = defineComponent23({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectDialogRootContext();
    const emitsAsProps = useEmitAsProps(emits);
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock17(), createBlock17(unref21(Presence), {
        present: _ctx.forceMount || unref21(rootContext).open.value
      }, {
        default: withCtx17(() => [
          unref21(rootContext).modal.value ? (openBlock17(), createBlock17(_sfc_main17, mergeProps7({
            key: 0,
            ref: unref21(forwardRef)
          }, { ...props2, ...unref21(emitsAsProps), ..._ctx.$attrs }), {
            default: withCtx17(() => [
              renderSlot19(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)) : (openBlock17(), createBlock17(_sfc_main18, mergeProps7({
            key: 1,
            ref: unref21(forwardRef)
          }, { ...props2, ...unref21(emitsAsProps), ..._ctx.$attrs }), {
            default: withCtx17(() => [
              renderSlot19(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogContent.js
var [injectAlertDialogContentContext, provideAlertDialogContentContext] = createContext("AlertDialogContent");
var _sfc_main20 = defineComponent24({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    const cancelElement = ref15();
    provideAlertDialogContentContext({
      onCancelElementChange: (el) => {
        cancelElement.value = el;
      }
    });
    return (_ctx, _cache) => {
      return openBlock18(), createBlock18(unref22(_sfc_main19), mergeProps8({ ...props2, ...unref22(emitsAsProps) }, {
        role: "alertdialog",
        onPointerDownOutside: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"])),
        onInteractOutside: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onOpenAutoFocus: _cache[2] || (_cache[2] = () => {
          nextTick8(() => {
            cancelElement.value?.focus({
              preventScroll: true
            });
          });
        })
      }), {
        default: withCtx18(() => [
          renderSlot20(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogCancel.js
var _sfc_main21 = defineComponent25({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const contentContext = injectAlertDialogContentContext();
    const { forwardRef, currentElement } = useForwardExpose();
    onMounted6(() => {
      contentContext.onCancelElementChange(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock19(), createBlock19(unref23(_sfc_main12), mergeProps9(props2, { ref: unref23(forwardRef) }), {
        default: withCtx19(() => [
          renderSlot21(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogDescription.js
import { defineComponent as defineComponent27, createBlock as createBlock21, openBlock as openBlock21, unref as unref25, normalizeProps as normalizeProps2, guardReactiveProps as guardReactiveProps2, withCtx as withCtx21, renderSlot as renderSlot23 } from "vue";

// node_modules/reka-ui/dist/Dialog/DialogDescription.js
import { defineComponent as defineComponent26, createBlock as createBlock20, openBlock as openBlock20, unref as unref24, mergeProps as mergeProps10, withCtx as withCtx20, renderSlot as renderSlot22 } from "vue";
var _sfc_main22 = defineComponent26({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: { default: "p" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectDialogRootContext();
    return (_ctx, _cache) => {
      return openBlock20(), createBlock20(unref24(Primitive), mergeProps10(props2, {
        id: unref24(rootContext).descriptionId
      }), {
        default: withCtx20(() => [
          renderSlot22(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogDescription.js
var _sfc_main23 = defineComponent27({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: { default: "p" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock21(), createBlock21(unref25(_sfc_main22), normalizeProps2(guardReactiveProps2(props2)), {
        default: withCtx21(() => [
          renderSlot23(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogOverlay.js
import { defineComponent as defineComponent30, createBlock as createBlock24, openBlock as openBlock24, unref as unref28, normalizeProps as normalizeProps3, guardReactiveProps as guardReactiveProps3, withCtx as withCtx24, renderSlot as renderSlot26 } from "vue";

// node_modules/reka-ui/dist/Dialog/DialogOverlay.js
import { defineComponent as defineComponent29, createBlock as createBlock23, createCommentVNode as createCommentVNode2, unref as unref27, openBlock as openBlock23, withCtx as withCtx23, createVNode as createVNode3, mergeProps as mergeProps11, renderSlot as renderSlot25 } from "vue";

// node_modules/reka-ui/dist/Dialog/DialogOverlayImpl.js
import { defineComponent as defineComponent28, createBlock as createBlock22, openBlock as openBlock22, unref as unref26, withCtx as withCtx22, renderSlot as renderSlot24 } from "vue";

// node_modules/reka-ui/dist/shared/useBodyScrollLock.js
import { defu } from "defu";
import { computed as computed11, ref as ref16, watch as watch7, nextTick as nextTick9 } from "vue";
var useBodyLockStackCount = createSharedComposable(() => {
  const map = ref16(/* @__PURE__ */ new Map());
  const initialOverflow = ref16();
  const locked = computed11(() => {
    for (const value of map.value.values()) {
      if (value)
        return true;
    }
    return false;
  });
  const context2 = injectConfigProviderContext({
    scrollBody: ref16(true)
  });
  let stopTouchMoveListener = null;
  const resetBodyStyle = () => {
    document.body.style.paddingRight = "";
    document.body.style.marginRight = "";
    document.body.style.pointerEvents = "";
    document.body.style.removeProperty("--scrollbar-width");
    document.body.style.overflow = initialOverflow.value ?? "";
    isIOS && stopTouchMoveListener?.();
    initialOverflow.value = void 0;
  };
  watch7(locked, (val, oldVal) => {
    if (!isClient)
      return;
    if (!val) {
      if (oldVal)
        resetBodyStyle();
      return;
    }
    if (initialOverflow.value === void 0)
      initialOverflow.value = document.body.style.overflow;
    const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const defaultConfig = { padding: verticalScrollbarWidth, margin: 0 };
    const config = context2.scrollBody?.value ? typeof context2.scrollBody.value === "object" ? defu({
      padding: context2.scrollBody.value.padding === true ? verticalScrollbarWidth : context2.scrollBody.value.padding,
      margin: context2.scrollBody.value.margin === true ? verticalScrollbarWidth : context2.scrollBody.value.margin
    }, defaultConfig) : defaultConfig : { padding: 0, margin: 0 };
    if (verticalScrollbarWidth > 0) {
      document.body.style.paddingRight = typeof config.padding === "number" ? `${config.padding}px` : String(config.padding);
      document.body.style.marginRight = typeof config.margin === "number" ? `${config.margin}px` : String(config.margin);
      document.body.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
      document.body.style.overflow = "hidden";
    }
    if (isIOS) {
      stopTouchMoveListener = useEventListener(
        document,
        "touchmove",
        (e) => preventDefault(e),
        { passive: false }
      );
    }
    nextTick9(() => {
      document.body.style.pointerEvents = "none";
      document.body.style.overflow = "hidden";
    });
  }, { immediate: true, flush: "sync" });
  return map;
});
function useBodyScrollLock(initialState) {
  const id = Math.random().toString(36).substring(2, 7);
  const map = useBodyLockStackCount();
  map.value.set(id, initialState ?? false);
  const locked = computed11({
    get: () => map.value.get(id) ?? false,
    set: (value) => map.value.set(id, value)
  });
  tryOnBeforeUnmount(() => {
    map.value.delete(id);
  });
  return locked;
}
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) {
    return true;
  } else {
    const parent = ele.parentNode;
    if (!(parent instanceof Element) || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (_target instanceof Element && checkOverflowScroll(_target))
    return false;
  if (e.touches.length > 1)
    return true;
  if (e.preventDefault && e.cancelable)
    e.preventDefault();
  return false;
}

// node_modules/reka-ui/dist/Dialog/DialogOverlayImpl.js
var _sfc_main24 = defineComponent28({
  __name: "DialogOverlayImpl",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const rootContext = injectDialogRootContext();
    useBodyScrollLock(true);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock22(), createBlock22(unref26(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-state": unref26(rootContext).open.value ? "open" : "closed",
        style: { "pointer-events": "auto" }
      }, {
        default: withCtx22(() => [
          renderSlot24(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "data-state"]);
    };
  }
});

// node_modules/reka-ui/dist/Dialog/DialogOverlay.js
var _sfc_main25 = defineComponent29({
  __name: "DialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const rootContext = injectDialogRootContext();
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return unref27(rootContext)?.modal.value ? (openBlock23(), createBlock23(unref27(Presence), {
        key: 0,
        present: _ctx.forceMount || unref27(rootContext).open.value
      }, {
        default: withCtx23(() => [
          createVNode3(_sfc_main24, mergeProps11(_ctx.$attrs, {
            ref: unref27(forwardRef),
            as: _ctx.as,
            "as-child": _ctx.asChild
          }), {
            default: withCtx23(() => [
              renderSlot25(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child"])
        ]),
        _: 3
      }, 8, ["present"])) : createCommentVNode2("", true);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogOverlay.js
var _sfc_main26 = defineComponent30({
  __name: "AlertDialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock24(), createBlock24(unref28(_sfc_main25), normalizeProps3(guardReactiveProps3(props2)), {
        default: withCtx24(() => [
          renderSlot26(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogPortal.js
import { defineComponent as defineComponent32, createBlock as createBlock26, openBlock as openBlock26, unref as unref30, normalizeProps as normalizeProps4, guardReactiveProps as guardReactiveProps4, withCtx as withCtx25, renderSlot as renderSlot28 } from "vue";

// node_modules/reka-ui/dist/Teleport/Teleport.js
import { defineComponent as defineComponent31, createBlock as createBlock25, createCommentVNode as createCommentVNode3, unref as unref29, openBlock as openBlock25, Teleport, renderSlot as renderSlot27 } from "vue";
var _sfc_main27 = defineComponent31({
  __name: "Teleport",
  props: {
    to: { default: "body" },
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const isMounted = useMounted();
    return (_ctx, _cache) => {
      return unref29(isMounted) || _ctx.forceMount ? (openBlock25(), createBlock25(Teleport, {
        key: 0,
        to: _ctx.to,
        disabled: _ctx.disabled,
        defer: _ctx.defer
      }, [
        renderSlot27(_ctx.$slots, "default")
      ], 8, ["to", "disabled", "defer"])) : createCommentVNode3("", true);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogPortal.js
var _sfc_main28 = defineComponent32({
  __name: "AlertDialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock26(), createBlock26(unref30(_sfc_main27), normalizeProps4(guardReactiveProps4(props2)), {
        default: withCtx25(() => [
          renderSlot28(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogRoot.js
import { defineComponent as defineComponent33, createBlock as createBlock27, openBlock as openBlock27, unref as unref31, mergeProps as mergeProps12, withCtx as withCtx26, renderSlot as renderSlot29, normalizeProps as normalizeProps5, guardReactiveProps as guardReactiveProps5 } from "vue";

// node_modules/reka-ui/dist/shared/useForwardPropsEmits.js
import { computed as computed13 } from "vue";

// node_modules/reka-ui/dist/shared/useForwardProps.js
import { getCurrentInstance as getCurrentInstance6, toRef as toRef2, computed as computed12, camelize as camelize3 } from "vue";
function useForwardProps(props2) {
  const vm = getCurrentInstance6();
  const defaultProps = Object.keys(vm?.type.props ?? {}).reduce((prev, curr) => {
    const defaultValue = (vm?.type.props[curr]).default;
    if (defaultValue !== void 0)
      prev[curr] = defaultValue;
    return prev;
  }, {});
  const refProps = toRef2(props2);
  return computed12(() => {
    const preservedProps = {};
    const assignedProps = vm?.vnode.props ?? {};
    Object.keys(assignedProps).forEach((key) => {
      preservedProps[camelize3(key)] = assignedProps[key];
    });
    return Object.keys({ ...defaultProps, ...preservedProps }).reduce((prev, curr) => {
      if (refProps.value[curr] !== void 0)
        prev[curr] = refProps.value[curr];
      return prev;
    }, {});
  });
}

// node_modules/reka-ui/dist/shared/useForwardPropsEmits.js
function useForwardPropsEmits(props2, emit) {
  const parsedProps = useForwardProps(props2);
  const emitsAsProps = emit ? useEmitAsProps(emit) : {};
  return computed13(() => ({
    ...parsedProps.value,
    ...emitsAsProps
  }));
}

// node_modules/reka-ui/dist/AlertDialog/AlertDialogRoot.js
var _sfc_main29 = defineComponent33({
  __name: "AlertDialogRoot",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock27(), createBlock27(unref31(_sfc_main11), mergeProps12(unref31(forwarded), { modal: true }), {
        default: withCtx26((slotProps) => [
          renderSlot29(_ctx.$slots, "default", normalizeProps5(guardReactiveProps5(slotProps)))
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogTitle.js
import { defineComponent as defineComponent35, createBlock as createBlock29, openBlock as openBlock29, unref as unref33, normalizeProps as normalizeProps6, guardReactiveProps as guardReactiveProps6, withCtx as withCtx28, renderSlot as renderSlot31 } from "vue";

// node_modules/reka-ui/dist/Dialog/DialogTitle.js
import { defineComponent as defineComponent34, createBlock as createBlock28, openBlock as openBlock28, unref as unref32, mergeProps as mergeProps13, withCtx as withCtx27, renderSlot as renderSlot30 } from "vue";
var _sfc_main30 = defineComponent34({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h2" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDialogRootContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock28(), createBlock28(unref32(Primitive), mergeProps13(props2, {
        id: unref32(rootContext).titleId
      }), {
        default: withCtx27(() => [
          renderSlot30(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogTitle.js
var _sfc_main31 = defineComponent35({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h2" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock29(), createBlock29(unref33(_sfc_main30), normalizeProps6(guardReactiveProps6(props2)), {
        default: withCtx28(() => [
          renderSlot31(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogTrigger.js
import { defineComponent as defineComponent37, createBlock as createBlock31, openBlock as openBlock31, unref as unref35, normalizeProps as normalizeProps7, guardReactiveProps as guardReactiveProps7, withCtx as withCtx30, renderSlot as renderSlot33 } from "vue";

// node_modules/reka-ui/dist/Dialog/DialogTrigger.js
import { defineComponent as defineComponent36, onMounted as onMounted7, createBlock as createBlock30, openBlock as openBlock30, unref as unref34, mergeProps as mergeProps14, withCtx as withCtx29, renderSlot as renderSlot32 } from "vue";
var _sfc_main32 = defineComponent36({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDialogRootContext();
    const { forwardRef, currentElement } = useForwardExpose();
    rootContext.contentId ||= useId2(void 0, "reka-dialog-content");
    onMounted7(() => {
      rootContext.triggerElement.value = currentElement.value;
    });
    return (_ctx, _cache) => {
      return openBlock30(), createBlock30(unref34(Primitive), mergeProps14(props2, {
        ref: unref34(forwardRef),
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-haspopup": "dialog",
        "aria-expanded": unref34(rootContext).open.value || false,
        "aria-controls": unref34(rootContext).open.value ? unref34(rootContext).contentId : void 0,
        "data-state": unref34(rootContext).open.value ? "open" : "closed",
        onClick: unref34(rootContext).onOpenToggle
      }), {
        default: withCtx29(() => [
          renderSlot32(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "onClick"]);
    };
  }
});

// node_modules/reka-ui/dist/AlertDialog/AlertDialogTrigger.js
var _sfc_main33 = defineComponent37({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock31(), createBlock31(unref35(_sfc_main32), normalizeProps7(guardReactiveProps7(props2)), {
        default: withCtx30(() => [
          renderSlot33(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/AspectRatio/AspectRatio.js
import { defineComponent as defineComponent38, computed as computed14, createElementBlock, openBlock as openBlock32, normalizeStyle as normalizeStyle2, createVNode as createVNode4, unref as unref36, mergeProps as mergeProps15, withCtx as withCtx31, renderSlot as renderSlot34 } from "vue";
var _sfc_main34 = defineComponent38({
  ...{
    inheritAttrs: false
  },
  __name: "AspectRatio",
  props: {
    ratio: { default: 1 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const aspect = computed14(() => {
      return 1 / props2.ratio * 100;
    });
    return (_ctx, _cache) => {
      return openBlock32(), createElementBlock("div", {
        style: normalizeStyle2(`position: relative; width: 100%; padding-bottom: ${aspect.value}%`),
        "data-reka-aspect-ratio-wrapper": ""
      }, [
        createVNode4(unref36(Primitive), mergeProps15({
          ref: unref36(forwardRef),
          "as-child": _ctx.asChild,
          as: _ctx.as,
          style: { "position": "absolute", "inset": "0px" }
        }, _ctx.$attrs), {
          default: withCtx31(() => [
            renderSlot34(_ctx.$slots, "default", { aspect: aspect.value })
          ]),
          _: 3
        }, 16, ["as-child", "as"])
      ], 4);
    };
  }
});

// node_modules/reka-ui/dist/Avatar/AvatarFallback.js
import { defineComponent as defineComponent40, ref as ref18, watch as watch8, createBlock as createBlock33, createCommentVNode as createCommentVNode4, unref as unref38, openBlock as openBlock34, withCtx as withCtx33, renderSlot as renderSlot36 } from "vue";

// node_modules/reka-ui/dist/Avatar/AvatarRoot.js
import { defineComponent as defineComponent39, ref as ref17, createBlock as createBlock32, openBlock as openBlock33, unref as unref37, withCtx as withCtx32, renderSlot as renderSlot35 } from "vue";
var [injectAvatarRootContext, provideAvatarRootContext] = createContext("AvatarRoot");
var _sfc_main35 = defineComponent39({
  __name: "AvatarRoot",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    useForwardExpose();
    provideAvatarRootContext({
      imageLoadingStatus: ref17("loading")
    });
    return (_ctx, _cache) => {
      return openBlock33(), createBlock32(unref37(Primitive), {
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx32(() => [
          renderSlot35(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});

// node_modules/reka-ui/dist/Avatar/AvatarFallback.js
var _sfc_main36 = defineComponent40({
  __name: "AvatarFallback",
  props: {
    delayMs: { default: 0 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectAvatarRootContext();
    useForwardExpose();
    const canRender = ref18(false);
    let timeout;
    watch8(rootContext.imageLoadingStatus, (value) => {
      if (value === "loading") {
        canRender.value = false;
        if (props2.delayMs) {
          timeout = setTimeout(() => {
            canRender.value = true;
            clearTimeout(timeout);
          }, props2.delayMs);
        } else {
          canRender.value = true;
        }
      }
    }, { immediate: true });
    return (_ctx, _cache) => {
      return canRender.value && unref38(rootContext).imageLoadingStatus.value !== "loaded" ? (openBlock34(), createBlock33(unref38(Primitive), {
        key: 0,
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx33(() => [
          renderSlot36(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as"])) : createCommentVNode4("", true);
    };
  }
});

// node_modules/reka-ui/dist/Avatar/AvatarImage.js
import { defineComponent as defineComponent41, toRefs as toRefs7, watch as watch10, withDirectives, createBlock as createBlock34, openBlock as openBlock35, unref as unref39, withCtx as withCtx34, renderSlot as renderSlot37, vShow } from "vue";

// node_modules/reka-ui/dist/Avatar/utils.js
import { ref as ref19, onMounted as onMounted8, watch as watch9, onUnmounted as onUnmounted4 } from "vue";
function useImageLoadingStatus(src, referrerPolicy) {
  const loadingStatus = ref19("idle");
  const isMounted = ref19(false);
  const updateStatus = (status) => () => {
    if (isMounted.value)
      loadingStatus.value = status;
  };
  onMounted8(() => {
    isMounted.value = true;
    watch9([() => src.value, () => referrerPolicy?.value], ([src2, referrer]) => {
      if (!src2) {
        loadingStatus.value = "error";
      } else {
        const image = new window.Image();
        loadingStatus.value = "loading";
        image.onload = updateStatus("loaded");
        image.onerror = updateStatus("error");
        image.src = src2;
        if (referrer) {
          image.referrerPolicy = referrer;
        }
      }
    }, { immediate: true });
  });
  onUnmounted4(() => {
    isMounted.value = false;
  });
  return loadingStatus;
}

// node_modules/reka-ui/dist/Avatar/AvatarImage.js
var _sfc_main37 = defineComponent41({
  __name: "AvatarImage",
  props: {
    src: {},
    referrerPolicy: {},
    asChild: { type: Boolean },
    as: { default: "img" }
  },
  emits: ["loadingStatusChange"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { src, referrerPolicy } = toRefs7(props2);
    useForwardExpose();
    const rootContext = injectAvatarRootContext();
    const imageLoadingStatus = useImageLoadingStatus(src, referrerPolicy);
    watch10(
      imageLoadingStatus,
      (newValue) => {
        emits("loadingStatusChange", newValue);
        if (newValue !== "idle")
          rootContext.imageLoadingStatus.value = newValue;
      },
      { immediate: true }
    );
    return (_ctx, _cache) => {
      return withDirectives((openBlock35(), createBlock34(unref39(Primitive), {
        role: "img",
        "as-child": _ctx.asChild,
        as: _ctx.as,
        src: unref39(src),
        "referrer-policy": unref39(referrerPolicy)
      }, {
        default: withCtx34(() => [
          renderSlot37(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as", "src", "referrer-policy"])), [
        [vShow, unref39(imageLoadingStatus) === "loaded"]
      ]);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarCell.js
import { defineComponent as defineComponent43, createBlock as createBlock36, openBlock as openBlock37, unref as unref41, withCtx as withCtx36, renderSlot as renderSlot39 } from "vue";

// node_modules/reka-ui/dist/Calendar/CalendarRoot.js
import { defineComponent as defineComponent42, toRefs as toRefs8, watch as watch12, onMounted as onMounted9, createBlock as createBlock35, openBlock as openBlock36, unref as unref40, withCtx as withCtx35, renderSlot as renderSlot38, createElementVNode, toDisplayString } from "vue";

// node_modules/@internationalized/date/dist/utils.mjs
function $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {
  return amount - numerator * Math.floor(amount / numerator);
}

// node_modules/@internationalized/date/dist/GregorianCalendar.mjs
var $3b62074eb05584b2$var$EPOCH = 1721426;
function $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {
  year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);
  let y1 = year - 1;
  let monthOffset = -2;
  if (month <= 2) monthOffset = 0;
  else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) monthOffset = -1;
  return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}
function $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {
  return era === "BC" ? 1 - year : year;
}
function $3b62074eb05584b2$export$4475b7e617eb123c(year) {
  let era = "AD";
  if (year <= 0) {
    era = "BC";
    year = 1 - year;
  }
  return [
    era,
    year
  ];
}
var $3b62074eb05584b2$var$daysInMonth = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
var $3b62074eb05584b2$export$80ee6245ec4f29ec = class {
  fromJulianDay(jd) {
    let jd0 = jd;
    let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;
    let quadricent = Math.floor(depoch / 146097);
    let dqc = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(depoch, 146097);
    let cent = Math.floor(dqc / 36524);
    let dcent = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dqc, 36524);
    let quad = Math.floor(dcent / 1461);
    let dquad = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dcent, 1461);
    let yindex = Math.floor(dquad / 365);
    let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
    let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);
    let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);
    let leapAdj = 2;
    if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;
    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) leapAdj = 1;
    let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
    let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, month, day);
  }
  toJulianDay(date) {
    return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);
  }
  getDaysInMonth(date) {
    return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(date) {
    return 12;
  }
  getDaysInYear(date) {
    return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(date) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(date) {
    return date.era === "BC";
  }
  balanceDate(date) {
    if (date.year <= 0) {
      date.era = date.era === "BC" ? "AD" : "BC";
      date.year = 1 - date.year;
    }
  }
  constructor() {
    this.identifier = "gregory";
  }
};

// node_modules/@internationalized/date/dist/weekStartData.mjs
var $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};

// node_modules/@internationalized/date/dist/queries.mjs
function $14e0f24ef4ac5c92$export$ea39ec197993aef0(a, b) {
  b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);
  return a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}
function $14e0f24ef4ac5c92$export$a18c89cbd24170ff(a, b) {
  b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);
  a = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(a);
  b = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(b);
  return a.era === b.era && a.year === b.year && a.month === b.month;
}
function $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(a, b) {
  return $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a.calendar, b.calendar) && $14e0f24ef4ac5c92$export$ea39ec197993aef0(a, b);
}
function $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(a, b) {
  return $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a.calendar, b.calendar) && $14e0f24ef4ac5c92$export$a18c89cbd24170ff(a, b);
}
function $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a, b) {
  var _a_isEqual, _b_isEqual;
  var _a_isEqual1, _ref;
  return (_ref = (_a_isEqual1 = (_a_isEqual = a.isEqual) === null || _a_isEqual === void 0 ? void 0 : _a_isEqual.call(a, b)) !== null && _a_isEqual1 !== void 0 ? _a_isEqual1 : (_b_isEqual = b.isEqual) === null || _b_isEqual === void 0 ? void 0 : _b_isEqual.call(b, a)) !== null && _ref !== void 0 ? _ref : a.identifier === b.identifier;
}
function $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone) {
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
}
var $14e0f24ef4ac5c92$var$DAY_MAP = {
  sun: 0,
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6
};
function $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale, firstDayOfWeek) {
  let julian = date.calendar.toJulianDay(date);
  let weekStart = firstDayOfWeek ? $14e0f24ef4ac5c92$var$DAY_MAP[firstDayOfWeek] : $14e0f24ef4ac5c92$var$getWeekStart(locale);
  let dayOfWeek = Math.ceil(julian + 1 - weekStart) % 7;
  if (dayOfWeek < 0) dayOfWeek += 7;
  return dayOfWeek;
}
function $14e0f24ef4ac5c92$export$461939dd4422153(timeZone) {
  return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(Date.now(), timeZone);
}
function $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone) {
  return (0, $11d87f3f76e88657$export$93522d1a439f3617)($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));
}
function $14e0f24ef4ac5c92$export$68781ddf31c0090f(a, b) {
  return a.calendar.toJulianDay(a) - b.calendar.toJulianDay(b);
}
function $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a, b) {
  return $14e0f24ef4ac5c92$var$timeToMs(a) - $14e0f24ef4ac5c92$var$timeToMs(b);
}
function $14e0f24ef4ac5c92$var$timeToMs(a) {
  return a.hour * 36e5 + a.minute * 6e4 + a.second * 1e3 + a.millisecond;
}
var $14e0f24ef4ac5c92$var$localTimeZone = null;
function $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {
  if ($14e0f24ef4ac5c92$var$localTimeZone == null) $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
  return $14e0f24ef4ac5c92$var$localTimeZone;
}
function $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date) {
  return date.subtract({
    days: date.day - 1
  });
}
function $14e0f24ef4ac5c92$export$a2258d9c4118825c(date) {
  return date.add({
    days: date.calendar.getDaysInMonth(date) - date.day
  });
}
var $14e0f24ef4ac5c92$var$cachedRegions = /* @__PURE__ */ new Map();
function $14e0f24ef4ac5c92$var$getRegion(locale) {
  if (Intl.Locale) {
    let region = $14e0f24ef4ac5c92$var$cachedRegions.get(locale);
    if (!region) {
      region = new Intl.Locale(locale).maximize().region;
      if (region) $14e0f24ef4ac5c92$var$cachedRegions.set(locale, region);
    }
    return region;
  }
  let part = locale.split("-")[1];
  return part === "u" ? void 0 : part;
}
function $14e0f24ef4ac5c92$var$getWeekStart(locale) {
  let region = $14e0f24ef4ac5c92$var$getRegion(locale);
  return region ? (0, $2fe286d2fb449abb$export$7a5acbd77d414bd9)[region] || 0 : 0;
}

// node_modules/@internationalized/date/dist/conversion.mjs
function $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {
  date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);
  return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}
function $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
  let date = /* @__PURE__ */ new Date();
  date.setUTCHours(hour, minute, second, millisecond);
  date.setUTCFullYear(year, month - 1, day);
  return date.getTime();
}
function $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone) {
  if (timeZone === "UTC") return 0;
  if (ms > 0 && timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)()) return new Date(ms).getTimezoneOffset() * -6e4;
  let { year, month, day, hour, minute, second } = $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone);
  let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);
  return utc - Math.floor(ms / 1e3) * 1e3;
}
var $11d87f3f76e88657$var$formattersByTimeZone = /* @__PURE__ */ new Map();
function $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone) {
  let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat("en-US", {
      timeZone,
      hour12: false,
      era: "short",
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
    $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);
  }
  let parts = formatter.formatToParts(new Date(ms));
  let namedParts = {};
  for (let part of parts) if (part.type !== "literal") namedParts[part.type] = part.value;
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
    month: +namedParts.month,
    day: +namedParts.day,
    hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
    minute: +namedParts.minute,
    second: +namedParts.second
  };
}
var $11d87f3f76e88657$var$DAYMILLIS = 864e5;
function $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {
  let found = earlier === later ? [
    earlier
  ] : [
    earlier,
    later
  ];
  return found.filter((absolute) => $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));
}
function $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {
  let parts = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);
  return date.year === parts.year && date.month === parts.month && date.day === parts.day && date.hour === parts.hour && date.minute === parts.minute && date.second === parts.second;
}
function $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
  let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
  if (timeZone === "UTC") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  if (timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)() && disambiguation === "compatible") {
    dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
    let date2 = /* @__PURE__ */ new Date();
    let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);
    date2.setFullYear(year, dateTime.month - 1, dateTime.day);
    date2.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
    return date2.getTime();
  }
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);
  if (valid.length === 1) return valid[0];
  if (valid.length > 1) switch (disambiguation) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return valid[0];
    case "later":
      return valid[valid.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (disambiguation) {
    case "earlier":
      return Math.min(ms - offsetBefore, ms - offsetAfter);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(ms - offsetBefore, ms - offsetAfter);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
  return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
}
function $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone) {
  let offset3 = $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone);
  let date = new Date(ms + offset3);
  let year = date.getUTCFullYear();
  let month = date.getUTCMonth() + 1;
  let day = date.getUTCDate();
  let hour = date.getUTCHours();
  let minute = date.getUTCMinutes();
  let second = date.getUTCSeconds();
  let millisecond = date.getUTCMilliseconds();
  return new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)(year < 1 ? "BC" : "AD", year < 1 ? -year + 1 : year, month, day, timeZone, offset3, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$93522d1a439f3617(dateTime) {
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
}
function $11d87f3f76e88657$export$b21e0b124e224484(date, time) {
  let hour = 0, minute = 0, second = 0, millisecond = 0;
  if ("timeZone" in date) ({ hour, minute, second, millisecond } = date);
  else if ("hour" in date && !time) return date;
  if (time) ({ hour, minute, second, millisecond } = time);
  return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {
  if ((0, $14e0f24ef4ac5c92$export$dbc69fd56b53d5e)(date.calendar, calendar)) return date;
  let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
  let copy = date.copy();
  copy.calendar = calendar;
  copy.era = calendarDate.era;
  copy.year = calendarDate.year;
  copy.month = calendarDate.month;
  copy.day = calendarDate.day;
  (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(copy);
  return copy;
}
function $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {
  if (date instanceof (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)) {
    if (date.timeZone === timeZone) return date;
    return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);
  }
  let ms = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);
  return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone);
}
function $11d87f3f76e88657$export$83aac07b4c37b25(date) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return new Date(ms);
}
function $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone), date.calendar);
}

// node_modules/@internationalized/date/dist/manipulation.mjs
var $735220c2d4774dd3$var$ONE_HOUR = 36e5;
function $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {
  let mutableDate = date.copy();
  let days = "hour" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;
  $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);
  if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);
  mutableDate.month += duration.months || 0;
  $735220c2d4774dd3$var$balanceYearMonth(mutableDate);
  $735220c2d4774dd3$var$constrainMonthDay(mutableDate);
  mutableDate.day += (duration.weeks || 0) * 7;
  mutableDate.day += duration.days || 0;
  mutableDate.day += days;
  $735220c2d4774dd3$var$balanceDay(mutableDate);
  if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);
  if (mutableDate.year < 1) {
    mutableDate.year = 1;
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
  if (mutableDate.year > maxYear) {
    var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;
    let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
    mutableDate.year = maxYear;
    mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
    mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  if (mutableDate.month < 1) {
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
  if (mutableDate.month > maxMonth) {
    mutableDate.month = maxMonth;
    mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
  return mutableDate;
}
function $735220c2d4774dd3$var$addYears(date, years) {
  var _date_calendar_isInverseEra, _date_calendar;
  if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;
  date.year += years;
}
function $735220c2d4774dd3$var$balanceYearMonth(date) {
  while (date.month < 1) {
    $735220c2d4774dd3$var$addYears(date, -1);
    date.month += date.calendar.getMonthsInYear(date);
  }
  let monthsInYear = 0;
  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {
    date.month -= monthsInYear;
    $735220c2d4774dd3$var$addYears(date, 1);
  }
}
function $735220c2d4774dd3$var$balanceDay(date) {
  while (date.day < 1) {
    date.month--;
    $735220c2d4774dd3$var$balanceYearMonth(date);
    date.day += date.calendar.getDaysInMonth(date);
  }
  while (date.day > date.calendar.getDaysInMonth(date)) {
    date.day -= date.calendar.getDaysInMonth(date);
    date.month++;
    $735220c2d4774dd3$var$balanceYearMonth(date);
  }
}
function $735220c2d4774dd3$var$constrainMonthDay(date) {
  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}
function $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {
  if (date.calendar.constrainDate) date.calendar.constrainDate(date);
  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
  $735220c2d4774dd3$var$constrainMonthDay(date);
}
function $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {
  let inverseDuration = {};
  for (let key in duration) if (typeof duration[key] === "number") inverseDuration[key] = -duration[key];
  return inverseDuration;
}
function $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {
  return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {
  let mutableDate = date.copy();
  if (fields.era != null) mutableDate.era = fields.era;
  if (fields.year != null) mutableDate.year = fields.year;
  if (fields.month != null) mutableDate.month = fields.month;
  if (fields.day != null) mutableDate.day = fields.day;
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);
  return mutableDate;
}
function $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {
  let mutableValue = value.copy();
  if (fields.hour != null) mutableValue.hour = fields.hour;
  if (fields.minute != null) mutableValue.minute = fields.minute;
  if (fields.second != null) mutableValue.second = fields.second;
  if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;
  $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);
  return mutableValue;
}
function $735220c2d4774dd3$var$balanceTime(time) {
  time.second += Math.floor(time.millisecond / 1e3);
  time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1e3);
  time.minute += Math.floor(time.second / 60);
  time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);
  time.hour += Math.floor(time.minute / 60);
  time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);
  let days = Math.floor(time.hour / 24);
  time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);
  return days;
}
function $735220c2d4774dd3$export$7555de1e070510cb(time) {
  time.millisecond = Math.max(0, Math.min(time.millisecond, 1e3));
  time.second = Math.max(0, Math.min(time.second, 59));
  time.minute = Math.max(0, Math.min(time.minute, 59));
  time.hour = Math.max(0, Math.min(time.hour, 23));
}
function $735220c2d4774dd3$var$nonNegativeMod(a, b) {
  let result = a % b;
  if (result < 0) result += b;
  return result;
}
function $735220c2d4774dd3$var$addTimeFields(time, duration) {
  time.hour += duration.hours || 0;
  time.minute += duration.minutes || 0;
  time.second += duration.seconds || 0;
  time.millisecond += duration.milliseconds || 0;
  return $735220c2d4774dd3$var$balanceTime(time);
}
function $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {
  let res = time.copy();
  $735220c2d4774dd3$var$addTimeFields(res, duration);
  return res;
}
function $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {
  return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "era": {
      let eras = value.calendar.getEras();
      let eraIndex = eras.indexOf(value.era);
      if (eraIndex < 0) throw new Error("Invalid era: " + value.era);
      eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
      mutable.era = eras[eraIndex];
      $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
      break;
    }
    case "year":
      var _mutable_calendar_isInverseEra, _mutable_calendar;
      if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;
      mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
      if (mutable.year === -Infinity) mutable.year = 1;
      if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);
      break;
    case "month":
      mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    case "day":
      mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
  return mutable;
}
function $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "hour": {
      let hours = value.hour;
      let min2 = 0;
      let max2 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = hours >= 12;
        min2 = isPM ? 12 : 0;
        max2 = isPM ? 23 : 11;
      }
      mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min2, max2, options === null || options === void 0 ? void 0 : options.round);
      break;
    }
    case "minute":
      mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "second":
      mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "millisecond":
      mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  return mutable;
}
function $735220c2d4774dd3$var$cycleValue(value, amount, min2, max2, round2 = false) {
  if (round2) {
    value += Math.sign(amount);
    if (value < min2) value = max2;
    let div = Math.abs(amount);
    if (amount > 0) value = Math.ceil(value / div) * div;
    else value = Math.floor(value / div) * div;
    if (value > max2) value = min2;
  } else {
    value += amount;
    if (value < min2) value = max2 - (min2 - value - 1);
    else if (value > max2) value = min2 + (value - max2 - 1);
  }
  return value;
}
function $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {
  let ms;
  if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {
    let res2 = $735220c2d4774dd3$export$e16d8520af44a096((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {
      years: duration.years,
      months: duration.months,
      weeks: duration.weeks,
      days: duration.days
    });
    ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res2, dateTime.timeZone);
  } else
    ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
  ms += duration.milliseconds || 0;
  ms += (duration.seconds || 0) * 1e3;
  ms += (duration.minutes || 0) * 6e4;
  ms += (duration.hours || 0) * 36e5;
  let res = (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);
}
function $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {
  return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {
  switch (field) {
    case "hour": {
      let min2 = 0;
      let max2 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = dateTime.hour >= 12;
        min2 = isPM ? 12 : 0;
        max2 = isPM ? 23 : 11;
      }
      let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
      let minDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: min2
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let minAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === minDate.day)[0];
      let maxDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: max2
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let maxAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === maxDate.day).pop();
      let ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
      let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);
      let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;
      ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);
    case "era":
    case "year":
    case "month":
    case "day": {
      let res = $735220c2d4774dd3$export$d52ced6badfb9a4c((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);
      let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    default:
      throw new Error("Unsupported field " + field);
  }
}
function $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
  let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
  let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
  if (res.compare(plainDateTime) === 0) return dateTime;
  let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
}

// node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];
function $fae977aafc393c5c$export$f59dee82248f5ad4(time) {
  return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1e3).slice(1) : ""}`;
}
function $fae977aafc393c5c$export$60dfd74aa96791bd(date) {
  let gregorianDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year;
  if (gregorianDate.era === "BC") year = gregorianDate.year === 1 ? "0000" : "-" + String(Math.abs(1 - gregorianDate.year)).padStart(6, "00");
  else year = String(gregorianDate.year).padStart(4, "0");
  return `${year}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$4223de14708adc63(date) {
  return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;
}
function $fae977aafc393c5c$var$offsetToString(offset3) {
  let sign = Math.sign(offset3) < 0 ? "-" : "+";
  offset3 = Math.abs(offset3);
  let offsetHours = Math.floor(offset3 / 36e5);
  let offsetMinutes = offset3 % 36e5 / 6e4;
  return `${sign}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {
  return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;
}

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

// node_modules/@internationalized/date/dist/CalendarDate.mjs
function $35ea8db9cb2ccb90$var$shiftArgs(args) {
  let calendar = typeof args[0] === "object" ? args.shift() : new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();
  let era;
  if (typeof args[0] === "string") era = args.shift();
  else {
    let eras = calendar.getEras();
    era = eras[eras.length - 1];
  }
  let year = args.shift();
  let month = args.shift();
  let day = args.shift();
  return [
    calendar,
    era,
    year,
    month,
    day
  ];
}
var $35ea8db9cb2ccb90$var$_type = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$99faa760c7908e4f = class _$35ea8db9cb2ccb90$export$99faa760c7908e4f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
    else return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)(this, fields);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(timeZone) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$60dfd74aa96791bd)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    return (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type1 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$680ea196effce5f = class _$35ea8db9cb2ccb90$export$680ea196effce5f {
  /** Returns a copy of this time. */
  copy() {
    return new _$35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `Time` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$7ed87b6bc2506470)(this, duration);
  }
  /** Returns a new `Time` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$fe34d3a381cd7501)(this, duration);
  }
  /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields);
  }
  /**
  * Returns a new `Time` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
  }
  /** Converts the time to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$f59dee82248f5ad4)(this);
  }
  /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */
  compare(b) {
    return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, b);
  }
  constructor(hour = 0, minute = 0, second = 0, millisecond = 0) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type1, {
      writable: true,
      value: void 0
    });
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond;
    (0, $735220c2d4774dd3$export$7555de1e070510cb)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type2 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$ca871e8dbb80966f = class _$35ea8db9cb2ccb90$export$ca871e8dbb80966f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)((0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields), fields);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    switch (field) {
      case "era":
      case "year":
      case "month":
      case "day":
        return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
      default:
        return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(timeZone, disambiguation) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone, disambiguation);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$4223de14708adc63)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    let res = (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);
    if (res === 0) return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, (0, $11d87f3f76e88657$export$b21e0b124e224484)(b));
    return res;
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type2, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type3 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$d3b7288e7994edea = class _$35ea8db9cb2ccb90$export$d3b7288e7994edea {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$96b1d28349274637)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$6814caac34ca03c7)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields, disambiguation) {
    return (0, $735220c2d4774dd3$export$31b5430eb18be4f8)(this, fields, disambiguation);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$9a297d111fc86b79)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return (0, $11d87f3f76e88657$export$83aac07b4c37b25)(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return (0, $fae977aafc393c5c$export$bf79f1ebf4b18792)(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    return this.toDate().getTime() - (0, $11d87f3f76e88657$export$84c95a83c799e074)(b, this.timeZone).toDate().getTime();
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type3, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    let timeZone = args.shift();
    let offset3 = args.shift();
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.timeZone = timeZone;
    this.offset = offset3;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};

// node_modules/@internationalized/date/dist/JapaneseCalendar.mjs
var $62225008020f0a13$var$ERA_START_DATES = [
  [
    1868,
    9,
    8
  ],
  [
    1912,
    7,
    30
  ],
  [
    1926,
    12,
    25
  ],
  [
    1989,
    1,
    8
  ],
  [
    2019,
    5,
    1
  ]
];
var $62225008020f0a13$var$ERA_END_DATES = [
  [
    1912,
    7,
    29
  ],
  [
    1926,
    12,
    24
  ],
  [
    1989,
    1,
    7
  ],
  [
    2019,
    4,
    30
  ]
];
var $62225008020f0a13$var$ERA_ADDENDS = [
  1867,
  1911,
  1925,
  1988,
  2018
];
var $62225008020f0a13$var$ERA_NAMES = [
  "meiji",
  "taisho",
  "showa",
  "heisei",
  "reiwa"
];
function $62225008020f0a13$var$findEraFromGregorianDate(date) {
  const idx = $62225008020f0a13$var$ERA_START_DATES.findIndex(([year, month, day]) => {
    if (date.year < year) return true;
    if (date.year === year && date.month < month) return true;
    if (date.year === year && date.month === month && date.day < day) return true;
    return false;
  });
  if (idx === -1) return $62225008020f0a13$var$ERA_START_DATES.length - 1;
  if (idx === 0) return 0;
  return idx - 1;
}
function $62225008020f0a13$var$toGregorian(date) {
  let eraAddend = $62225008020f0a13$var$ERA_ADDENDS[$62225008020f0a13$var$ERA_NAMES.indexOf(date.era)];
  if (!eraAddend) throw new Error("Unknown era: " + date.era);
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(date.year + eraAddend, date.month, date.day);
}
var $62225008020f0a13$export$b746ab2b60cdffbf = class extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {
  fromJulianDay(jd) {
    let date = super.fromJulianDay(jd);
    let era = $62225008020f0a13$var$findEraFromGregorianDate(date);
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, $62225008020f0a13$var$ERA_NAMES[era], date.year - $62225008020f0a13$var$ERA_ADDENDS[era], date.month, date.day);
  }
  toJulianDay(date) {
    return super.toJulianDay($62225008020f0a13$var$toGregorian(date));
  }
  balanceDate(date) {
    let gregorianDate = $62225008020f0a13$var$toGregorian(date);
    let era = $62225008020f0a13$var$findEraFromGregorianDate(gregorianDate);
    if ($62225008020f0a13$var$ERA_NAMES[era] !== date.era) {
      date.era = $62225008020f0a13$var$ERA_NAMES[era];
      date.year = gregorianDate.year - $62225008020f0a13$var$ERA_ADDENDS[era];
    }
    this.constrainDate(date);
  }
  constrainDate(date) {
    let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);
    let end = $62225008020f0a13$var$ERA_END_DATES[idx];
    if (end != null) {
      let [endYear, endMonth, endDay] = end;
      let maxYear = endYear - $62225008020f0a13$var$ERA_ADDENDS[idx];
      date.year = Math.max(1, Math.min(maxYear, date.year));
      if (date.year === maxYear) {
        date.month = Math.min(endMonth, date.month);
        if (date.month === endMonth) date.day = Math.min(endDay, date.day);
      }
    }
    if (date.year === 1 && idx >= 0) {
      let [, startMonth, startDay] = $62225008020f0a13$var$ERA_START_DATES[idx];
      date.month = Math.max(startMonth, date.month);
      if (date.month === startMonth) date.day = Math.max(startDay, date.day);
    }
  }
  getEras() {
    return $62225008020f0a13$var$ERA_NAMES;
  }
  getYearsInEra(date) {
    let era = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);
    let cur = $62225008020f0a13$var$ERA_START_DATES[era];
    let next = $62225008020f0a13$var$ERA_START_DATES[era + 1];
    if (next == null)
      return 9999 - cur[0] + 1;
    let years = next[0] - cur[0];
    if (date.month < next[1] || date.month === next[1] && date.day < next[2]) years++;
    return years;
  }
  getDaysInMonth(date) {
    return super.getDaysInMonth($62225008020f0a13$var$toGregorian(date));
  }
  getMinimumMonthInYear(date) {
    let start = $62225008020f0a13$var$getMinimums(date);
    return start ? start[1] : 1;
  }
  getMinimumDayInMonth(date) {
    let start = $62225008020f0a13$var$getMinimums(date);
    return start && date.month === start[1] ? start[2] : 1;
  }
  constructor(...args) {
    super(...args), this.identifier = "japanese";
  }
};
function $62225008020f0a13$var$getMinimums(date) {
  if (date.year === 1) {
    let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);
    return $62225008020f0a13$var$ERA_START_DATES[idx];
  }
}

// node_modules/@internationalized/date/dist/BuddhistCalendar.mjs
var $8d73d47422ca7302$var$BUDDHIST_ERA_START = -543;
var $8d73d47422ca7302$export$42d20a78301dee44 = class extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {
  fromJulianDay(jd) {
    let gregorianDate = super.fromJulianDay(jd);
    let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(gregorianDate.era, gregorianDate.year);
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year - $8d73d47422ca7302$var$BUDDHIST_ERA_START, gregorianDate.month, gregorianDate.day);
  }
  toJulianDay(date) {
    return super.toJulianDay($8d73d47422ca7302$var$toGregorian(date));
  }
  getEras() {
    return [
      "BE"
    ];
  }
  getDaysInMonth(date) {
    return super.getDaysInMonth($8d73d47422ca7302$var$toGregorian(date));
  }
  balanceDate() {
  }
  constructor(...args) {
    super(...args), this.identifier = "buddhist";
  }
};
function $8d73d47422ca7302$var$toGregorian(date) {
  let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)(date.year + $8d73d47422ca7302$var$BUDDHIST_ERA_START);
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, date.month, date.day);
}

// node_modules/@internationalized/date/dist/TaiwanCalendar.mjs
var $5f31bd6f0c8940b2$var$TAIWAN_ERA_START = 1911;
function $5f31bd6f0c8940b2$var$gregorianYear(date) {
  return date.era === "minguo" ? date.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START : 1 - date.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
}
function $5f31bd6f0c8940b2$var$gregorianToTaiwan(year) {
  let y = year - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
  if (y > 0) return [
    "minguo",
    y
  ];
  else return [
    "before_minguo",
    1 - y
  ];
}
var $5f31bd6f0c8940b2$export$65e01080afcb0799 = class extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {
  fromJulianDay(jd) {
    let date = super.fromJulianDay(jd);
    let extendedYear = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);
    let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan(extendedYear);
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, date.month, date.day);
  }
  toJulianDay(date) {
    return super.toJulianDay($5f31bd6f0c8940b2$var$toGregorian(date));
  }
  getEras() {
    return [
      "before_minguo",
      "minguo"
    ];
  }
  balanceDate(date) {
    let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan($5f31bd6f0c8940b2$var$gregorianYear(date));
    date.era = era;
    date.year = year;
  }
  isInverseEra(date) {
    return date.era === "before_minguo";
  }
  getDaysInMonth(date) {
    return super.getDaysInMonth($5f31bd6f0c8940b2$var$toGregorian(date));
  }
  getYearsInEra(date) {
    return date.era === "before_minguo" ? 9999 : 9999 - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
  }
  constructor(...args) {
    super(...args), this.identifier = "roc";
  }
};
function $5f31bd6f0c8940b2$var$toGregorian(date) {
  let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)($5f31bd6f0c8940b2$var$gregorianYear(date));
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, date.month, date.day);
}

// node_modules/@internationalized/date/dist/PersianCalendar.mjs
var $f3ed2e4472ae7e25$var$PERSIAN_EPOCH = 1948320;
var $f3ed2e4472ae7e25$var$MONTH_START = [
  0,
  31,
  62,
  93,
  124,
  155,
  186,
  216,
  246,
  276,
  306,
  336
  // Esfand
];
var $f3ed2e4472ae7e25$export$37fccdbfd14c5939 = class {
  fromJulianDay(jd) {
    let daysSinceEpoch = jd - $f3ed2e4472ae7e25$var$PERSIAN_EPOCH;
    let year = 1 + Math.floor((33 * daysSinceEpoch + 3) / 12053);
    let farvardin1 = 365 * (year - 1) + Math.floor((8 * year + 21) / 33);
    let dayOfYear = daysSinceEpoch - farvardin1;
    let month = dayOfYear < 216 ? Math.floor(dayOfYear / 31) : Math.floor((dayOfYear - 6) / 30);
    let day = dayOfYear - $f3ed2e4472ae7e25$var$MONTH_START[month] + 1;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year, month + 1, day);
  }
  toJulianDay(date) {
    let jd = $f3ed2e4472ae7e25$var$PERSIAN_EPOCH - 1 + 365 * (date.year - 1) + Math.floor((8 * date.year + 21) / 33);
    jd += $f3ed2e4472ae7e25$var$MONTH_START[date.month - 1];
    jd += date.day;
    return jd;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInMonth(date) {
    if (date.month <= 6) return 31;
    if (date.month <= 11) return 30;
    let isLeapYear = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(25 * date.year + 11, 33) < 8;
    return isLeapYear ? 30 : 29;
  }
  getEras() {
    return [
      "AP"
    ];
  }
  getYearsInEra() {
    return 9377;
  }
  constructor() {
    this.identifier = "persian";
  }
};

// node_modules/@internationalized/date/dist/IndianCalendar.mjs
var $82c358003bdda0a8$var$INDIAN_ERA_START = 78;
var $82c358003bdda0a8$var$INDIAN_YEAR_START = 80;
var $82c358003bdda0a8$export$39f31c639fa15726 = class extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {
  fromJulianDay(jd) {
    let date = super.fromJulianDay(jd);
    let indianYear = date.year - $82c358003bdda0a8$var$INDIAN_ERA_START;
    let yDay = jd - (0, $3b62074eb05584b2$export$f297eb839006d339)(date.era, date.year, 1, 1);
    let leapMonth;
    if (yDay < $82c358003bdda0a8$var$INDIAN_YEAR_START) {
      indianYear--;
      leapMonth = (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year - 1) ? 31 : 30;
      yDay += leapMonth + 155 + 90 + 10;
    } else {
      leapMonth = (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year) ? 31 : 30;
      yDay -= $82c358003bdda0a8$var$INDIAN_YEAR_START;
    }
    let indianMonth;
    let indianDay;
    if (yDay < leapMonth) {
      indianMonth = 1;
      indianDay = yDay + 1;
    } else {
      let mDay = yDay - leapMonth;
      if (mDay < 155) {
        indianMonth = Math.floor(mDay / 31) + 2;
        indianDay = mDay % 31 + 1;
      } else {
        mDay -= 155;
        indianMonth = Math.floor(mDay / 30) + 7;
        indianDay = mDay % 30 + 1;
      }
    }
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, indianYear, indianMonth, indianDay);
  }
  toJulianDay(date) {
    let extendedYear = date.year + $82c358003bdda0a8$var$INDIAN_ERA_START;
    let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)(extendedYear);
    let leapMonth;
    let jd;
    if ((0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(year)) {
      leapMonth = 31;
      jd = (0, $3b62074eb05584b2$export$f297eb839006d339)(era, year, 3, 21);
    } else {
      leapMonth = 30;
      jd = (0, $3b62074eb05584b2$export$f297eb839006d339)(era, year, 3, 22);
    }
    if (date.month === 1) return jd + date.day - 1;
    jd += leapMonth + Math.min(date.month - 2, 5) * 31;
    if (date.month >= 8) jd += (date.month - 7) * 30;
    jd += date.day - 1;
    return jd;
  }
  getDaysInMonth(date) {
    if (date.month === 1 && (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year + $82c358003bdda0a8$var$INDIAN_ERA_START)) return 31;
    if (date.month >= 2 && date.month <= 6) return 31;
    return 30;
  }
  getYearsInEra() {
    return 9919;
  }
  getEras() {
    return [
      "saka"
    ];
  }
  balanceDate() {
  }
  constructor(...args) {
    super(...args), this.identifier = "indian";
  }
};

// node_modules/@internationalized/date/dist/IslamicCalendar.mjs
var $f2f3e0e3a817edbd$var$CIVIL_EPOC = 1948440;
var $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC = 1948439;
var $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START = 1300;
var $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END = 1600;
var $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS = 460322;
function $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, day) {
  return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + epoch - 1;
}
function $f2f3e0e3a817edbd$var$julianDayToIslamic(calendar, epoch, jd) {
  let year = Math.floor((30 * (jd - epoch) + 10646) / 10631);
  let month = Math.min(12, Math.ceil((jd - (29 + $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, 1, 1))) / 29.5) + 1);
  let day = jd - $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, 1) + 1;
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(calendar, year, month, day);
}
function $f2f3e0e3a817edbd$var$isLeapYear(year) {
  return (14 + 11 * year) % 30 < 11;
}
var $f2f3e0e3a817edbd$export$2066795aadd37bfc = class {
  fromJulianDay(jd) {
    return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$CIVIL_EPOC, jd);
  }
  toJulianDay(date) {
    return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$CIVIL_EPOC, date.year, date.month, date.day);
  }
  getDaysInMonth(date) {
    let length = 29 + date.month % 2;
    if (date.month === 12 && $f2f3e0e3a817edbd$var$isLeapYear(date.year)) length++;
    return length;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInYear(date) {
    return $f2f3e0e3a817edbd$var$isLeapYear(date.year) ? 355 : 354;
  }
  getYearsInEra() {
    return 9665;
  }
  getEras() {
    return [
      "AH"
    ];
  }
  constructor() {
    this.identifier = "islamic-civil";
  }
};
var $f2f3e0e3a817edbd$export$37f0887f2f9d22f7 = class extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {
  fromJulianDay(jd) {
    return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, jd);
  }
  toJulianDay(date) {
    return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, date.year, date.month, date.day);
  }
  constructor(...args) {
    super(...args), this.identifier = "islamic-tbla";
  }
};
var $f2f3e0e3a817edbd$var$UMALQURA_DATA = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
var $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH;
var $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE;
function $f2f3e0e3a817edbd$var$umalquraYearStart(year) {
  return $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS + $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];
}
function $f2f3e0e3a817edbd$var$umalquraMonthLength(year, month) {
  let idx = year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START;
  let mask = 1 << 11 - (month - 1);
  if (($f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH[idx] & mask) === 0) return 29;
  else return 30;
}
function $f2f3e0e3a817edbd$var$umalquraMonthStart(year, month) {
  let day = $f2f3e0e3a817edbd$var$umalquraYearStart(year);
  for (let i = 1; i < month; i++) day += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i);
  return day;
}
function $f2f3e0e3a817edbd$var$umalquraYearLength(year) {
  return $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year + 1 - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];
}
var $f2f3e0e3a817edbd$export$5baab4758c231076 = class extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {
  fromJulianDay(jd) {
    let days = jd - $f2f3e0e3a817edbd$var$CIVIL_EPOC;
    let startDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_START);
    let endDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END);
    if (days < startDays || days > endDays) return super.fromJulianDay(jd);
    else {
      let y = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START - 1;
      let m = 1;
      let d = 1;
      while (d > 0) {
        y++;
        d = days - $f2f3e0e3a817edbd$var$umalquraYearStart(y) + 1;
        let yearLength = $f2f3e0e3a817edbd$var$umalquraYearLength(y);
        if (d === yearLength) {
          m = 12;
          break;
        } else if (d < yearLength) {
          let monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m);
          m = 1;
          while (d > monthLength) {
            d -= monthLength;
            m++;
            monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m);
          }
          break;
        }
      }
      return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, y, m, days - $f2f3e0e3a817edbd$var$umalquraMonthStart(y, m) + 1);
    }
  }
  toJulianDay(date) {
    if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.toJulianDay(date);
    return $f2f3e0e3a817edbd$var$CIVIL_EPOC + $f2f3e0e3a817edbd$var$umalquraMonthStart(date.year, date.month) + (date.day - 1);
  }
  getDaysInMonth(date) {
    if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInMonth(date);
    return $f2f3e0e3a817edbd$var$umalquraMonthLength(date.year, date.month);
  }
  getDaysInYear(date) {
    if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInYear(date);
    return $f2f3e0e3a817edbd$var$umalquraYearLength(date.year);
  }
  constructor() {
    super(), this.identifier = "islamic-umalqura";
    if (!$f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH) $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH = new Uint16Array(Uint8Array.from(atob($f2f3e0e3a817edbd$var$UMALQURA_DATA), (c2) => c2.charCodeAt(0)).buffer);
    if (!$f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE) {
      $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE = new Uint32Array($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START + 1);
      let yearStart = 0;
      for (let year = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START; year <= $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END; year++) {
        $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] = yearStart;
        for (let i = 1; i <= 12; i++) yearStart += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i);
      }
    }
  }
};

// node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HEBREW_EPOCH = 347997;
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;
function $7c5f6fbf42389787$var$isLeapYear(year) {
  return (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(year * 7 + 1, 19) < 7;
}
function $7c5f6fbf42389787$var$hebrewDelay1(year) {
  let months = Math.floor((235 * year - 234) / 19);
  let parts = 12084 + 13753 * months;
  let day = months * 29 + Math.floor(parts / 25920);
  if ((0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(3 * (day + 1), 7) < 3) day += 1;
  return day;
}
function $7c5f6fbf42389787$var$hebrewDelay2(year) {
  let last = $7c5f6fbf42389787$var$hebrewDelay1(year - 1);
  let present = $7c5f6fbf42389787$var$hebrewDelay1(year);
  let next = $7c5f6fbf42389787$var$hebrewDelay1(year + 1);
  if (next - present === 356) return 2;
  if (present - last === 382) return 1;
  return 0;
}
function $7c5f6fbf42389787$var$startOfYear(year) {
  return $7c5f6fbf42389787$var$hebrewDelay1(year) + $7c5f6fbf42389787$var$hebrewDelay2(year);
}
function $7c5f6fbf42389787$var$getDaysInYear(year) {
  return $7c5f6fbf42389787$var$startOfYear(year + 1) - $7c5f6fbf42389787$var$startOfYear(year);
}
function $7c5f6fbf42389787$var$getYearType(year) {
  let yearLength = $7c5f6fbf42389787$var$getDaysInYear(year);
  if (yearLength > 380) yearLength -= 30;
  switch (yearLength) {
    case 353:
      return 0;
    // deficient
    case 354:
      return 1;
    // normal
    case 355:
      return 2;
  }
}
function $7c5f6fbf42389787$var$getDaysInMonth(year, month) {
  if (month >= 6 && !$7c5f6fbf42389787$var$isLeapYear(year)) month++;
  if (month === 4 || month === 7 || month === 9 || month === 11 || month === 13) return 29;
  let yearType = $7c5f6fbf42389787$var$getYearType(year);
  if (month === 2) return yearType === 2 ? 30 : 29;
  if (month === 3) return yearType === 0 ? 29 : 30;
  if (month === 6) return $7c5f6fbf42389787$var$isLeapYear(year) ? 30 : 0;
  return 30;
}
var $7c5f6fbf42389787$export$ca405048b8fb5af = class {
  fromJulianDay(jd) {
    let d = jd - $7c5f6fbf42389787$var$HEBREW_EPOCH;
    let m = d * $7c5f6fbf42389787$var$DAY_PARTS / $7c5f6fbf42389787$var$MONTH_PARTS;
    let year = Math.floor((19 * m + 234) / 235) + 1;
    let ys = $7c5f6fbf42389787$var$startOfYear(year);
    let dayOfYear = Math.floor(d - ys);
    while (dayOfYear < 1) {
      year--;
      ys = $7c5f6fbf42389787$var$startOfYear(year);
      dayOfYear = Math.floor(d - ys);
    }
    let month = 1;
    let monthStart = 0;
    while (monthStart < dayOfYear) {
      monthStart += $7c5f6fbf42389787$var$getDaysInMonth(year, month);
      month++;
    }
    month--;
    monthStart -= $7c5f6fbf42389787$var$getDaysInMonth(year, month);
    let day = dayOfYear - monthStart;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year, month, day);
  }
  toJulianDay(date) {
    let jd = $7c5f6fbf42389787$var$startOfYear(date.year);
    for (let month = 1; month < date.month; month++) jd += $7c5f6fbf42389787$var$getDaysInMonth(date.year, month);
    return jd + date.day + $7c5f6fbf42389787$var$HEBREW_EPOCH;
  }
  getDaysInMonth(date) {
    return $7c5f6fbf42389787$var$getDaysInMonth(date.year, date.month);
  }
  getMonthsInYear(date) {
    return $7c5f6fbf42389787$var$isLeapYear(date.year) ? 13 : 12;
  }
  getDaysInYear(date) {
    return $7c5f6fbf42389787$var$getDaysInYear(date.year);
  }
  getYearsInEra() {
    return 9999;
  }
  getEras() {
    return [
      "AM"
    ];
  }
  balanceYearMonth(date, previousDate) {
    if (previousDate.year !== date.year) {
      if ($7c5f6fbf42389787$var$isLeapYear(previousDate.year) && !$7c5f6fbf42389787$var$isLeapYear(date.year) && previousDate.month > 6) date.month--;
      else if (!$7c5f6fbf42389787$var$isLeapYear(previousDate.year) && $7c5f6fbf42389787$var$isLeapYear(date.year) && previousDate.month > 6) date.month++;
    }
  }
  constructor() {
    this.identifier = "hebrew";
  }
};

// node_modules/@internationalized/date/dist/EthiopicCalendar.mjs
var $b956b2d7a6cf451f$var$ETHIOPIC_EPOCH = 1723856;
var $b956b2d7a6cf451f$var$COPTIC_EPOCH = 1824665;
var $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA = 5500;
function $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, day) {
  return epoch + 365 * year + Math.floor(year / 4) + 30 * (month - 1) + day - 1;
}
function $b956b2d7a6cf451f$var$julianDayToCE(epoch, jd) {
  let year = Math.floor(4 * (jd - epoch) / 1461);
  let month = 1 + Math.floor((jd - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, 1, 1)) / 30);
  let day = jd + 1 - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, 1);
  return [
    year,
    month,
    day
  ];
}
function $b956b2d7a6cf451f$var$getLeapDay(year) {
  return Math.floor(year % 4 / 3);
}
function $b956b2d7a6cf451f$var$getDaysInMonth(year, month) {
  if (month % 13 !== 0)
    return 30;
  else
    return $b956b2d7a6cf451f$var$getLeapDay(year) + 5;
}
var $b956b2d7a6cf451f$export$26ba6eab5e20cd7d = class {
  fromJulianDay(jd) {
    let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);
    let era = "AM";
    if (year <= 0) {
      era = "AA";
      year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
    }
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, month, day);
  }
  toJulianDay(date) {
    let year = date.year;
    if (date.era === "AA") year -= $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
    return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, year, date.month, date.day);
  }
  getDaysInMonth(date) {
    return $b956b2d7a6cf451f$var$getDaysInMonth(date.year, date.month);
  }
  getMonthsInYear() {
    return 13;
  }
  getDaysInYear(date) {
    return 365 + $b956b2d7a6cf451f$var$getLeapDay(date.year);
  }
  getYearsInEra(date) {
    return date.era === "AA" ? 9999 : 9991;
  }
  getEras() {
    return [
      "AA",
      "AM"
    ];
  }
  constructor() {
    this.identifier = "ethiopic";
  }
};
var $b956b2d7a6cf451f$export$d72e0c37005a4914 = class extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
  fromJulianDay(jd) {
    let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);
    year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, "AA", year, month, day);
  }
  getEras() {
    return [
      "AA"
    ];
  }
  getYearsInEra() {
    return 9999;
  }
  constructor(...args) {
    super(...args), this.identifier = "ethioaa";
  }
};
var $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1 = class extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
  fromJulianDay(jd) {
    let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$COPTIC_EPOCH, jd);
    let era = "CE";
    if (year <= 0) {
      era = "BCE";
      year = 1 - year;
    }
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, month, day);
  }
  toJulianDay(date) {
    let year = date.year;
    if (date.era === "BCE") year = 1 - year;
    return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$COPTIC_EPOCH, year, date.month, date.day);
  }
  getDaysInMonth(date) {
    let year = date.year;
    if (date.era === "BCE") year = 1 - year;
    return $b956b2d7a6cf451f$var$getDaysInMonth(year, date.month);
  }
  isInverseEra(date) {
    return date.era === "BCE";
  }
  balanceDate(date) {
    if (date.year <= 0) {
      date.era = date.era === "BCE" ? "CE" : "BCE";
      date.year = 1 - date.year;
    }
  }
  getEras() {
    return [
      "BCE",
      "CE"
    ];
  }
  getYearsInEra(date) {
    return date.era === "BCE" ? 9999 : 9715;
  }
  constructor(...args) {
    super(...args), this.identifier = "coptic";
  }
};

// node_modules/@internationalized/date/dist/createCalendar.mjs
function $64244302c3013299$export$dd0bbc9b26defe37(name) {
  switch (name) {
    case "buddhist":
      return new (0, $8d73d47422ca7302$export$42d20a78301dee44)();
    case "ethiopic":
      return new (0, $b956b2d7a6cf451f$export$26ba6eab5e20cd7d)();
    case "ethioaa":
      return new (0, $b956b2d7a6cf451f$export$d72e0c37005a4914)();
    case "coptic":
      return new (0, $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1)();
    case "hebrew":
      return new (0, $7c5f6fbf42389787$export$ca405048b8fb5af)();
    case "indian":
      return new (0, $82c358003bdda0a8$export$39f31c639fa15726)();
    case "islamic-civil":
      return new (0, $f2f3e0e3a817edbd$export$2066795aadd37bfc)();
    case "islamic-tbla":
      return new (0, $f2f3e0e3a817edbd$export$37f0887f2f9d22f7)();
    case "islamic-umalqura":
      return new (0, $f2f3e0e3a817edbd$export$5baab4758c231076)();
    case "japanese":
      return new (0, $62225008020f0a13$export$b746ab2b60cdffbf)();
    case "persian":
      return new (0, $f3ed2e4472ae7e25$export$37fccdbfd14c5939)();
    case "roc":
      return new (0, $5f31bd6f0c8940b2$export$65e01080afcb0799)();
    case "gregory":
    default:
      return new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();
  }
}

// node_modules/@internationalized/date/dist/DateFormatter.mjs
var $fb18d541ea1ad717$var$formatterCache = /* @__PURE__ */ new Map();
var $fb18d541ea1ad717$export$ad991b66133851cf = class {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(value) {
    return this.formatter.format(value);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(value) {
    return this.formatter.formatToParts(value);
  }
  /** Formats a date range as a string. */
  formatRange(start, end) {
    if (typeof this.formatter.formatRange === "function")
      return this.formatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(start)} – ${this.formatter.format(end)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.formatter.formatRangeToParts === "function")
      return this.formatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.formatter.formatToParts(start);
    let endParts = this.formatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let resolvedOptions = this.formatter.resolvedOptions();
    if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {
      if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
      resolvedOptions.hourCycle = this.resolvedHourCycle;
      resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
    }
    if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
    return resolvedOptions;
  }
  constructor(locale, options = {}) {
    this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);
    this.options = options;
  }
};
var $fb18d541ea1ad717$var$hour12Preferences = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {
  if (typeof options.hour12 === "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
    options = {
      ...options
    };
    let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
    let defaultHourCycle = options.hour12 ? "h12" : "h23";
    options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
    delete options.hour12;
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.DateTimeFormat(locale, options);
  $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
var $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
  if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: false
  }).format(new Date(2020, 2, 3, 0)) === "24";
  return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
}
var $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
  if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: false
  }).resolvedOptions().hourCycle === "h12";
  return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
}
function $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {
  if (!options.timeStyle && !options.hour) return void 0;
  locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
  locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
  let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {
    ...options,
    timeZone: void 0
    // use local timezone
  });
  let min2 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p) => p.type === "hour").value, 10);
  let max2 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p) => p.type === "hour").value, 10);
  if (min2 === 0 && max2 === 23) return "h23";
  if (min2 === 24 && max2 === 23) return "h24";
  if (min2 === 0 && max2 === 11) return "h11";
  if (min2 === 12 && max2 === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}

// node_modules/reka-ui/dist/date/comparators.js
function getDefaultDate(props2) {
  const { defaultValue, defaultPlaceholder, granularity = "day", locale = "en" } = props2;
  if (Array.isArray(defaultValue) && defaultValue.length)
    return defaultValue.at(-1).copy();
  if (defaultValue && !Array.isArray(defaultValue))
    return defaultValue.copy();
  if (defaultPlaceholder)
    return defaultPlaceholder.copy();
  const date = /* @__PURE__ */ new Date();
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const calendarDateTimeGranularities2 = ["hour", "minute", "second"];
  const defaultFormatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale);
  const calendar = $64244302c3013299$export$dd0bbc9b26defe37(defaultFormatter.resolvedOptions().calendar);
  if (calendarDateTimeGranularities2.includes(granularity ?? "day"))
    return $11d87f3f76e88657$export$b4a036af3fc0b032(new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(year, month, day, 0, 0, 0), calendar);
  return $11d87f3f76e88657$export$b4a036af3fc0b032(new $35ea8db9cb2ccb90$export$99faa760c7908e4f(year, month, day), calendar);
}
function getDefaultTime(props2) {
  const { defaultValue, defaultPlaceholder } = props2;
  if (defaultValue) {
    return defaultValue.copy();
  }
  if (defaultPlaceholder) {
    return defaultPlaceholder.copy();
  }
  return new $35ea8db9cb2ccb90$export$680ea196effce5f(0, 0, 0);
}
function toDate(dateValue, tz = $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) {
  if (isZonedDateTime(dateValue))
    return dateValue.toDate();
  else
    return dateValue.toDate(tz);
}
function isCalendarDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f;
}
function isZonedDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea;
}
function hasTime(dateValue) {
  return isCalendarDateTime(dateValue) || isZonedDateTime(dateValue);
}
function getDaysInMonth(date) {
  if (date instanceof Date) {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    return new Date(year, month, 0).getDate();
  } else {
    return date.set({ day: 100 }).day;
  }
}
function isBefore(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) < 0;
}
function isAfter(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) > 0;
}
function isBeforeOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) <= 0;
}
function isAfterOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) >= 0;
}
function isBetweenInclusive(date, start, end) {
  return isAfterOrSame(date, start) && isBeforeOrSame(date, end);
}
function isBetween(date, start, end) {
  return isAfter(date, start) && isBefore(date, end);
}
function getLastFirstDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  if (firstDayOfWeek > day)
    return date.subtract({ days: day + 7 - firstDayOfWeek });
  if (firstDayOfWeek === day)
    return date;
  return date.subtract({ days: day - firstDayOfWeek });
}
function getNextLastDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  const lastDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
  if (day === lastDayOfWeek)
    return date;
  if (day > lastDayOfWeek)
    return date.add({ days: 7 - day + lastDayOfWeek });
  return date.add({ days: lastDayOfWeek - day });
}
function areAllDaysBetweenValid(start, end, isUnavailable, isDisabled, isHighlightable) {
  if (isUnavailable === void 0 && isDisabled === void 0 && isHighlightable === void 0)
    return true;
  let dCurrent = start.add({ days: 1 });
  if ((isDisabled?.(dCurrent) || isUnavailable?.(dCurrent)) && !isHighlightable?.(dCurrent)) {
    return false;
  }
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    dCurrent = dCurrent.add({ days: 1 });
    if ((isDisabled?.(dCurrent) || isUnavailable?.(dCurrent)) && !isHighlightable?.(dCurrent)) {
      return false;
    }
  }
  return true;
}

// node_modules/reka-ui/dist/date/utils.js
function chunk(arr, size3) {
  const result = [];
  for (let i = 0; i < arr.length; i += size3)
    result.push(arr.slice(i, i + size3));
  return result;
}
function getOptsByGranularity(granularity, hourCycle, isTimeValue = false) {
  const opts = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: hourCycle === 24 ? "h23" : void 0,
    hour12: hourCycle === 24 ? false : void 0
  };
  if (isTimeValue) {
    delete opts.year;
    delete opts.month;
    delete opts.day;
  }
  if (granularity === "day") {
    delete opts.second;
    delete opts.hour;
    delete opts.minute;
    delete opts.timeZoneName;
  }
  if (granularity === "hour") {
    delete opts.minute;
    delete opts.second;
  }
  if (granularity === "minute")
    delete opts.second;
  return opts;
}
function handleCalendarInitialFocus(calendar) {
  const selectedDay = calendar.querySelector("[data-selected]");
  if (selectedDay)
    return selectedDay.focus();
  const today = calendar.querySelector("[data-today]");
  if (today)
    return today.focus();
  const firstDay = calendar.querySelector("[data-reka-calendar-day]");
  if (firstDay)
    return firstDay.focus();
}

// node_modules/reka-ui/dist/date/calendar.js
function getDaysBetween(start, end) {
  const days = [];
  let dCurrent = start.add({ days: 1 });
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    days.push(dCurrent);
    dCurrent = dCurrent.add({ days: 1 });
  }
  return days;
}
function createMonth(props2) {
  const { dateObj, weekStartsOn, fixedWeeks, locale } = props2;
  const daysInMonth = getDaysInMonth(dateObj);
  const datesArray = Array.from({ length: daysInMonth }, (_, i) => dateObj.set({ day: i + 1 }));
  const firstDayOfMonth = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(dateObj);
  const lastDayOfMonth = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
  const lastSunday = getLastFirstDayOfWeek(firstDayOfMonth, weekStartsOn, locale);
  const nextSaturday = getNextLastDayOfWeek(lastDayOfMonth, weekStartsOn, locale);
  const lastMonthDays = getDaysBetween(lastSunday.subtract({ days: 1 }), firstDayOfMonth);
  const nextMonthDays = getDaysBetween(lastDayOfMonth, nextSaturday.add({ days: 1 }));
  const totalDays = lastMonthDays.length + datesArray.length + nextMonthDays.length;
  if (fixedWeeks && totalDays < 42) {
    const extraDays = 42 - totalDays;
    let startFrom = nextMonthDays[nextMonthDays.length - 1];
    if (!startFrom)
      startFrom = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
    const extraDaysArray = Array.from({ length: extraDays }, (_, i) => {
      const incr = i + 1;
      return startFrom.add({ days: incr });
    });
    nextMonthDays.push(...extraDaysArray);
  }
  const allDays = lastMonthDays.concat(datesArray, nextMonthDays);
  const weeks = chunk(allDays, 7);
  return {
    value: dateObj,
    cells: allDays,
    rows: weeks
  };
}
function createMonths(props2) {
  const { numberOfMonths, dateObj, ...monthProps } = props2;
  const months = [];
  if (!numberOfMonths || numberOfMonths === 1) {
    months.push(
      createMonth({
        ...monthProps,
        dateObj
      })
    );
    return months;
  }
  months.push(
    createMonth({
      ...monthProps,
      dateObj
    })
  );
  for (let i = 1; i < numberOfMonths; i++) {
    const nextMonth = dateObj.add({ months: i });
    months.push(
      createMonth({
        ...monthProps,
        dateObj: nextMonth
      })
    );
  }
  return months;
}

// node_modules/reka-ui/dist/Calendar/useCalendar.js
import { computed as computed15, ref as ref21, watch as watch11 } from "vue";

// node_modules/reka-ui/dist/shared/useDateFormatter.js
import { ref as ref20 } from "vue";
function useDateFormatter(initialLocale) {
  const locale = ref20(initialLocale);
  function getLocale() {
    return locale.value;
  }
  function setLocale(newLocale) {
    locale.value = newLocale;
  }
  function custom(date, options) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, options).format(date);
  }
  function selectedDate(date, includeTime = true) {
    if (hasTime(date) && includeTime) {
      return custom(toDate(date), {
        dateStyle: "long",
        timeStyle: "long"
      });
    } else {
      return custom(toDate(date), {
        dateStyle: "long"
      });
    }
  }
  function fullMonthAndYear(date, options = {}) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, { month: "long", year: "numeric", ...options }).format(date);
  }
  function fullMonth(date, options = {}) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, { month: "long", ...options }).format(date);
  }
  function getMonths() {
    const defaultDate = $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3($14e0f24ef4ac5c92$export$aa8b41735afcabd2());
    const months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    return months.map((item) => ({ label: fullMonth(toDate(defaultDate.set({ month: item }))), value: item }));
  }
  function fullYear(date, options = {}) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, { year: "numeric", ...options }).format(date);
  }
  function toParts(date, options) {
    if (isZonedDateTime(date)) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
        ...options,
        timeZone: date.timeZone
      }).formatToParts(toDate(date));
    } else {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, options).formatToParts(toDate(date));
    }
  }
  function dayOfWeek(date, length = "narrow") {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, { weekday: length }).format(date);
  }
  function dayPeriod(date) {
    const parts = new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
      hour: "numeric",
      minute: "numeric"
    }).formatToParts(date);
    const value = parts.find((p) => p.type === "dayPeriod")?.value;
    if (value === "PM")
      return "PM";
    return "AM";
  }
  const defaultPartOptions = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  };
  function part(dateObj, type, options = {}) {
    const opts = { ...defaultPartOptions, ...options };
    const parts = toParts(dateObj, opts);
    const part2 = parts.find((p) => p.type === type);
    return part2 ? part2.value : "";
  }
  return {
    setLocale,
    getLocale,
    fullMonth,
    fullYear,
    fullMonthAndYear,
    toParts,
    custom,
    part,
    dayPeriod,
    selectedDate,
    dayOfWeek,
    getMonths
  };
}

// node_modules/reka-ui/dist/Calendar/useCalendar.js
function useCalendarState(props2) {
  function isDateSelected(dateObj) {
    if (Array.isArray(props2.date.value))
      return props2.date.value.some((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, dateObj));
    else if (!props2.date.value)
      return false;
    else
      return $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.date.value, dateObj);
  }
  const isInvalid = computed15(
    () => {
      if (Array.isArray(props2.date.value)) {
        if (!props2.date.value.length)
          return false;
        for (const dateObj of props2.date.value) {
          if (props2.isDateDisabled?.(dateObj))
            return true;
          if (props2.isDateUnavailable?.(dateObj))
            return true;
        }
      } else {
        if (!props2.date.value)
          return false;
        if (props2.isDateDisabled?.(props2.date.value))
          return true;
        if (props2.isDateUnavailable?.(props2.date.value))
          return true;
      }
      return false;
    }
  );
  return {
    isDateSelected,
    isInvalid
  };
}
function handleNextDisabled(lastPeriodInView, nextPageFunc) {
  const firstPeriodOfNextPage = nextPageFunc(lastPeriodInView);
  const diff = firstPeriodOfNextPage.compare(lastPeriodInView);
  const duration = {};
  if (diff >= 7)
    duration.day = 1;
  if (diff >= getDaysInMonth(lastPeriodInView))
    duration.month = 1;
  return firstPeriodOfNextPage.set({ ...duration });
}
function handlePrevDisabled(firstPeriodInView, prevPageFunc) {
  const lastPeriodOfPrevPage = prevPageFunc(firstPeriodInView);
  const diff = firstPeriodInView.compare(lastPeriodOfPrevPage);
  const duration = {};
  if (diff >= 7)
    duration.day = 35;
  if (diff >= getDaysInMonth(firstPeriodInView))
    duration.month = 13;
  return lastPeriodOfPrevPage.set({ ...duration });
}
function handleNextPage(date, nextPageFunc) {
  return nextPageFunc(date);
}
function handlePrevPage(date, prevPageFunc) {
  return prevPageFunc(date);
}
function useCalendar(props2) {
  const formatter = useDateFormatter(props2.locale.value);
  const headingFormatOptions = computed15(() => {
    const options = {
      calendar: props2.placeholder.value.calendar.identifier
    };
    if (props2.placeholder.value.calendar.identifier === "gregory" && props2.placeholder.value.era === "BC")
      options.era = "short";
    return options;
  });
  const grid = ref21(createMonths({
    dateObj: props2.placeholder.value,
    weekStartsOn: props2.weekStartsOn.value,
    locale: props2.locale.value,
    fixedWeeks: props2.fixedWeeks.value,
    numberOfMonths: props2.numberOfMonths.value
  }));
  const visibleView = computed15(() => {
    return grid.value.map((month) => month.value);
  });
  function isOutsideVisibleView(date) {
    return !visibleView.value.some((month) => $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(date, month));
  }
  const isNextButtonDisabled = (nextPageFunc) => {
    if (!props2.maxValue.value || !grid.value.length)
      return false;
    if (props2.disabled.value)
      return true;
    const lastPeriodInView = grid.value[grid.value.length - 1].value;
    if (!nextPageFunc && !props2.nextPage.value) {
      const firstPeriodOfNextPage2 = lastPeriodInView.add({ months: 1 }).set({ day: 1 });
      return isAfter(firstPeriodOfNextPage2, props2.maxValue.value);
    }
    const firstPeriodOfNextPage = handleNextDisabled(lastPeriodInView, nextPageFunc || props2.nextPage.value);
    return isAfter(firstPeriodOfNextPage, props2.maxValue.value);
  };
  const isPrevButtonDisabled = (prevPageFunc) => {
    if (!props2.minValue.value || !grid.value.length)
      return false;
    if (props2.disabled.value)
      return true;
    const firstPeriodInView = grid.value[0].value;
    if (!prevPageFunc && !props2.prevPage.value) {
      const lastPeriodOfPrevPage2 = firstPeriodInView.subtract({ months: 1 }).set({ day: 35 });
      return isBefore(lastPeriodOfPrevPage2, props2.minValue.value);
    }
    const lastPeriodOfPrevPage = handlePrevDisabled(firstPeriodInView, prevPageFunc || props2.prevPage.value);
    return isBefore(lastPeriodOfPrevPage, props2.minValue.value);
  };
  function isDateDisabled(dateObj) {
    if (props2.isDateDisabled?.(dateObj) || props2.disabled.value)
      return true;
    if (props2.maxValue.value && isAfter(dateObj, props2.maxValue.value))
      return true;
    if (props2.minValue.value && isBefore(dateObj, props2.minValue.value))
      return true;
    return false;
  }
  const isDateUnavailable = (date) => {
    if (props2.isDateUnavailable?.(date))
      return true;
    return false;
  };
  const weekdays = computed15(() => {
    if (!grid.value.length)
      return [];
    return grid.value[0].rows[0].map((date) => {
      return formatter.dayOfWeek(toDate(date), props2.weekdayFormat.value);
    });
  });
  const nextPage = (nextPageFunc) => {
    const firstDate = grid.value[0].value;
    if (!nextPageFunc && !props2.nextPage.value) {
      const newDate2 = firstDate.add({ months: props2.pagedNavigation.value ? props2.numberOfMonths.value : 1 });
      const newGrid2 = createMonths({
        dateObj: newDate2,
        weekStartsOn: props2.weekStartsOn.value,
        locale: props2.locale.value,
        fixedWeeks: props2.fixedWeeks.value,
        numberOfMonths: props2.numberOfMonths.value
      });
      grid.value = newGrid2;
      props2.placeholder.value = newGrid2[0].value.set({ day: 1 });
      return;
    }
    const newDate = handleNextPage(firstDate, nextPageFunc || props2.nextPage.value);
    const newGrid = createMonths({
      dateObj: newDate,
      weekStartsOn: props2.weekStartsOn.value,
      locale: props2.locale.value,
      fixedWeeks: props2.fixedWeeks.value,
      numberOfMonths: props2.numberOfMonths.value
    });
    grid.value = newGrid;
    const duration = {};
    if (!nextPageFunc) {
      const diff = newGrid[0].value.compare(firstDate);
      if (diff >= getDaysInMonth(firstDate))
        duration.day = 1;
      if (diff >= 365)
        duration.month = 1;
    }
    props2.placeholder.value = newGrid[0].value.set({ ...duration });
  };
  const prevPage = (prevPageFunc) => {
    const firstDate = grid.value[0].value;
    if (!prevPageFunc && !props2.prevPage.value) {
      const newDate2 = firstDate.subtract({ months: props2.pagedNavigation.value ? props2.numberOfMonths.value : 1 });
      const newGrid2 = createMonths({
        dateObj: newDate2,
        weekStartsOn: props2.weekStartsOn.value,
        locale: props2.locale.value,
        fixedWeeks: props2.fixedWeeks.value,
        numberOfMonths: props2.numberOfMonths.value
      });
      grid.value = newGrid2;
      props2.placeholder.value = newGrid2[0].value.set({ day: 1 });
      return;
    }
    const newDate = handlePrevPage(firstDate, prevPageFunc || props2.prevPage.value);
    const newGrid = createMonths({
      dateObj: newDate,
      weekStartsOn: props2.weekStartsOn.value,
      locale: props2.locale.value,
      fixedWeeks: props2.fixedWeeks.value,
      numberOfMonths: props2.numberOfMonths.value
    });
    grid.value = newGrid;
    const duration = {};
    if (!prevPageFunc) {
      const diff = firstDate.compare(newGrid[0].value);
      if (diff >= getDaysInMonth(firstDate))
        duration.day = 1;
      if (diff >= 365)
        duration.month = 1;
    }
    props2.placeholder.value = newGrid[0].value.set({ ...duration });
  };
  watch11(props2.placeholder, (value) => {
    if (visibleView.value.some((month) => $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(month, value)))
      return;
    grid.value = createMonths({
      dateObj: value,
      weekStartsOn: props2.weekStartsOn.value,
      locale: props2.locale.value,
      fixedWeeks: props2.fixedWeeks.value,
      numberOfMonths: props2.numberOfMonths.value
    });
  });
  watch11([props2.locale, props2.weekStartsOn, props2.fixedWeeks, props2.numberOfMonths], () => {
    grid.value = createMonths({
      dateObj: props2.placeholder.value,
      weekStartsOn: props2.weekStartsOn.value,
      locale: props2.locale.value,
      fixedWeeks: props2.fixedWeeks.value,
      numberOfMonths: props2.numberOfMonths.value
    });
  });
  const headingValue = computed15(() => {
    if (!grid.value.length)
      return "";
    if (props2.locale.value !== formatter.getLocale())
      formatter.setLocale(props2.locale.value);
    if (grid.value.length === 1) {
      const month = grid.value[0].value;
      return `${formatter.fullMonthAndYear(toDate(month), headingFormatOptions.value)}`;
    }
    const startMonth = toDate(grid.value[0].value);
    const endMonth = toDate(grid.value[grid.value.length - 1].value);
    const startMonthName = formatter.fullMonth(startMonth, headingFormatOptions.value);
    const endMonthName = formatter.fullMonth(endMonth, headingFormatOptions.value);
    const startMonthYear = formatter.fullYear(startMonth, headingFormatOptions.value);
    const endMonthYear = formatter.fullYear(endMonth, headingFormatOptions.value);
    const content = startMonthYear === endMonthYear ? `${startMonthName} - ${endMonthName} ${endMonthYear}` : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
    return content;
  });
  const fullCalendarLabel = computed15(() => `${props2.calendarLabel.value ?? "Event Date"}, ${headingValue.value}`);
  return {
    isDateDisabled,
    isDateUnavailable,
    isNextButtonDisabled,
    isPrevButtonDisabled,
    grid,
    weekdays,
    visibleView,
    isOutsideVisibleView,
    formatter,
    nextPage,
    prevPage,
    headingValue,
    fullCalendarLabel
  };
}

// node_modules/reka-ui/dist/Primitive/usePrimitiveElement.js
import { ref as ref22, computed as computed16 } from "vue";
function usePrimitiveElement() {
  const primitiveElement = ref22();
  const currentElement = computed16(() => ["#text", "#comment"].includes(primitiveElement.value?.$el.nodeName) ? primitiveElement.value?.$el.nextElementSibling : unrefElement(primitiveElement));
  return {
    primitiveElement,
    currentElement
  };
}

// node_modules/reka-ui/dist/shared/useLocale.js
import { ref as ref23, computed as computed17 } from "vue";
function useLocale(locale) {
  const context2 = injectConfigProviderContext({
    locale: ref23("en")
  });
  return computed17(() => locale?.value || context2.locale?.value || "en");
}

// node_modules/reka-ui/dist/Calendar/CalendarRoot.js
var _hoisted_1 = { style: { "border": "0px", "clip": "rect(0px, 0px, 0px, 0px)", "clip-path": "inset(50%)", "height": "1px", "margin": "-1px", "overflow": "hidden", "padding": "0px", "position": "absolute", "white-space": "nowrap", "width": "1px" } };
var _hoisted_2 = {
  role: "heading",
  "aria-level": "2"
};
var [injectCalendarRootContext, provideCalendarRootContext] = createContext("CalendarRoot");
var _sfc_main38 = defineComponent42({
  __name: "CalendarRoot",
  props: {
    modelValue: {},
    multiple: { type: Boolean, default: false },
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    pagedNavigation: { type: Boolean, default: false },
    preventDeselect: { type: Boolean, default: false },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    calendarLabel: {},
    fixedWeeks: { type: Boolean, default: false },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: { default: 1 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    initialFocus: { type: Boolean, default: false },
    isDateDisabled: { type: Function, default: void 0 },
    isDateUnavailable: { type: Function, default: void 0 },
    dir: {},
    nextPage: {},
    prevPage: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const {
      disabled,
      readonly: readonly3,
      initialFocus,
      pagedNavigation,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      multiple,
      minValue,
      maxValue,
      numberOfMonths,
      preventDeselect,
      isDateDisabled: propsIsDateDisabled,
      isDateUnavailable: propsIsDateUnavailable,
      calendarLabel,
      defaultValue,
      nextPage: propsNextPage,
      prevPage: propsPrevPage,
      dir: propDir,
      locale: propLocale
    } = toRefs8(props2);
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const locale = useLocale(propLocale);
    const dir = useDirection(propDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: defaultValue.value,
      passive: props2.modelValue === void 0
    });
    const defaultDate = getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      defaultValue: modelValue.value,
      locale: props2.locale
    });
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    function onPlaceholderChange(value) {
      placeholder.value = value.copy();
    }
    const {
      fullCalendarLabel,
      headingValue,
      isDateDisabled,
      isDateUnavailable,
      isNextButtonDisabled,
      isPrevButtonDisabled,
      weekdays,
      isOutsideVisibleView,
      nextPage,
      prevPage,
      formatter,
      grid
    } = useCalendar({
      locale,
      placeholder,
      weekStartsOn,
      fixedWeeks,
      numberOfMonths,
      minValue,
      maxValue,
      disabled,
      weekdayFormat,
      pagedNavigation,
      isDateDisabled: propsIsDateDisabled.value,
      isDateUnavailable: propsIsDateUnavailable.value,
      calendarLabel,
      nextPage: propsNextPage,
      prevPage: propsPrevPage
    });
    const {
      isInvalid,
      isDateSelected
    } = useCalendarState({
      date: modelValue,
      isDateDisabled,
      isDateUnavailable
    });
    watch12(modelValue, (_modelValue) => {
      if (Array.isArray(_modelValue) && _modelValue.length) {
        const lastValue = _modelValue[_modelValue.length - 1];
        if (lastValue && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(placeholder.value, lastValue))
          onPlaceholderChange(lastValue);
      } else if (!Array.isArray(_modelValue) && _modelValue && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(placeholder.value, _modelValue)) {
        onPlaceholderChange(_modelValue);
      }
    });
    function onDateChange(value) {
      if (!multiple.value) {
        if (!modelValue.value) {
          modelValue.value = value.copy();
          return;
        }
        if (!preventDeselect.value && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(modelValue.value, value)) {
          placeholder.value = value.copy();
          modelValue.value = void 0;
        } else {
          modelValue.value = value.copy();
        }
      } else if (!modelValue.value) {
        modelValue.value = [value.copy()];
      } else if (Array.isArray(modelValue.value)) {
        const index = modelValue.value.findIndex((date) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, value));
        if (index === -1) {
          modelValue.value = [...modelValue.value, value];
        } else if (!preventDeselect.value) {
          const next = modelValue.value.filter((date) => !$14e0f24ef4ac5c92$export$ea39ec197993aef0(date, value));
          if (!next.length) {
            placeholder.value = value.copy();
            modelValue.value = void 0;
            return;
          }
          modelValue.value = next.map((date) => date.copy());
        }
      }
    }
    onMounted9(() => {
      if (initialFocus.value)
        handleCalendarInitialFocus(parentElement.value);
    });
    provideCalendarRootContext({
      isDateUnavailable,
      dir,
      isDateDisabled,
      locale,
      formatter,
      modelValue,
      placeholder,
      disabled,
      initialFocus,
      pagedNavigation,
      grid,
      weekDays: weekdays,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      multiple,
      numberOfMonths,
      readonly: readonly3,
      preventDeselect,
      fullCalendarLabel,
      headingValue,
      isInvalid,
      isDateSelected,
      isNextButtonDisabled,
      isPrevButtonDisabled,
      isOutsideVisibleView,
      nextPage,
      prevPage,
      parentElement,
      onPlaceholderChange,
      onDateChange
    });
    return (_ctx, _cache) => {
      return openBlock36(), createBlock35(unref40(Primitive), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        role: "application",
        "aria-label": unref40(fullCalendarLabel),
        "data-readonly": unref40(readonly3) ? "" : void 0,
        "data-disabled": unref40(disabled) ? "" : void 0,
        "data-invalid": unref40(isInvalid) ? "" : void 0,
        dir: unref40(dir)
      }, {
        default: withCtx35(() => [
          renderSlot38(_ctx.$slots, "default", {
            date: unref40(placeholder),
            grid: unref40(grid),
            weekDays: unref40(weekdays),
            weekStartsOn: unref40(weekStartsOn),
            locale: unref40(locale),
            fixedWeeks: unref40(fixedWeeks),
            modelValue: unref40(modelValue)
          }),
          createElementVNode("div", _hoisted_1, [
            createElementVNode("div", _hoisted_2, toDisplayString(unref40(fullCalendarLabel)), 1)
          ])
        ]),
        _: 3
      }, 8, ["as", "as-child", "aria-label", "data-readonly", "data-disabled", "data-invalid", "dir"]);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarCell.js
var _sfc_main39 = defineComponent43({
  __name: "CalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: { default: "td" }
  },
  setup(__props) {
    const rootContext = injectCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock37(), createBlock36(unref41(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        role: "gridcell",
        "aria-selected": unref41(rootContext).isDateSelected(_ctx.date) ? true : void 0,
        "aria-disabled": unref41(rootContext).isDateDisabled(_ctx.date) || unref41(rootContext).isDateUnavailable?.(_ctx.date),
        "data-disabled": unref41(rootContext).isDateDisabled(_ctx.date) ? "" : void 0
      }, {
        default: withCtx36(() => [
          renderSlot39(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "aria-selected", "aria-disabled", "data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarCellTrigger.js
import { defineComponent as defineComponent44, computed as computed18, createBlock as createBlock37, openBlock as openBlock38, unref as unref42, mergeProps as mergeProps16, withKeys as withKeys2, withModifiers as withModifiers2, withCtx as withCtx37, renderSlot as renderSlot40, createTextVNode, toDisplayString as toDisplayString2, nextTick as nextTick10 } from "vue";

// node_modules/reka-ui/dist/Calendar/utils.js
var SELECTOR = "[data-reka-calendar-cell-trigger]:not([data-outside-view]):not([data-outside-visible-view])";
function getSelectableCells(calendar) {
  return Array.from(calendar.querySelectorAll(SELECTOR)) ?? [];
}

// node_modules/reka-ui/dist/shared/useKbd.js
function useKbd() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}

// node_modules/reka-ui/dist/Calendar/CalendarCellTrigger.js
var _sfc_main40 = defineComponent44({
  __name: "CalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    const kbd = useKbd();
    const rootContext = injectCalendarRootContext();
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const dayValue = computed18(() => props2.day.day.toLocaleString(rootContext.locale.value));
    const labelText = computed18(() => {
      return rootContext.formatter.custom(toDate(props2.day), {
        weekday: "long",
        month: "long",
        day: "numeric",
        year: "numeric"
      });
    });
    const isDisabled = computed18(() => rootContext.isDateDisabled(props2.day));
    const isUnavailable = computed18(
      () => rootContext.isDateUnavailable?.(props2.day) ?? false
    );
    const isDateToday = computed18(() => {
      return $14e0f24ef4ac5c92$export$629b0a497aa65267(props2.day, $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
    });
    const isOutsideView = computed18(() => {
      return !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(props2.day, props2.month);
    });
    const isOutsideVisibleView = computed18(
      () => rootContext.isOutsideVisibleView(props2.day)
    );
    const isFocusedDate = computed18(() => {
      return !rootContext.disabled.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.day, rootContext.placeholder.value);
    });
    const isSelectedDate = computed18(() => rootContext.isDateSelected(props2.day));
    function changeDate(date) {
      if (rootContext.readonly.value)
        return;
      if (rootContext.isDateDisabled(date) || rootContext.isDateUnavailable?.(date))
        return;
      rootContext.onDateChange(date);
    }
    function handleClick() {
      changeDate(props2.day);
    }
    function handleArrowKey(e) {
      e.preventDefault();
      e.stopPropagation();
      const parentElement = rootContext.parentElement.value;
      const indexIncrementation = 7;
      const sign = rootContext.dir.value === "rtl" ? -1 : 1;
      switch (e.code) {
        case kbd.ARROW_RIGHT:
          shiftFocus(currentElement.value, sign);
          break;
        case kbd.ARROW_LEFT:
          shiftFocus(currentElement.value, -sign);
          break;
        case kbd.ARROW_UP:
          shiftFocus(currentElement.value, -7);
          break;
        case kbd.ARROW_DOWN:
          shiftFocus(currentElement.value, indexIncrementation);
          break;
        case kbd.ENTER:
        case kbd.SPACE_CODE:
          changeDate(props2.day);
      }
      function shiftFocus(node, add) {
        const allCollectionItems = getSelectableCells(parentElement);
        if (!allCollectionItems.length)
          return;
        const index = allCollectionItems.indexOf(node);
        const newIndex = index + add;
        if (newIndex >= 0 && newIndex < allCollectionItems.length) {
          if (allCollectionItems[newIndex].hasAttribute("data-disabled")) {
            shiftFocus(allCollectionItems[newIndex], add);
          }
          allCollectionItems[newIndex].focus();
          return;
        }
        if (newIndex < 0) {
          if (rootContext.isPrevButtonDisabled())
            return;
          rootContext.prevPage();
          nextTick10(() => {
            const newCollectionItems = getSelectableCells(parentElement);
            if (!newCollectionItems.length)
              return;
            if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {
              const numberOfDays = getDaysInMonth(rootContext.placeholder.value);
              const computedIndex2 = numberOfDays - Math.abs(newIndex);
              if (newCollectionItems[computedIndex2].hasAttribute("data-disabled")) {
                shiftFocus(newCollectionItems[computedIndex2], add);
              }
              newCollectionItems[computedIndex2].focus();
              return;
            }
            const computedIndex = newCollectionItems.length - Math.abs(newIndex);
            if (newCollectionItems[computedIndex].hasAttribute("data-disabled")) {
              shiftFocus(newCollectionItems[computedIndex], add);
            }
            newCollectionItems[computedIndex].focus();
          });
          return;
        }
        if (newIndex >= allCollectionItems.length) {
          if (rootContext.isNextButtonDisabled())
            return;
          rootContext.nextPage();
          nextTick10(() => {
            const newCollectionItems = getSelectableCells(parentElement);
            if (!newCollectionItems.length)
              return;
            if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {
              const numberOfDays = getDaysInMonth(
                rootContext.placeholder.value.add({ months: rootContext.numberOfMonths.value - 1 })
              );
              const computedIndex2 = newIndex - allCollectionItems.length + (newCollectionItems.length - numberOfDays);
              if (newCollectionItems[computedIndex2].hasAttribute("data-disabled")) {
                shiftFocus(newCollectionItems[computedIndex2], add);
              }
              newCollectionItems[computedIndex2].focus();
              return;
            }
            const computedIndex = newIndex - allCollectionItems.length;
            if (newCollectionItems[computedIndex].hasAttribute("data-disabled")) {
              shiftFocus(newCollectionItems[computedIndex], add);
            }
            newCollectionItems[computedIndex].focus();
          });
        }
      }
    }
    return (_ctx, _cache) => {
      return openBlock38(), createBlock37(unref42(Primitive), mergeProps16({
        ref_key: "primitiveElement",
        ref: primitiveElement
      }, props2, {
        role: "button",
        "aria-label": labelText.value,
        "data-reka-calendar-cell-trigger": "",
        "aria-disabled": isDisabled.value || isUnavailable.value ? true : void 0,
        "data-selected": isSelectedDate.value ? true : void 0,
        "data-value": _ctx.day.toString(),
        "data-disabled": isDisabled.value ? "" : void 0,
        "data-unavailable": isUnavailable.value ? "" : void 0,
        "data-today": isDateToday.value ? "" : void 0,
        "data-outside-view": isOutsideView.value ? "" : void 0,
        "data-outside-visible-view": isOutsideVisibleView.value ? "" : void 0,
        "data-focused": isFocusedDate.value ? "" : void 0,
        tabindex: isFocusedDate.value ? 0 : isOutsideView.value || isDisabled.value ? void 0 : -1,
        onClick: handleClick,
        onKeydown: [
          withKeys2(handleArrowKey, ["up", "down", "left", "right", "space", "enter"]),
          _cache[0] || (_cache[0] = withKeys2(withModifiers2(() => {
          }, ["prevent"]), ["enter"]))
        ]
      }), {
        default: withCtx37(() => [
          renderSlot40(_ctx.$slots, "default", {
            dayValue: dayValue.value,
            disabled: isDisabled.value,
            today: isDateToday.value,
            selected: isSelectedDate.value,
            outsideView: isOutsideView.value,
            outsideVisibleView: isOutsideVisibleView.value,
            unavailable: isUnavailable.value
          }, () => [
            createTextVNode(toDisplayString2(dayValue.value), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-label", "aria-disabled", "data-selected", "data-value", "data-disabled", "data-unavailable", "data-today", "data-outside-view", "data-outside-visible-view", "data-focused", "tabindex"]);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarGrid.js
import { defineComponent as defineComponent45, computed as computed19, createBlock as createBlock38, openBlock as openBlock39, unref as unref43, mergeProps as mergeProps17, withCtx as withCtx38, renderSlot as renderSlot41 } from "vue";
var _sfc_main41 = defineComponent45({
  __name: "CalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: { default: "table" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectCalendarRootContext();
    const disabled = computed19(() => rootContext.disabled.value ? true : void 0);
    const readonly3 = computed19(() => rootContext.readonly.value ? true : void 0);
    return (_ctx, _cache) => {
      return openBlock39(), createBlock38(unref43(Primitive), mergeProps17(props2, {
        tabindex: "-1",
        role: "grid",
        "aria-readonly": readonly3.value,
        "aria-disabled": disabled.value,
        "data-readonly": readonly3.value && "",
        "data-disabled": disabled.value && ""
      }), {
        default: withCtx38(() => [
          renderSlot41(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-readonly", "aria-disabled", "data-readonly", "data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarGridBody.js
import { defineComponent as defineComponent46, createBlock as createBlock39, openBlock as openBlock40, unref as unref44, normalizeProps as normalizeProps8, guardReactiveProps as guardReactiveProps8, withCtx as withCtx39, renderSlot as renderSlot42 } from "vue";
var _sfc_main42 = defineComponent46({
  __name: "CalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: { default: "tbody" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock40(), createBlock39(unref44(Primitive), normalizeProps8(guardReactiveProps8(props2)), {
        default: withCtx39(() => [
          renderSlot42(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarGridHead.js
import { defineComponent as defineComponent47, createBlock as createBlock40, openBlock as openBlock41, unref as unref45, mergeProps as mergeProps18, withCtx as withCtx40, renderSlot as renderSlot43 } from "vue";
var _sfc_main43 = defineComponent47({
  __name: "CalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: { default: "thead" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock41(), createBlock40(unref45(Primitive), mergeProps18(props2, { "aria-hidden": "true" }), {
        default: withCtx40(() => [
          renderSlot43(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarGridRow.js
import { defineComponent as defineComponent48, createBlock as createBlock41, openBlock as openBlock42, unref as unref46, normalizeProps as normalizeProps9, guardReactiveProps as guardReactiveProps9, withCtx as withCtx41, renderSlot as renderSlot44 } from "vue";
var _sfc_main44 = defineComponent48({
  __name: "CalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: { default: "tr" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock42(), createBlock41(unref46(Primitive), normalizeProps9(guardReactiveProps9(props2)), {
        default: withCtx41(() => [
          renderSlot44(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarHeadCell.js
import { defineComponent as defineComponent49, createBlock as createBlock42, openBlock as openBlock43, unref as unref47, normalizeProps as normalizeProps10, guardReactiveProps as guardReactiveProps10, withCtx as withCtx42, renderSlot as renderSlot45 } from "vue";
var _sfc_main45 = defineComponent49({
  __name: "CalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: { default: "th" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock43(), createBlock42(unref47(Primitive), normalizeProps10(guardReactiveProps10(props2)), {
        default: withCtx42(() => [
          renderSlot45(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarHeader.js
import { defineComponent as defineComponent50, createBlock as createBlock43, openBlock as openBlock44, unref as unref48, normalizeProps as normalizeProps11, guardReactiveProps as guardReactiveProps11, withCtx as withCtx43, renderSlot as renderSlot46 } from "vue";
var _sfc_main46 = defineComponent50({
  __name: "CalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock44(), createBlock43(unref48(Primitive), normalizeProps11(guardReactiveProps11(props2)), {
        default: withCtx43(() => [
          renderSlot46(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarHeading.js
import { defineComponent as defineComponent51, createBlock as createBlock44, openBlock as openBlock45, unref as unref49, mergeProps as mergeProps19, withCtx as withCtx44, renderSlot as renderSlot47, createTextVNode as createTextVNode2, toDisplayString as toDisplayString3 } from "vue";
var _sfc_main47 = defineComponent51({
  __name: "CalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock45(), createBlock44(unref49(Primitive), mergeProps19(props2, {
        "data-disabled": unref49(rootContext).disabled.value ? "" : void 0
      }), {
        default: withCtx44(() => [
          renderSlot47(_ctx.$slots, "default", {
            headingValue: unref49(rootContext).headingValue.value
          }, () => [
            createTextVNode2(toDisplayString3(unref49(rootContext).headingValue.value), 1)
          ])
        ]),
        _: 3
      }, 16, ["data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarNext.js
import { defineComponent as defineComponent52, computed as computed20, createBlock as createBlock45, openBlock as openBlock46, unref as unref50, withCtx as withCtx45, renderSlot as renderSlot48, createTextVNode as createTextVNode3 } from "vue";
var _sfc_main48 = defineComponent52({
  __name: "CalendarNext",
  props: {
    nextPage: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const disabled = computed20(() => rootContext.disabled.value || rootContext.isNextButtonDisabled(props2.nextPage));
    const rootContext = injectCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock46(), createBlock45(unref50(Primitive), {
        as: props2.as,
        "as-child": props2.asChild,
        "aria-label": "Next page",
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-disabled": disabled.value || void 0,
        "data-disabled": disabled.value || void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => unref50(rootContext).nextPage(props2.nextPage))
      }, {
        default: withCtx45(() => [
          renderSlot48(_ctx.$slots, "default", { disabled: disabled.value }, () => [
            _cache[1] || (_cache[1] = createTextVNode3(" Next page "))
          ])
        ]),
        _: 3
      }, 8, ["as", "as-child", "type", "aria-disabled", "data-disabled", "disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Calendar/CalendarPrev.js
import { defineComponent as defineComponent53, computed as computed21, createBlock as createBlock46, openBlock as openBlock47, unref as unref51, withCtx as withCtx46, renderSlot as renderSlot49, createTextVNode as createTextVNode4 } from "vue";
var _sfc_main49 = defineComponent53({
  __name: "CalendarPrev",
  props: {
    prevPage: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const disabled = computed21(() => rootContext.disabled.value || rootContext.isPrevButtonDisabled(props2.prevPage));
    const rootContext = injectCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock47(), createBlock46(unref51(Primitive), {
        "aria-label": "Previous page",
        as: props2.as,
        "as-child": props2.asChild,
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-disabled": disabled.value || void 0,
        "data-disabled": disabled.value || void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => unref51(rootContext).prevPage(props2.prevPage))
      }, {
        default: withCtx46(() => [
          renderSlot49(_ctx.$slots, "default", { disabled: disabled.value }, () => [
            _cache[1] || (_cache[1] = createTextVNode4(" Prev page "))
          ])
        ]),
        _: 3
      }, 8, ["as", "as-child", "type", "aria-disabled", "data-disabled", "disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Checkbox/CheckboxGroupRoot.js
import { defineComponent as defineComponent58, toRefs as toRefs10, computed as computed26, createBlock as createBlock50, openBlock as openBlock51, resolveDynamicComponent, unref as unref53, mergeProps as mergeProps22, withCtx as withCtx48, renderSlot as renderSlot51, createCommentVNode as createCommentVNode5 } from "vue";

// node_modules/reka-ui/dist/shared/useFormControl.js
import { computed as computed22 } from "vue";
function useFormControl(el) {
  return computed22(() => toValue2(el) ? Boolean(unrefElement(el)?.closest("form")) : true);
}

// node_modules/reka-ui/dist/RovingFocus/RovingFocusGroup.js
import { defineComponent as defineComponent55, toRefs as toRefs9, ref as ref25, createBlock as createBlock47, openBlock as openBlock48, unref as unref52, withCtx as withCtx47, createVNode as createVNode5, renderSlot as renderSlot50 } from "vue";

// node_modules/reka-ui/dist/Collection/Collection.js
import { ref as ref24, provide as provide3, inject as inject4, defineComponent as defineComponent54, watch as watch13, h as h4, watchEffect as watchEffect6, markRaw as markRaw2, computed as computed23 } from "vue";
var ITEM_DATA_ATTR = "data-reka-collection-item";
function useCollection(options = {}) {
  const { key = "", isProvider = false } = options;
  const injectionKey = `${key}CollectionProvider`;
  let context2;
  if (isProvider) {
    const itemMap = ref24(/* @__PURE__ */ new Map());
    const collectionRef = ref24();
    context2 = {
      collectionRef,
      itemMap
    };
    provide3(injectionKey, context2);
  } else {
    context2 = inject4(injectionKey);
  }
  const getItems = (includeDisabledItem = false) => {
    const collectionNode = context2.collectionRef.value;
    if (!collectionNode)
      return [];
    const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
    const items = Array.from(context2.itemMap.value.values());
    const orderedItems = items.sort(
      (a, b) => orderedNodes.indexOf(a.ref) - orderedNodes.indexOf(b.ref)
    );
    if (includeDisabledItem)
      return orderedItems;
    else
      return orderedItems.filter((i) => i.ref.dataset.disabled !== "");
  };
  const CollectionSlot = defineComponent54({
    name: "CollectionSlot",
    setup(_, { slots }) {
      const { primitiveElement, currentElement } = usePrimitiveElement();
      watch13(currentElement, () => {
        context2.collectionRef.value = currentElement.value;
      });
      return () => h4(Slot, { ref: primitiveElement }, slots);
    }
  });
  const CollectionItem = defineComponent54({
    name: "CollectionItem",
    inheritAttrs: false,
    props: {
      value: {
        // It accepts any value
        validator: () => true
      }
    },
    setup(props2, { slots, attrs }) {
      const { primitiveElement, currentElement } = usePrimitiveElement();
      watchEffect6((cleanupFn) => {
        if (currentElement.value) {
          const key2 = markRaw2(currentElement.value);
          context2.itemMap.value.set(key2, { ref: currentElement.value, value: props2.value });
          cleanupFn(() => context2.itemMap.value.delete(key2));
        }
      });
      return () => h4(Slot, { ...attrs, [ITEM_DATA_ATTR]: "", ref: primitiveElement }, slots);
    }
  });
  const reactiveItems = computed23(() => Array.from(context2.itemMap.value.values()));
  const itemMapSize = computed23(() => context2.itemMap.value.size);
  return { getItems, reactiveItems, itemMapSize, CollectionSlot, CollectionItem };
}

// node_modules/reka-ui/dist/RovingFocus/utils.js
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst3(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement();
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus({ preventScroll });
    if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}

// node_modules/reka-ui/dist/RovingFocus/RovingFocusGroup.js
var [injectRovingFocusGroupContext, provideRovingFocusGroupContext] = createContext("RovingFocusGroup");
var _sfc_main50 = defineComponent55({
  __name: "RovingFocusGroup",
  props: {
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: false },
    currentTabStopId: {},
    defaultCurrentTabStopId: {},
    preventScrollOnEntryFocus: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { loop, orientation, dir: propDir } = toRefs9(props2);
    const dir = useDirection(propDir);
    const currentTabStopId = useVModel(props2, "currentTabStopId", emits, {
      defaultValue: props2.defaultCurrentTabStopId,
      passive: props2.currentTabStopId === void 0
    });
    const isTabbingBackOut = ref25(false);
    const isClickFocus = ref25(false);
    const focusableItemsCount = ref25(0);
    const { getItems, CollectionSlot } = useCollection({ isProvider: true });
    function handleFocus(event) {
      const isKeyboardFocus = !isClickFocus.value;
      if (event.currentTarget && event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut.value) {
        const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        emits("entryFocus", entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().map((i) => i.ref).filter((i) => i.dataset.disabled !== "");
          const activeItem = items.find((item) => item.getAttribute("data-active") === "");
          const currentItem = items.find(
            (item) => item.id === currentTabStopId.value
          );
          const candidateItems = [activeItem, currentItem, ...items].filter(
            Boolean
          );
          focusFirst3(candidateItems, props2.preventScrollOnEntryFocus);
        }
      }
      isClickFocus.value = false;
    }
    function handleMouseUp() {
      setTimeout(() => {
        isClickFocus.value = false;
      }, 1);
    }
    __expose({
      getItems
    });
    provideRovingFocusGroupContext({
      loop,
      dir,
      orientation,
      currentTabStopId,
      onItemFocus: (tabStopId) => {
        currentTabStopId.value = tabStopId;
      },
      onItemShiftTab: () => {
        isTabbingBackOut.value = true;
      },
      onFocusableItemAdd: () => {
        focusableItemsCount.value++;
      },
      onFocusableItemRemove: () => {
        focusableItemsCount.value--;
      }
    });
    return (_ctx, _cache) => {
      return openBlock48(), createBlock47(unref52(CollectionSlot), null, {
        default: withCtx47(() => [
          createVNode5(unref52(Primitive), {
            tabindex: isTabbingBackOut.value || focusableItemsCount.value === 0 ? -1 : 0,
            "data-orientation": unref52(orientation),
            as: _ctx.as,
            "as-child": _ctx.asChild,
            dir: unref52(dir),
            style: { "outline": "none" },
            onMousedown: _cache[0] || (_cache[0] = ($event) => isClickFocus.value = true),
            onMouseup: handleMouseUp,
            onFocus: handleFocus,
            onBlur: _cache[1] || (_cache[1] = ($event) => isTabbingBackOut.value = false)
          }, {
            default: withCtx47(() => [
              renderSlot50(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["tabindex", "data-orientation", "as", "as-child", "dir"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/VisuallyHidden/VisuallyHiddenInput.js
import { defineComponent as defineComponent57, computed as computed25, createBlock as createBlock49, createElementBlock as createElementBlock2, openBlock as openBlock50, mergeProps as mergeProps21, Fragment as Fragment3, renderList } from "vue";

// node_modules/reka-ui/dist/VisuallyHidden/VisuallyHiddenInputBubble.js
import { defineComponent as defineComponent56, computed as computed24, watch as watch14, createBlock as createBlock48, openBlock as openBlock49, mergeProps as mergeProps20 } from "vue";
var _sfc_main51 = defineComponent56({
  ...{
    inheritAttrs: false
  },
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {},
    value: {},
    checked: { type: Boolean, default: void 0 },
    required: { type: Boolean },
    disabled: { type: Boolean },
    feature: { default: "fully-hidden" }
  },
  setup(__props) {
    const props2 = __props;
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const valueState = computed24(() => props2.checked ?? props2.value);
    watch14(valueState, (cur, prev) => {
      if (!currentElement.value)
        return;
      const input = currentElement.value;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
      const setValue = descriptor.set;
      if (setValue && cur !== prev) {
        const inputEvent = new Event("input", { bubbles: true });
        const changeEvent = new Event("change", { bubbles: true });
        setValue.call(input, cur);
        input.dispatchEvent(inputEvent);
        input.dispatchEvent(changeEvent);
      }
    });
    return (_ctx, _cache) => {
      return openBlock49(), createBlock48(_sfc_main, mergeProps20({
        ref_key: "primitiveElement",
        ref: primitiveElement
      }, { ...props2, ..._ctx.$attrs }, { as: "input" }), null, 16);
    };
  }
});

// node_modules/reka-ui/dist/VisuallyHidden/VisuallyHiddenInput.js
var _sfc_main52 = defineComponent57({
  ...{
    inheritAttrs: false
  },
  __name: "VisuallyHiddenInput",
  props: {
    name: {},
    value: {},
    checked: { type: Boolean, default: void 0 },
    required: { type: Boolean },
    disabled: { type: Boolean },
    feature: { default: "fully-hidden" }
  },
  setup(__props) {
    const props2 = __props;
    const isFormArrayEmptyAndRequired = computed25(
      () => typeof props2.value === "object" && Array.isArray(props2.value) && props2.value.length === 0 && props2.required
    );
    const parsedValue = computed25(() => {
      if (typeof props2.value === "string" || typeof props2.value === "number" || typeof props2.value === "boolean") {
        return [{ name: props2.name, value: props2.value }];
      } else if (typeof props2.value === "object" && Array.isArray(props2.value)) {
        return props2.value.flatMap((obj, index) => {
          if (typeof obj === "object")
            return Object.entries(obj).map(([key, value]) => ({ name: `[${props2.name}][${index}][${key}]`, value }));
          else
            return { name: `[${props2.name}][${index}]`, value: obj };
        });
      } else if (props2.value !== null && typeof props2.value === "object" && !Array.isArray(props2.value)) {
        return Object.entries(props2.value).map(([key, value]) => ({ name: `[${props2.name}][${key}]`, value }));
      }
      return [];
    });
    return (_ctx, _cache) => {
      return isFormArrayEmptyAndRequired.value ? (openBlock50(), createBlock49(_sfc_main51, mergeProps21({ key: _ctx.name }, { ...props2, ..._ctx.$attrs }, {
        name: _ctx.name,
        value: _ctx.value
      }), null, 16, ["name", "value"])) : (openBlock50(true), createElementBlock2(Fragment3, { key: 1 }, renderList(parsedValue.value, (parsed) => {
        return openBlock50(), createBlock49(_sfc_main51, mergeProps21({
          key: parsed.name,
          ref_for: true
        }, { ...props2, ..._ctx.$attrs }, {
          name: parsed.name,
          value: parsed.value
        }), null, 16, ["name", "value"]);
      }), 128));
    };
  }
});

// node_modules/reka-ui/dist/Checkbox/CheckboxGroupRoot.js
var [injectCheckboxGroupRootContext, provideCheckboxGroupRootContext] = createContext("CheckboxGroupRoot");
var _sfc_main53 = defineComponent58({
  __name: "CheckboxGroupRoot",
  props: {
    defaultValue: {},
    modelValue: {},
    rovingFocus: { type: Boolean, default: true },
    disabled: { type: Boolean },
    as: {},
    asChild: { type: Boolean },
    dir: {},
    orientation: {},
    loop: { type: Boolean },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, rovingFocus, dir: propDir } = toRefs10(props2);
    const dir = useDirection(propDir);
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const isFormControl = useFormControl(currentElement);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? [],
      passive: props2.modelValue === void 0
    });
    const rovingFocusProps = computed26(() => {
      return rovingFocus.value ? { loop: props2.loop, dir: dir.value, orientation: props2.orientation } : {};
    });
    provideCheckboxGroupRootContext({
      modelValue,
      rovingFocus,
      disabled
    });
    return (_ctx, _cache) => {
      return openBlock51(), createBlock50(resolveDynamicComponent(unref53(rovingFocus) ? unref53(_sfc_main50) : unref53(Primitive)), mergeProps22({
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, rovingFocusProps.value), {
        default: withCtx48(() => [
          renderSlot51(_ctx.$slots, "default"),
          unref53(isFormControl) && _ctx.name ? (openBlock51(), createBlock50(unref53(_sfc_main52), {
            key: 0,
            name: _ctx.name,
            value: unref53(modelValue),
            required: _ctx.required
          }, null, 8, ["name", "value", "required"])) : createCommentVNode5("", true)
        ]),
        _: 3
      }, 16, ["as", "as-child"]);
    };
  }
});

// node_modules/reka-ui/dist/Checkbox/CheckboxIndicator.js
import { defineComponent as defineComponent61, createBlock as createBlock53, openBlock as openBlock54, unref as unref56, withCtx as withCtx51, createVNode as createVNode7, mergeProps as mergeProps24, renderSlot as renderSlot54 } from "vue";

// node_modules/reka-ui/dist/Checkbox/utils.js
function isIndeterminate2(checked) {
  return checked === "indeterminate";
}
function getState(checked) {
  return isIndeterminate2(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}

// node_modules/reka-ui/dist/Checkbox/CheckboxRoot.js
import { defineComponent as defineComponent60, computed as computed28, createBlock as createBlock52, openBlock as openBlock53, resolveDynamicComponent as resolveDynamicComponent2, unref as unref55, mergeProps as mergeProps23, withKeys as withKeys3, withModifiers as withModifiers3, withCtx as withCtx50, renderSlot as renderSlot53, createCommentVNode as createCommentVNode6 } from "vue";

// node_modules/reka-ui/dist/RovingFocus/RovingFocusItem.js
import { defineComponent as defineComponent59, computed as computed27, onMounted as onMounted10, onUnmounted as onUnmounted5, createBlock as createBlock51, openBlock as openBlock52, unref as unref54, withCtx as withCtx49, createVNode as createVNode6, renderSlot as renderSlot52, nextTick as nextTick11 } from "vue";
var _sfc_main54 = defineComponent59({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {},
    focusable: { type: Boolean, default: true },
    active: { type: Boolean },
    allowShiftKey: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectRovingFocusGroupContext();
    const randomId = useId2();
    const id = computed27(() => props2.tabStopId || randomId);
    const isCurrentTabStop = computed27(
      () => context2.currentTabStopId.value === id.value
    );
    const { getItems, CollectionItem } = useCollection();
    onMounted10(() => {
      if (props2.focusable)
        context2.onFocusableItemAdd();
    });
    onUnmounted5(() => {
      if (props2.focusable)
        context2.onFocusableItemRemove();
    });
    function handleKeydown(event) {
      if (event.key === "Tab" && event.shiftKey) {
        context2.onItemShiftTab();
        return;
      }
      if (event.target !== event.currentTarget)
        return;
      const focusIntent = getFocusIntent(
        event,
        context2.orientation.value,
        context2.dir.value
      );
      if (focusIntent !== void 0) {
        if (event.metaKey || event.ctrlKey || event.altKey || (props2.allowShiftKey ? false : event.shiftKey))
          return;
        event.preventDefault();
        let candidateNodes = [...getItems().map((i) => i.ref).filter((i) => i.dataset.disabled !== "")];
        if (focusIntent === "last") {
          candidateNodes.reverse();
        } else if (focusIntent === "prev" || focusIntent === "next") {
          if (focusIntent === "prev")
            candidateNodes.reverse();
          const currentIndex = candidateNodes.indexOf(
            event.currentTarget
          );
          candidateNodes = context2.loop.value ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
        }
        nextTick11(() => focusFirst3(candidateNodes));
      }
    }
    return (_ctx, _cache) => {
      return openBlock52(), createBlock51(unref54(CollectionItem), null, {
        default: withCtx49(() => [
          createVNode6(unref54(Primitive), {
            tabindex: isCurrentTabStop.value ? 0 : -1,
            "data-orientation": unref54(context2).orientation.value,
            "data-active": _ctx.active ? "" : void 0,
            "data-disabled": !_ctx.focusable ? "" : void 0,
            as: _ctx.as,
            "as-child": _ctx.asChild,
            onMousedown: _cache[0] || (_cache[0] = (event) => {
              if (!_ctx.focusable) event.preventDefault();
              else unref54(context2).onItemFocus(id.value);
            }),
            onFocus: _cache[1] || (_cache[1] = ($event) => unref54(context2).onItemFocus(id.value)),
            onKeydown: handleKeydown
          }, {
            default: withCtx49(() => [
              renderSlot52(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["tabindex", "data-orientation", "data-active", "data-disabled", "as", "as-child"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Checkbox/CheckboxRoot.js
var [injectCheckboxRootContext, provideCheckboxRootContext] = createContext("CheckboxRoot");
var _sfc_main55 = defineComponent60({
  ...{
    inheritAttrs: false
  },
  __name: "CheckboxRoot",
  props: {
    defaultValue: { type: [Boolean, String] },
    modelValue: { type: [Boolean, String, null], default: void 0 },
    disabled: { type: Boolean },
    value: { default: "on" },
    id: {},
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const checkboxGroupContext = injectCheckboxGroupRootContext(null);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const disabled = computed28(() => checkboxGroupContext?.disabled.value || props2.disabled);
    const checkboxState = computed28(() => {
      if (!isNullish(checkboxGroupContext?.modelValue.value)) {
        return isValueEqualOrExist(checkboxGroupContext.modelValue.value, props2.value);
      } else {
        return modelValue.value === "indeterminate" ? "indeterminate" : modelValue.value;
      }
    });
    function handleClick() {
      if (!isNullish(checkboxGroupContext?.modelValue.value)) {
        const modelValueArray = [...checkboxGroupContext.modelValue.value || []];
        if (isValueEqualOrExist(modelValueArray, props2.value)) {
          const index = modelValueArray.findIndex((i) => isEqual(i, props2.value));
          modelValueArray.splice(index, 1);
        } else {
          modelValueArray.push(props2.value);
        }
        checkboxGroupContext.modelValue.value = modelValueArray;
      } else {
        modelValue.value = isIndeterminate2(modelValue.value) ? true : !modelValue.value;
      }
    }
    const isFormControl = useFormControl(currentElement);
    const ariaLabel = computed28(() => props2.id && currentElement.value ? document.querySelector(`[for="${props2.id}"]`)?.innerText : void 0);
    provideCheckboxRootContext({
      disabled,
      state: checkboxState
    });
    return (_ctx, _cache) => {
      return openBlock53(), createBlock52(resolveDynamicComponent2(unref55(checkboxGroupContext)?.rovingFocus.value ? unref55(_sfc_main54) : unref55(Primitive)), mergeProps23(_ctx.$attrs, {
        id: _ctx.id,
        ref: unref55(forwardRef),
        role: "checkbox",
        "as-child": _ctx.asChild,
        as: _ctx.as,
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-checked": unref55(isIndeterminate2)(checkboxState.value) ? "mixed" : checkboxState.value,
        "aria-required": _ctx.required,
        "aria-label": _ctx.$attrs["aria-label"] || ariaLabel.value,
        "data-state": unref55(getState)(checkboxState.value),
        "data-disabled": disabled.value ? "" : void 0,
        disabled: disabled.value,
        focusable: unref55(checkboxGroupContext)?.rovingFocus.value ? !disabled.value : void 0,
        onKeydown: withKeys3(withModifiers3(() => {
        }, ["prevent"]), ["enter"]),
        onClick: handleClick
      }), {
        default: withCtx50(() => [
          renderSlot53(_ctx.$slots, "default", {
            modelValue: unref55(modelValue),
            state: checkboxState.value
          }),
          unref55(isFormControl) && _ctx.name && !unref55(checkboxGroupContext) ? (openBlock53(), createBlock52(unref55(_sfc_main52), {
            key: 0,
            type: "checkbox",
            checked: !!checkboxState.value,
            name: _ctx.name,
            value: _ctx.value,
            disabled: disabled.value,
            required: _ctx.required
          }, null, 8, ["checked", "name", "value", "disabled", "required"])) : createCommentVNode6("", true)
        ]),
        _: 3
      }, 16, ["id", "as-child", "as", "type", "aria-checked", "aria-required", "aria-label", "data-state", "data-disabled", "disabled", "focusable", "onKeydown"]);
    };
  }
});

// node_modules/reka-ui/dist/Checkbox/CheckboxIndicator.js
var _sfc_main56 = defineComponent61({
  __name: "CheckboxIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const { forwardRef } = useForwardExpose();
    const rootContext = injectCheckboxRootContext();
    return (_ctx, _cache) => {
      return openBlock54(), createBlock53(unref56(Presence), {
        present: _ctx.forceMount || unref56(isIndeterminate2)(unref56(rootContext).state.value) || unref56(rootContext).state.value === true
      }, {
        default: withCtx51(() => [
          createVNode7(unref56(Primitive), mergeProps24({
            ref: unref56(forwardRef),
            "data-state": unref56(getState)(unref56(rootContext).state.value),
            "data-disabled": unref56(rootContext).disabled.value ? "" : void 0,
            style: { pointerEvents: "none" },
            "as-child": _ctx.asChild,
            as: _ctx.as
          }, _ctx.$attrs), {
            default: withCtx51(() => [
              renderSlot54(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["data-state", "data-disabled", "as-child", "as"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxAnchor.js
import { defineComponent as defineComponent64, createBlock as createBlock55, openBlock as openBlock56, unref as unref58, withCtx as withCtx53, createVNode as createVNode8, mergeProps as mergeProps25, renderSlot as renderSlot57 } from "vue";

// node_modules/reka-ui/dist/Popper/PopperAnchor.js
import { defineComponent as defineComponent63, watchPostEffect, createBlock as createBlock54, openBlock as openBlock55, unref as unref57, withCtx as withCtx52, renderSlot as renderSlot56 } from "vue";

// node_modules/reka-ui/dist/Popper/PopperRoot.js
import { defineComponent as defineComponent62, ref as ref26, renderSlot as renderSlot55 } from "vue";
var [injectPopperRootContext, providePopperRootContext] = createContext("PopperRoot");
var _sfc_main57 = defineComponent62({
  ...{
    inheritAttrs: false
  },
  __name: "PopperRoot",
  setup(__props) {
    const anchor = ref26();
    providePopperRootContext({
      anchor,
      onAnchorChange: (element) => anchor.value = element
    });
    return (_ctx, _cache) => {
      return renderSlot55(_ctx.$slots, "default");
    };
  }
});

// node_modules/reka-ui/dist/Popper/PopperAnchor.js
var _sfc_main58 = defineComponent63({
  __name: "PopperAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectPopperRootContext();
    watchPostEffect(() => {
      rootContext.onAnchorChange(props2.reference ?? currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock55(), createBlock54(unref57(Primitive), {
        ref: unref57(forwardRef),
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, {
        default: withCtx52(() => [
          renderSlot56(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxAnchor.js
var _sfc_main59 = defineComponent64({
  __name: "ComboboxAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock56(), createBlock55(unref58(_sfc_main58), {
        "as-child": "",
        reference: _ctx.reference
      }, {
        default: withCtx53(() => [
          createVNode8(unref58(Primitive), mergeProps25({
            ref: unref58(forwardRef),
            "as-child": _ctx.asChild,
            as: _ctx.as
          }, _ctx.$attrs), {
            default: withCtx53(() => [
              renderSlot57(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["as-child", "as"])
        ]),
        _: 3
      }, 8, ["reference"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxArrow.js
import { defineComponent as defineComponent72, createBlock as createBlock61, createCommentVNode as createCommentVNode8, unref as unref67, openBlock as openBlock64, normalizeProps as normalizeProps12, mergeProps as mergeProps31, withCtx as withCtx61, renderSlot as renderSlot65 } from "vue";

// node_modules/reka-ui/dist/Popper/PopperArrow.js
import { defineComponent as defineComponent67, computed as computed31, createElementBlock as createElementBlock5, openBlock as openBlock59, normalizeStyle as normalizeStyle4, unref as unref61, createVNode as createVNode10, mergeProps as mergeProps28, withCtx as withCtx56, renderSlot as renderSlot60 } from "vue";

// node_modules/reka-ui/dist/component/Arrow.js
import { defineComponent as defineComponent65, createBlock as createBlock56, openBlock as openBlock57, unref as unref59, mergeProps as mergeProps26, withCtx as withCtx54, renderSlot as renderSlot58, createElementBlock as createElementBlock3 } from "vue";
var _hoisted_12 = {
  key: 0,
  d: "M0 0L6 6L12 0"
};
var _hoisted_22 = {
  key: 1,
  d: "M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0"
};
var _sfc_main60 = defineComponent65({
  __name: "Arrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock57(), createBlock56(unref59(Primitive), mergeProps26(props2, {
        width: _ctx.width,
        height: _ctx.height,
        viewBox: _ctx.asChild ? void 0 : "0 0 12 6",
        preserveAspectRatio: _ctx.asChild ? void 0 : "none"
      }), {
        default: withCtx54(() => [
          renderSlot58(_ctx.$slots, "default", {}, () => [
            !_ctx.rounded ? (openBlock57(), createElementBlock3("path", _hoisted_12)) : (openBlock57(), createElementBlock3("path", _hoisted_22))
          ])
        ]),
        _: 3
      }, 16, ["width", "height", "viewBox", "preserveAspectRatio"]);
    };
  }
});

// node_modules/reka-ui/dist/Popper/PopperContent.js
import { defineComponent as defineComponent66, mergeDefaults, ref as ref28, computed as computed30, watchPostEffect as watchPostEffect2, watchEffect as watchEffect7, createElementBlock as createElementBlock4, openBlock as openBlock58, normalizeStyle as normalizeStyle3, unref as unref60, createVNode as createVNode9, mergeProps as mergeProps27, withCtx as withCtx55, renderSlot as renderSlot59 } from "vue";

// node_modules/reka-ui/dist/Popper/utils.js
function isNotNull(value) {
  return value !== null;
}
function transformOrigin(options) {
  return {
    name: "transformOrigin",
    options,
    fn(data) {
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
      const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
      const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
      let x = "";
      let y = "";
      if (placedSide === "bottom") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x = `${-arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x = `${rects.floating.width + arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x, y } };
    }
  };
}
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}

// node_modules/reka-ui/dist/shared/useSize.js
import { ref as ref27, computed as computed29, onMounted as onMounted11 } from "vue";
function useSize(element) {
  const size3 = ref27();
  const width = computed29(() => size3.value?.width ?? 0);
  const height = computed29(() => size3.value?.height ?? 0);
  onMounted11(() => {
    const el = unrefElement(element);
    if (el) {
      size3.value = { width: el.offsetWidth, height: el.offsetHeight };
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width2;
        let height2;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry.borderBoxSize;
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width2 = borderSize.inlineSize;
          height2 = borderSize.blockSize;
        } else {
          width2 = el.offsetWidth;
          height2 = el.offsetHeight;
        }
        size3.value = { width: width2, height: height2 };
      });
      resizeObserver.observe(el, { box: "border-box" });
      return () => resizeObserver.unobserve(el);
    } else {
      size3.value = void 0;
    }
  });
  return {
    width,
    height
  };
}

// node_modules/reka-ui/dist/Popper/PopperContent.js
var PopperContentPropsDefaultValue = {
  side: "bottom",
  sideOffset: 0,
  align: "center",
  alignOffset: 0,
  arrowPadding: 0,
  avoidCollisions: true,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: false,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: false
};
var [injectPopperContentContext, providePopperContentContext] = createContext("PopperContent");
var _sfc_main61 = defineComponent66({
  ...{
    inheritAttrs: false
  },
  __name: "PopperContent",
  props: mergeDefaults({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  }, {
    ...PopperContentPropsDefaultValue
  }),
  emits: ["placed"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectPopperRootContext();
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const floatingRef = ref28();
    const arrow$1 = ref28();
    const { width: arrowWidth, height: arrowHeight } = useSize(arrow$1);
    const desiredPlacement = computed30(
      () => props2.side + (props2.align !== "center" ? `-${props2.align}` : "")
    );
    const collisionPadding = computed30(() => {
      return typeof props2.collisionPadding === "number" ? props2.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...props2.collisionPadding };
    });
    const boundary = computed30(() => {
      return Array.isArray(props2.collisionBoundary) ? props2.collisionBoundary : [props2.collisionBoundary];
    });
    const detectOverflowOptions = computed30(() => {
      return {
        padding: collisionPadding.value,
        boundary: boundary.value.filter(isNotNull),
        // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
        altBoundary: boundary.value.length > 0
      };
    });
    const computedMiddleware = computedEager(() => {
      return [
        offset2({
          mainAxis: props2.sideOffset + arrowHeight.value,
          alignmentAxis: props2.alignOffset
        }),
        props2.prioritizePosition && props2.avoidCollisions && flip2({
          ...detectOverflowOptions.value
        }),
        props2.avoidCollisions && shift2({
          mainAxis: true,
          crossAxis: !!props2.prioritizePosition,
          limiter: props2.sticky === "partial" ? limitShift2() : void 0,
          ...detectOverflowOptions.value
        }),
        !props2.prioritizePosition && props2.avoidCollisions && flip2({
          ...detectOverflowOptions.value
        }),
        size2({
          ...detectOverflowOptions.value,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty(
              "--reka-popper-available-width",
              `${availableWidth}px`
            );
            contentStyle.setProperty(
              "--reka-popper-available-height",
              `${availableHeight}px`
            );
            contentStyle.setProperty(
              "--reka-popper-anchor-width",
              `${anchorWidth}px`
            );
            contentStyle.setProperty(
              "--reka-popper-anchor-height",
              `${anchorHeight}px`
            );
          }
        }),
        arrow$1.value && arrow3({ element: arrow$1.value, padding: props2.arrowPadding }),
        transformOrigin({
          arrowWidth: arrowWidth.value,
          arrowHeight: arrowHeight.value
        }),
        props2.hideWhenDetached && hide2({ strategy: "referenceHidden", ...detectOverflowOptions.value })
      ];
    });
    const reference = computed30(() => props2.reference ?? rootContext.anchor.value);
    const { floatingStyles, placement, isPositioned, middlewareData, update } = useFloating(
      reference,
      floatingRef,
      {
        strategy: props2.positionStrategy,
        placement: desiredPlacement,
        whileElementsMounted: (...args) => {
          const cleanup = autoUpdate(...args, {
            layoutShift: !props2.disableUpdateOnLayoutShift,
            animationFrame: props2.updatePositionStrategy === "always"
          });
          return cleanup;
        },
        middleware: computedMiddleware
      }
    );
    const placedSide = computed30(
      () => getSideAndAlignFromPlacement(placement.value)[0]
    );
    const placedAlign = computed30(
      () => getSideAndAlignFromPlacement(placement.value)[1]
    );
    watchPostEffect2(() => {
      if (isPositioned.value)
        emits("placed");
    });
    const cannotCenterArrow = computed30(
      () => middlewareData.value.arrow?.centerOffset !== 0
    );
    const contentZIndex = ref28("");
    watchEffect7(() => {
      if (contentElement.value)
        contentZIndex.value = window.getComputedStyle(contentElement.value).zIndex;
    });
    const arrowX = computed30(() => middlewareData.value.arrow?.x ?? 0);
    const arrowY = computed30(() => middlewareData.value.arrow?.y ?? 0);
    providePopperContentContext({
      placedSide,
      onArrowChange: (element) => arrow$1.value = element,
      arrowX,
      arrowY,
      shouldHideArrow: cannotCenterArrow
    });
    return (_ctx, _cache) => {
      return openBlock58(), createElementBlock4("div", {
        ref_key: "floatingRef",
        ref: floatingRef,
        "data-reka-popper-content-wrapper": "",
        style: normalizeStyle3({
          ...unref60(floatingStyles),
          transform: unref60(isPositioned) ? unref60(floatingStyles).transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex.value,
          ["--reka-popper-transform-origin"]: [
            unref60(middlewareData).transformOrigin?.x,
            unref60(middlewareData).transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...unref60(middlewareData).hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        })
      }, [
        createVNode9(unref60(Primitive), mergeProps27({ ref: unref60(forwardRef) }, _ctx.$attrs, {
          "as-child": props2.asChild,
          as: _ctx.as,
          "data-side": placedSide.value,
          "data-align": placedAlign.value,
          style: {
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: !unref60(isPositioned) ? "none" : void 0
          }
        }), {
          default: withCtx55(() => [
            renderSlot59(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-side", "data-align", "style"])
      ], 4);
    };
  }
});

// node_modules/reka-ui/dist/Popper/PopperArrow.js
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var _sfc_main62 = defineComponent67({
  ...{
    inheritAttrs: false
  },
  __name: "PopperArrow",
  props: {
    width: {},
    height: {},
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const { forwardRef } = useForwardExpose();
    const contentContext = injectPopperContentContext();
    const baseSide = computed31(() => OPPOSITE_SIDE[contentContext.placedSide.value]);
    return (_ctx, _cache) => {
      return openBlock59(), createElementBlock5("span", {
        ref: (el) => {
          unref61(contentContext).onArrowChange(el);
          return void 0;
        },
        style: normalizeStyle4({
          position: "absolute",
          left: unref61(contentContext).arrowX?.value ? `${unref61(contentContext).arrowX?.value}px` : void 0,
          top: unref61(contentContext).arrowY?.value ? `${unref61(contentContext).arrowY?.value}px` : void 0,
          [baseSide.value]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[unref61(contentContext).placedSide.value],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[unref61(contentContext).placedSide.value],
          visibility: unref61(contentContext).shouldHideArrow.value ? "hidden" : void 0
        })
      }, [
        createVNode10(_sfc_main60, mergeProps28(_ctx.$attrs, {
          ref: unref61(forwardRef),
          style: {
            display: "block"
          },
          as: _ctx.as,
          "as-child": _ctx.asChild,
          rounded: _ctx.rounded,
          width: _ctx.width,
          height: _ctx.height
        }), {
          default: withCtx56(() => [
            renderSlot60(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "rounded", "width", "height"])
      ], 4);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxContentImpl.js
import { defineComponent as defineComponent71, toRefs as toRefs13, computed as computed34, ref as ref31, onMounted as onMounted13, onUnmounted as onUnmounted6, createBlock as createBlock60, openBlock as openBlock63, unref as unref66, withCtx as withCtx60, createVNode as createVNode13, resolveDynamicComponent as resolveDynamicComponent3, mergeProps as mergeProps30, renderSlot as renderSlot64 } from "vue";

// node_modules/reka-ui/dist/Combobox/ComboboxRoot.js
import { defineComponent as defineComponent69, toRefs as toRefs12, ref as ref30, computed as computed33, reactive as reactive5, watch as watch16, nextTick as nextTick13, getCurrentInstance as getCurrentInstance7, onMounted as onMounted12, createBlock as createBlock58, openBlock as openBlock61, unref as unref64, withCtx as withCtx58, createVNode as createVNode11, mergeProps as mergeProps29, isRef as isRef3, renderSlot as renderSlot62 } from "vue";

// node_modules/reka-ui/dist/shared/useFilter.js
import { computed as computed32, unref as unref62 } from "vue";
function useFilter(options) {
  const computedOptions = computed32(() => unref62(options));
  const collator = computed32(() => new Intl.Collator("en", { usage: "search", ...computedOptions.value }));
  const startsWith = (string, substring) => {
    if (substring.length === 0)
      return true;
    string = string.normalize("NFC");
    substring = substring.normalize("NFC");
    return collator.value.compare(string.slice(0, substring.length), substring) === 0;
  };
  const endsWith = (string, substring) => {
    if (substring.length === 0)
      return true;
    string = string.normalize("NFC");
    substring = substring.normalize("NFC");
    return collator.value.compare(string.slice(-substring.length), substring) === 0;
  };
  const contains = (string, substring) => {
    if (substring.length === 0)
      return true;
    string = string.normalize("NFC");
    substring = substring.normalize("NFC");
    let scan = 0;
    const sliceLen = substring.length;
    for (; scan + sliceLen <= string.length; scan++) {
      const slice = string.slice(scan, scan + sliceLen);
      if (collator.value.compare(substring, slice) === 0)
        return true;
    }
    return false;
  };
  return {
    startsWith,
    endsWith,
    contains
  };
}

// node_modules/reka-ui/dist/Listbox/ListboxRoot.js
import { defineComponent as defineComponent68, toRefs as toRefs11, ref as ref29, watch as watch15, nextTick as nextTick12, createBlock as createBlock57, openBlock as openBlock60, unref as unref63, withCtx as withCtx57, renderSlot as renderSlot61, createCommentVNode as createCommentVNode7 } from "vue";

// node_modules/reka-ui/dist/Listbox/utils.js
function queryCheckedElement(parentEl) {
  return parentEl?.querySelector("[data-state=checked]");
}
function valueComparator(value, currentValue, comparator) {
  if (value === void 0)
    return false;
  else if (Array.isArray(value))
    return value.some((val) => compare(val, currentValue, comparator));
  else
    return compare(value, currentValue, comparator);
}
function compare(value, currentValue, comparator) {
  if (value === void 0 || currentValue === void 0)
    return false;
  if (typeof value === "string")
    return value === currentValue;
  if (typeof comparator === "function")
    return comparator(value, currentValue);
  if (typeof comparator === "string")
    return value?.[comparator] === currentValue?.[comparator];
  return isEqual(value, currentValue);
}

// node_modules/reka-ui/dist/shared/useTypeahead.js
function useTypeahead(callback) {
  const search = refAutoReset("", 1e3);
  const handleTypeaheadSearch = (key, items) => {
    search.value = search.value + key;
    {
      const currentItem = getActiveElement();
      const itemsWithTextValue = items.map((item) => ({
        ...item,
        textValue: item.value?.textValue ?? item.ref.textContent?.trim() ?? ""
      }));
      const currentMatch = itemsWithTextValue.find((item) => item.ref === currentItem);
      const values = itemsWithTextValue.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search.value, currentMatch?.textValue);
      const newItem = itemsWithTextValue.find((item) => item.textValue === nextMatch);
      if (newItem)
        newItem.ref.focus();
      return newItem?.ref;
    }
  };
  const resetTypeahead = () => {
    search.value = "";
  };
  return {
    search,
    handleTypeaheadSearch,
    resetTypeahead
  };
}
function wrapArray2(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray2(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}

// node_modules/reka-ui/dist/shared/arrays.js
function areEqual(arrayA, arrayB) {
  if (arrayA.length !== arrayB.length)
    return false;
  for (let index = 0; index < arrayA.length; index++) {
    if (arrayA[index] !== arrayB[index])
      return false;
  }
  return true;
}
function findValuesBetween(array, start, end) {
  const startIndex = array.findIndex((i) => isEqual(i, start));
  const endIndex = array.findIndex((i) => isEqual(i, end));
  if (startIndex === -1 || endIndex === -1)
    return [];
  const [minIndex, maxIndex] = [startIndex, endIndex].sort((a, b) => a - b);
  return array.slice(minIndex, maxIndex + 1);
}

// node_modules/reka-ui/dist/Listbox/ListboxRoot.js
var [injectListboxRootContext, provideListboxRootContext] = createContext("ListboxRoot");
var _sfc_main63 = defineComponent68({
  __name: "ListboxRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    multiple: { type: Boolean },
    orientation: { default: "vertical" },
    dir: {},
    disabled: { type: Boolean },
    selectionBehavior: { default: "toggle" },
    highlightOnHover: { type: Boolean },
    by: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "highlight", "entryFocus", "leave"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { multiple, highlightOnHover, orientation, disabled, selectionBehavior, dir: propDir } = toRefs11(props2);
    const { getItems } = useCollection({ isProvider: true });
    const { handleTypeaheadSearch } = useTypeahead();
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const kbd = useKbd();
    const dir = useDirection(propDir);
    const isFormControl = useFormControl(currentElement);
    const firstValue = ref29();
    const isUserAction = ref29(false);
    const focusable = ref29(true);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? (multiple.value ? [] : void 0),
      passive: props2.modelValue === void 0,
      deep: true
    });
    function onValueChange(val) {
      isUserAction.value = true;
      if (props2.multiple) {
        const modelArray = Array.isArray(modelValue.value) ? [...modelValue.value] : [];
        const index = modelArray.findIndex((i) => compare(i, val, props2.by));
        if (props2.selectionBehavior === "toggle") {
          index === -1 ? modelArray.push(val) : modelArray.splice(index, 1);
          modelValue.value = modelArray;
        } else {
          modelValue.value = [val];
          firstValue.value = val;
        }
      } else {
        if (props2.selectionBehavior === "toggle") {
          if (compare(modelValue.value, val, props2.by))
            modelValue.value = void 0;
          else
            modelValue.value = val;
        } else {
          modelValue.value = val;
        }
      }
      setTimeout(() => {
        isUserAction.value = false;
      }, 1);
    }
    const highlightedElement = ref29(null);
    const previousElement = ref29(null);
    const isVirtual = ref29(false);
    const isComposing = ref29(false);
    const virtualFocusHook = createEventHook();
    const virtualKeydownHook = createEventHook();
    const virtualHighlightHook = createEventHook();
    function getCollectionItem() {
      return getItems().map((i) => i.ref).filter((i) => i.dataset.disabled !== "");
    }
    function changeHighlight(el, scrollIntoView = true) {
      if (!el)
        return;
      highlightedElement.value = el;
      if (focusable.value)
        highlightedElement.value.focus();
      if (scrollIntoView)
        highlightedElement.value.scrollIntoView({ block: "nearest" });
      const highlightedItem = getItems().find((i) => i.ref === el);
      emits("highlight", highlightedItem);
    }
    function highlightItem(value) {
      if (isVirtual.value) {
        virtualHighlightHook.trigger(value);
      } else {
        const item = getItems().find((i) => compare(i.value, value, props2.by));
        if (item) {
          highlightedElement.value = item.ref;
          changeHighlight(item.ref);
        }
      }
    }
    function onKeydownEnter(event) {
      if (highlightedElement.value && highlightedElement.value.isConnected) {
        event.preventDefault();
        event.stopPropagation();
        if (!isComposing.value) {
          highlightedElement.value.click();
        }
      }
    }
    function onKeydownTypeAhead(event) {
      if (!focusable.value)
        return;
      isUserAction.value = true;
      if (isVirtual.value) {
        virtualKeydownHook.trigger(event);
      } else {
        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
        if (isMetaKey && event.key === "a" && multiple.value) {
          const collection = getItems();
          const values = collection.map((i) => i.value);
          modelValue.value = [...values];
          event.preventDefault();
          changeHighlight(collection[collection.length - 1].ref);
        } else if (!isMetaKey) {
          const el = handleTypeaheadSearch(event.key, getItems());
          if (el)
            changeHighlight(el);
        }
      }
      setTimeout(() => {
        isUserAction.value = false;
      }, 1);
    }
    function onCompositionStart() {
      isComposing.value = true;
    }
    function onCompositionEnd() {
      requestAnimationFrame(() => {
        isComposing.value = false;
      });
    }
    function highlightFirstItem() {
      nextTick12(() => {
        const event = new KeyboardEvent("keydown", { key: "PageUp" });
        onKeydownNavigation(event);
      });
    }
    function onLeave(event) {
      const el = highlightedElement.value;
      if (el?.isConnected) {
        previousElement.value = el;
      }
      highlightedElement.value = null;
      emits("leave", event);
    }
    function onEnter(event) {
      const entryFocusEvent = new CustomEvent("listbox.entryFocus", { bubbles: false, cancelable: true });
      event.currentTarget?.dispatchEvent(entryFocusEvent);
      emits("entryFocus", entryFocusEvent);
      if (entryFocusEvent.defaultPrevented)
        return;
      if (previousElement.value) {
        changeHighlight(previousElement.value);
      } else {
        const el = getCollectionItem()?.[0];
        changeHighlight(el);
      }
    }
    function onKeydownNavigation(event) {
      const intent = getFocusIntent(event, orientation.value, dir.value);
      if (!intent)
        return;
      let collection = getCollectionItem();
      if (highlightedElement.value) {
        if (intent === "last") {
          collection.reverse();
        } else if (intent === "prev" || intent === "next") {
          if (intent === "prev")
            collection.reverse();
          const currentIndex = collection.indexOf(highlightedElement.value);
          collection = collection.slice(currentIndex + 1);
        }
        handleMultipleReplace(event, collection[0]);
      }
      if (collection.length) {
        const index = !highlightedElement.value && intent === "prev" ? collection.length - 1 : 0;
        changeHighlight(collection[index]);
      }
      if (isVirtual.value)
        return virtualKeydownHook.trigger(event);
    }
    function handleMultipleReplace(event, targetEl) {
      if (isVirtual.value || props2.selectionBehavior !== "replace" || !multiple.value || !Array.isArray(modelValue.value))
        return;
      const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
      if (isMetaKey && !event.shiftKey)
        return;
      if (event.shiftKey) {
        const collection = getItems().filter((i) => i.ref.dataset.disabled !== "");
        let lastValue = collection.find((i) => i.ref === targetEl)?.value;
        if (event.key === kbd.END)
          lastValue = collection[collection.length - 1].value;
        else if (event.key === kbd.HOME)
          lastValue = collection[0].value;
        if (!lastValue || !firstValue.value)
          return;
        const values = findValuesBetween(collection.map((i) => i.value), firstValue.value, lastValue);
        modelValue.value = values;
      }
    }
    async function highlightSelected(event) {
      await nextTick12();
      if (isVirtual.value) {
        virtualFocusHook.trigger(event);
      } else {
        const collection = getCollectionItem();
        const item = collection.find((i) => i.dataset.state === "checked");
        if (item)
          changeHighlight(item);
        else if (collection.length)
          changeHighlight(collection[0]);
      }
    }
    watch15(modelValue, () => {
      if (!isUserAction.value) {
        nextTick12(() => {
          highlightSelected();
        });
      }
    }, { immediate: true, deep: true });
    __expose({
      highlightedElement,
      highlightItem,
      highlightFirstItem,
      highlightSelected,
      getItems
    });
    provideListboxRootContext({
      modelValue,
      // @ts-expect-error ignoring
      onValueChange,
      multiple,
      orientation,
      dir,
      disabled,
      highlightOnHover,
      highlightedElement,
      isVirtual,
      virtualFocusHook,
      virtualKeydownHook,
      virtualHighlightHook,
      by: props2.by,
      firstValue,
      selectionBehavior,
      focusable,
      onLeave,
      onEnter,
      changeHighlight,
      onKeydownEnter,
      onKeydownNavigation,
      onKeydownTypeAhead,
      onCompositionStart,
      onCompositionEnd,
      highlightFirstItem
    });
    return (_ctx, _cache) => {
      return openBlock60(), createBlock57(unref63(Primitive), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        dir: unref63(dir),
        "data-disabled": unref63(disabled) ? "" : void 0,
        onPointerleave: onLeave,
        onFocusout: _cache[0] || (_cache[0] = async (event) => {
          const target = event.relatedTarget || event.target;
          await nextTick12();
          if (highlightedElement.value && unref63(currentElement) && !unref63(currentElement).contains(target)) {
            onLeave(event);
          }
        })
      }, {
        default: withCtx57(() => [
          renderSlot61(_ctx.$slots, "default", { modelValue: unref63(modelValue) }),
          unref63(isFormControl) && _ctx.name ? (openBlock60(), createBlock57(unref63(_sfc_main52), {
            key: 0,
            name: _ctx.name,
            value: unref63(modelValue),
            disabled: unref63(disabled),
            required: _ctx.required
          }, null, 8, ["name", "value", "disabled", "required"])) : createCommentVNode7("", true)
        ]),
        _: 3
      }, 8, ["as", "as-child", "dir", "data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxRoot.js
var [injectComboboxRootContext, provideComboboxRootContext] = createContext("ComboboxRoot");
var _sfc_main64 = defineComponent69({
  __name: "ComboboxRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    resetSearchTermOnBlur: { type: Boolean, default: true },
    resetSearchTermOnSelect: { type: Boolean, default: true },
    ignoreFilter: { type: Boolean },
    modelValue: {},
    defaultValue: {},
    multiple: { type: Boolean },
    dir: {},
    disabled: { type: Boolean },
    highlightOnHover: { type: Boolean },
    by: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "highlight", "update:open"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const { multiple, disabled, ignoreFilter, resetSearchTermOnSelect, dir: propDir } = toRefs12(props2);
    const dir = useDirection(propDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      // @ts-expect-error ignore the type error here
      defaultValue: props2.defaultValue ?? (multiple.value ? [] : void 0),
      passive: props2.modelValue === void 0,
      deep: true
    });
    const open = useVModel(props2, "open", emits, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    async function onOpenChange(val) {
      open.value = val;
      filterState.search = "";
      if (val) {
        await nextTick13();
        primitiveElement.value?.highlightSelected();
        isUserInputted.value = true;
      } else {
        isUserInputted.value = false;
      }
      inputElement.value?.focus();
      setTimeout(() => {
        if (!val && props2.resetSearchTermOnBlur)
          resetSearchTerm.trigger();
      }, 1);
    }
    const resetSearchTerm = createEventHook();
    const isUserInputted = ref30(false);
    const isVirtual = ref30(false);
    const inputElement = ref30();
    const triggerElement = ref30();
    const highlightedElement = computed33(() => primitiveElement.value?.highlightedElement ?? void 0);
    const allItems = ref30(/* @__PURE__ */ new Map());
    const allGroups = ref30(/* @__PURE__ */ new Map());
    const { contains } = useFilter({ sensitivity: "base" });
    const filterState = reactive5({
      search: "",
      filtered: {
        /** The count of all visible items. */
        count: 0,
        /** Map from visible item id to its search score. */
        items: /* @__PURE__ */ new Map(),
        /** Set of groups with at least one visible item. */
        groups: /* @__PURE__ */ new Set()
      }
    });
    function filterItems() {
      if (!filterState.search || props2.ignoreFilter || isVirtual.value) {
        filterState.filtered.count = allItems.value.size;
        return;
      }
      filterState.filtered.groups = /* @__PURE__ */ new Set();
      let itemCount = 0;
      for (const [id, value] of allItems.value) {
        const score = contains(value, filterState.search);
        filterState.filtered.items.set(id, score ? 1 : 0);
        if (score)
          itemCount++;
      }
      for (const [groupId, group] of allGroups.value) {
        for (const itemId of group) {
          if (filterState.filtered.items.get(itemId) > 0) {
            filterState.filtered.groups.add(groupId);
            break;
          }
        }
      }
      filterState.filtered.count = itemCount;
    }
    watch16([() => filterState.search, () => allItems.value.size], () => {
      filterItems();
    }, { immediate: true });
    watch16(() => open.value, () => {
      nextTick13(() => {
        if (open.value)
          filterItems();
      });
    }, { flush: "post" });
    const inst = getCurrentInstance7();
    onMounted12(() => {
      if (inst?.exposed) {
        inst.exposed.highlightItem = primitiveElement.value?.highlightItem;
        inst.exposed.highlightFirstItem = primitiveElement.value?.highlightFirstItem;
        inst.exposed.highlightSelected = primitiveElement.value?.highlightSelected;
      }
    });
    __expose({
      filtered: computed33(() => filterState.filtered),
      highlightedElement,
      highlightItem: primitiveElement.value?.highlightItem,
      highlightFirstItem: primitiveElement.value?.highlightFirstItem,
      highlightSelected: primitiveElement.value?.highlightSelected
    });
    provideComboboxRootContext({
      modelValue,
      multiple,
      disabled,
      open,
      onOpenChange,
      contentId: "",
      isUserInputted,
      isVirtual,
      inputElement,
      highlightedElement,
      onInputElementChange: (val) => inputElement.value = val,
      triggerElement,
      onTriggerElementChange: (val) => triggerElement.value = val,
      parentElement,
      resetSearchTermOnSelect,
      onResetSearchTerm: resetSearchTerm.on,
      allItems,
      allGroups,
      filterState,
      ignoreFilter
    });
    return (_ctx, _cache) => {
      return openBlock61(), createBlock58(unref64(_sfc_main57), null, {
        default: withCtx58(() => [
          createVNode11(unref64(_sfc_main63), mergeProps29({
            ref_key: "primitiveElement",
            ref: primitiveElement
          }, _ctx.$attrs, {
            modelValue: unref64(modelValue),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef3(modelValue) ? modelValue.value = $event : null),
            style: {
              pointerEvents: unref64(open) ? "auto" : void 0
            },
            as: _ctx.as,
            "as-child": _ctx.asChild,
            dir: unref64(dir),
            multiple: unref64(multiple),
            name: _ctx.name,
            required: _ctx.required,
            disabled: unref64(disabled),
            "highlight-on-hover": true,
            by: props2.by,
            onHighlight: _cache[1] || (_cache[1] = ($event) => emits("highlight", $event))
          }), {
            default: withCtx58(() => [
              renderSlot62(_ctx.$slots, "default", {
                open: unref64(open),
                modelValue: unref64(modelValue)
              })
            ]),
            _: 3
          }, 16, ["modelValue", "style", "as", "as-child", "dir", "multiple", "name", "required", "disabled", "by"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Listbox/ListboxContent.js
import { defineComponent as defineComponent70, createBlock as createBlock59, openBlock as openBlock62, unref as unref65, withCtx as withCtx59, createVNode as createVNode12, withKeys as withKeys4, withModifiers as withModifiers4, renderSlot as renderSlot63 } from "vue";
var _sfc_main65 = defineComponent70({
  __name: "ListboxContent",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const { CollectionSlot } = useCollection();
    const rootContext = injectListboxRootContext();
    const isClickFocus = refAutoReset(false, 10);
    return (_ctx, _cache) => {
      return openBlock62(), createBlock59(unref65(CollectionSlot), null, {
        default: withCtx59(() => [
          createVNode12(unref65(Primitive), {
            role: "listbox",
            as: _ctx.as,
            "as-child": _ctx.asChild,
            tabindex: unref65(rootContext).focusable.value ? unref65(rootContext).highlightedElement.value ? "-1" : "0" : void 0,
            "aria-orientation": unref65(rootContext).orientation.value,
            "aria-multiselectable": !!unref65(rootContext).multiple.value,
            "data-orientation": unref65(rootContext).orientation.value,
            onMousedown: _cache[0] || (_cache[0] = withModifiers4(($event) => isClickFocus.value = true, ["left"])),
            onFocus: _cache[1] || (_cache[1] = (ev) => {
              if (unref65(isClickFocus))
                return;
              unref65(rootContext).onEnter(ev);
            }),
            onKeydown: [
              _cache[2] || (_cache[2] = withKeys4(withModifiers4((event) => {
                unref65(rootContext).focusable.value ? unref65(rootContext).onKeydownNavigation(event) : void 0;
              }, ["prevent"]), ["down", "up", "left", "right", "home", "end"])),
              withKeys4(unref65(rootContext).onKeydownEnter, ["enter"]),
              unref65(rootContext).onKeydownTypeAhead
            ]
          }, {
            default: withCtx59(() => [
              renderSlot63(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["as", "as-child", "tabindex", "aria-orientation", "aria-multiselectable", "data-orientation", "onKeydown"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxContentImpl.js
var [injectComboboxContentContext, provideComboboxContentContext] = createContext("ComboboxContent");
var _sfc_main66 = defineComponent71({
  __name: "ComboboxContentImpl",
  props: {
    position: { default: "inline" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { position } = toRefs13(props2);
    const rootContext = injectComboboxRootContext();
    const { forwardRef, currentElement } = useForwardExpose();
    useBodyScrollLock(props2.bodyLock);
    useHideOthers(rootContext.parentElement);
    const pickedProps = computed34(() => {
      if (props2.position === "popper")
        return props2;
      else return {};
    });
    const forwardedProps = useForwardProps(pickedProps.value);
    const popperStyle = {
      // Ensure border-box for floating-ui calculations
      "boxSizing": "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    provideComboboxContentContext({ position });
    const isInputWithinContent = ref31(false);
    onMounted13(() => {
      if (rootContext.inputElement.value) {
        isInputWithinContent.value = currentElement.value.contains(rootContext.inputElement.value);
        if (isInputWithinContent.value) {
          rootContext.inputElement.value.focus();
        }
      }
    });
    onUnmounted6(() => {
      if (isInputWithinContent.value) {
        rootContext.triggerElement.value?.focus();
      }
    });
    return (_ctx, _cache) => {
      return openBlock63(), createBlock60(unref66(_sfc_main65), { "as-child": "" }, {
        default: withCtx60(() => [
          createVNode13(unref66(_sfc_main14), {
            "as-child": "",
            "disable-outside-pointer-events": _ctx.disableOutsidePointerEvents,
            onDismiss: _cache[0] || (_cache[0] = ($event) => unref66(rootContext).onOpenChange(false)),
            onFocusOutside: _cache[1] || (_cache[1] = (ev) => {
              if (unref66(rootContext).parentElement.value?.contains(ev.target)) ev.preventDefault();
              emits("focusOutside", ev);
            }),
            onInteractOutside: _cache[2] || (_cache[2] = ($event) => emits("interactOutside", $event)),
            onEscapeKeyDown: _cache[3] || (_cache[3] = ($event) => emits("escapeKeyDown", $event)),
            onPointerDownOutside: _cache[4] || (_cache[4] = (ev) => {
              if (unref66(rootContext).parentElement.value?.contains(ev.target)) ev.preventDefault();
              emits("pointerDownOutside", ev);
            })
          }, {
            default: withCtx60(() => [
              (openBlock63(), createBlock60(resolveDynamicComponent3(unref66(position) === "popper" ? unref66(_sfc_main61) : unref66(Primitive)), mergeProps30({ ..._ctx.$attrs, ...unref66(forwardedProps) }, {
                id: unref66(rootContext).contentId,
                ref: unref66(forwardRef),
                "data-state": unref66(rootContext).open.value ? "open" : "closed",
                style: {
                  // flex layout so we can place the scroll buttons properly
                  display: "flex",
                  flexDirection: "column",
                  // reset the outline by default as the content MAY get focused
                  outline: "none",
                  ...unref66(position) === "popper" ? popperStyle : {}
                }
              }), {
                default: withCtx60(() => [
                  renderSlot64(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["id", "data-state", "style"]))
            ]),
            _: 3
          }, 8, ["disable-outside-pointer-events"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxArrow.js
var _sfc_main67 = defineComponent72({
  __name: "ComboboxArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectComboboxRootContext();
    const contentContext = injectComboboxContentContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return unref67(rootContext).open.value && unref67(contentContext).position.value === "popper" ? (openBlock64(), createBlock61(unref67(_sfc_main62), normalizeProps12(mergeProps31({ key: 0 }, props2)), {
        default: withCtx61(() => [
          renderSlot65(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode8("", true);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxCancel.js
import { defineComponent as defineComponent73, createBlock as createBlock62, openBlock as openBlock65, unref as unref68, mergeProps as mergeProps32, withCtx as withCtx62, renderSlot as renderSlot66 } from "vue";
var _sfc_main68 = defineComponent73({
  __name: "ComboboxCancel",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectComboboxRootContext();
    function handleClick() {
      rootContext.filterState.search = "";
      if (rootContext.inputElement.value) {
        rootContext.inputElement.value.value = "";
        rootContext.inputElement.value.focus();
      }
    }
    return (_ctx, _cache) => {
      return openBlock65(), createBlock62(unref68(Primitive), mergeProps32({
        type: _ctx.as === "button" ? "button" : void 0
      }, props2, {
        tabindex: "-1",
        onClick: handleClick
      }), {
        default: withCtx62(() => [
          renderSlot66(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["type"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxContent.js
import { defineComponent as defineComponent74, createBlock as createBlock63, openBlock as openBlock66, unref as unref69, withCtx as withCtx63, createVNode as createVNode14, mergeProps as mergeProps33, renderSlot as renderSlot67 } from "vue";
var _sfc_main69 = defineComponent74({
  __name: "ComboboxContent",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const { forwardRef } = useForwardExpose();
    const rootContext = injectComboboxRootContext();
    rootContext.contentId ||= useId2(void 0, "reka-combobox-content");
    return (_ctx, _cache) => {
      return openBlock66(), createBlock63(unref69(Presence), {
        present: _ctx.forceMount || unref69(rootContext).open.value
      }, {
        default: withCtx63(() => [
          createVNode14(_sfc_main66, mergeProps33({ ...unref69(forwarded), ..._ctx.$attrs }, { ref: unref69(forwardRef) }), {
            default: withCtx63(() => [
              renderSlot67(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxEmpty.js
import { defineComponent as defineComponent75, computed as computed35, createBlock as createBlock64, createCommentVNode as createCommentVNode9, openBlock as openBlock67, unref as unref70, normalizeProps as normalizeProps13, mergeProps as mergeProps34, withCtx as withCtx64, renderSlot as renderSlot68, createTextVNode as createTextVNode5 } from "vue";
var _sfc_main70 = defineComponent75({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectComboboxRootContext();
    const isRender = computed35(
      () => rootContext.ignoreFilter.value ? rootContext.allItems.value.size === 0 : !!rootContext.filterState.search && rootContext.filterState.filtered.count === 0
    );
    return (_ctx, _cache) => {
      return isRender.value ? (openBlock67(), createBlock64(unref70(Primitive), normalizeProps13(mergeProps34({ key: 0 }, props2)), {
        default: withCtx64(() => [
          renderSlot68(_ctx.$slots, "default", {}, () => [
            _cache[0] || (_cache[0] = createTextVNode5("No options"))
          ])
        ]),
        _: 3
      }, 16)) : createCommentVNode9("", true);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxGroup.js
import { defineComponent as defineComponent77, computed as computed36, onMounted as onMounted14, onUnmounted as onUnmounted7, createBlock as createBlock66, openBlock as openBlock69, unref as unref72, mergeProps as mergeProps36, withCtx as withCtx66, renderSlot as renderSlot70 } from "vue";

// node_modules/reka-ui/dist/Listbox/ListboxGroup.js
import { defineComponent as defineComponent76, createBlock as createBlock65, openBlock as openBlock68, unref as unref71, mergeProps as mergeProps35, withCtx as withCtx65, renderSlot as renderSlot69 } from "vue";
var [injectListboxGroupContext, provideListboxGroupContext] = createContext("ListboxGroup");
var _sfc_main71 = defineComponent76({
  __name: "ListboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const id = useId2(void 0, "reka-listbox-group");
    provideListboxGroupContext({ id });
    return (_ctx, _cache) => {
      return openBlock68(), createBlock65(unref71(Primitive), mergeProps35({ role: "group" }, props2, { "aria-labelledby": unref71(id) }), {
        default: withCtx65(() => [
          renderSlot69(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-labelledby"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxGroup.js
var [injectComboboxGroupContext, provideComboboxGroupContext] = createContext("ComboboxGroup");
var _sfc_main72 = defineComponent77({
  __name: "ComboboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const id = useId2(void 0, "reka-combobox-group");
    const rootContext = injectComboboxRootContext();
    const isRender = computed36(() => rootContext.ignoreFilter.value ? true : !rootContext.filterState.search ? true : rootContext.filterState.filtered.groups.has(id));
    const context2 = provideComboboxGroupContext({
      id,
      labelId: ""
    });
    onMounted14(() => {
      if (!rootContext.allGroups.value.has(id))
        rootContext.allGroups.value.set(id, /* @__PURE__ */ new Set());
    });
    onUnmounted7(() => {
      rootContext.allGroups.value.delete(id);
    });
    return (_ctx, _cache) => {
      return openBlock69(), createBlock66(unref72(_sfc_main71), mergeProps36({
        id: unref72(id),
        "aria-labelledby": unref72(context2).labelId
      }, props2, {
        hidden: isRender.value ? void 0 : true
      }), {
        default: withCtx66(() => [
          renderSlot70(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby", "hidden"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxInput.js
import { defineComponent as defineComponent79, onMounted as onMounted16, watch as watch17, createBlock as createBlock68, openBlock as openBlock71, unref as unref74, withKeys as withKeys6, withModifiers as withModifiers6, isRef as isRef4, withCtx as withCtx68, renderSlot as renderSlot72, nextTick as nextTick14 } from "vue";

// node_modules/reka-ui/dist/Listbox/ListboxFilter.js
import { defineComponent as defineComponent78, computed as computed37, ref as ref32, watchSyncEffect, onMounted as onMounted15, onUnmounted as onUnmounted8, createBlock as createBlock67, openBlock as openBlock70, unref as unref73, withKeys as withKeys5, withModifiers as withModifiers5, withCtx as withCtx67, renderSlot as renderSlot71 } from "vue";
var _sfc_main73 = defineComponent78({
  __name: "ListboxFilter",
  props: {
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: "",
      passive: props2.modelValue === void 0
    });
    const rootContext = injectListboxRootContext();
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const disabled = computed37(() => props2.disabled || rootContext.disabled.value || false);
    const activedescendant = ref32();
    watchSyncEffect(() => activedescendant.value = rootContext.highlightedElement.value?.id);
    onMounted15(() => {
      rootContext.focusable.value = false;
      setTimeout(() => {
        if (props2.autoFocus)
          currentElement.value?.focus();
      }, 1);
    });
    onUnmounted8(() => {
      rootContext.focusable.value = true;
    });
    return (_ctx, _cache) => {
      return openBlock70(), createBlock67(unref73(Primitive), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        value: unref73(modelValue),
        disabled: disabled.value ? "" : void 0,
        "data-disabled": disabled.value ? "" : void 0,
        "aria-disabled": disabled.value ?? void 0,
        "aria-activedescendant": activedescendant.value,
        type: "text",
        onKeydown: [
          withKeys5(withModifiers5(unref73(rootContext).onKeydownNavigation, ["prevent"]), ["down", "up", "home", "end"]),
          withKeys5(unref73(rootContext).onKeydownEnter, ["enter"])
        ],
        onInput: _cache[0] || (_cache[0] = (event) => {
          modelValue.value = event.target.value;
          unref73(rootContext).highlightFirstItem(event);
        }),
        onCompositionstart: unref73(rootContext).onCompositionStart,
        onCompositionend: unref73(rootContext).onCompositionEnd
      }, {
        default: withCtx67(() => [
          renderSlot71(_ctx.$slots, "default", { modelValue: unref73(modelValue) })
        ]),
        _: 3
      }, 8, ["as", "as-child", "value", "disabled", "data-disabled", "aria-disabled", "aria-activedescendant", "onKeydown", "onCompositionstart", "onCompositionend"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxInput.js
var _sfc_main74 = defineComponent79({
  __name: "ComboboxInput",
  props: {
    displayValue: {},
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectComboboxRootContext();
    const listboxContext = injectListboxRootContext();
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const modelValue = useVModel(props2, "modelValue", emits, {
      passive: props2.modelValue === void 0
    });
    onMounted16(() => {
      if (currentElement.value)
        rootContext.onInputElementChange(currentElement.value);
    });
    function handleKeyDown(ev) {
      if (!rootContext.open.value)
        rootContext.onOpenChange(true);
    }
    function handleInput(event) {
      const target = event.target;
      if (!rootContext.open.value) {
        rootContext.onOpenChange(true);
        nextTick14(() => {
          if (target.value) {
            rootContext.filterState.search = target.value;
            listboxContext.highlightFirstItem(event);
          }
        });
      } else {
        rootContext.filterState.search = target.value;
      }
    }
    function resetSearchTerm() {
      const rootModelValue = rootContext.modelValue.value;
      if (props2.displayValue) {
        modelValue.value = props2.displayValue(rootModelValue);
      } else if (!rootContext.multiple.value && rootModelValue && !Array.isArray(rootModelValue)) {
        if (typeof rootModelValue !== "object")
          modelValue.value = rootModelValue.toString();
        else modelValue.value = "";
      } else {
        modelValue.value = "";
      }
      nextTick14(() => {
        modelValue.value = modelValue.value;
      });
    }
    rootContext.onResetSearchTerm(() => {
      resetSearchTerm();
    });
    watch17(rootContext.modelValue, async () => {
      if (!rootContext.isUserInputted.value && rootContext.resetSearchTermOnSelect.value)
        resetSearchTerm();
    }, { immediate: true, deep: true });
    watch17(
      () => props2.modelValue,
      () => {
        if (props2.modelValue !== void 0) {
          rootContext.filterState.search = props2.modelValue;
        }
      }
    );
    return (_ctx, _cache) => {
      return openBlock71(), createBlock68(unref74(_sfc_main73), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        modelValue: unref74(modelValue),
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef4(modelValue) ? modelValue.value = $event : null),
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "auto-focus": _ctx.autoFocus,
        "aria-expanded": unref74(rootContext).open.value,
        "aria-controls": unref74(rootContext).contentId,
        "aria-autocomplete": "list",
        role: "combobox",
        autocomplete: "false",
        onInput: handleInput,
        onKeydown: withKeys6(withModifiers6(handleKeyDown, ["prevent"]), ["down", "up"])
      }, {
        default: withCtx68(() => [
          renderSlot72(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["modelValue", "as", "as-child", "auto-focus", "aria-expanded", "aria-controls", "onKeydown"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxItem.js
import { defineComponent as defineComponent81, computed as computed39, onMounted as onMounted17, onUnmounted as onUnmounted9, createBlock as createBlock70, createCommentVNode as createCommentVNode10, openBlock as openBlock73, unref as unref76, mergeProps as mergeProps38, withCtx as withCtx70, renderSlot as renderSlot74, createTextVNode as createTextVNode6, toDisplayString as toDisplayString4 } from "vue";

// node_modules/reka-ui/dist/Listbox/ListboxItem.js
import { defineComponent as defineComponent80, computed as computed38, createBlock as createBlock69, openBlock as openBlock72, unref as unref75, withCtx as withCtx69, withMemo, createVNode as createVNode15, mergeProps as mergeProps37, withKeys as withKeys7, withModifiers as withModifiers7, renderSlot as renderSlot73 } from "vue";
var LISTBOX_SELECT = "listbox.select";
var [injectListboxItemContext, provideListboxItemContext] = createContext("ListboxItem");
var _sfc_main75 = defineComponent80({
  __name: "ListboxItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const id = useId2(void 0, "reka-listbox-item");
    const { CollectionItem } = useCollection();
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectListboxRootContext();
    const isHighlighted = computed38(() => currentElement.value === rootContext.highlightedElement.value);
    const isSelected = computed38(() => valueComparator(rootContext.modelValue.value, props2.value, rootContext.by));
    const disabled = computed38(() => rootContext.disabled.value || props2.disabled);
    async function handleSelect2(ev) {
      emits("select", ev);
      if (ev?.defaultPrevented)
        return;
      if (!disabled.value && ev) {
        rootContext.onValueChange(props2.value);
        rootContext.changeHighlight(currentElement.value);
      }
    }
    function handleSelectCustomEvent(ev) {
      const eventDetail = { originalEvent: ev, value: props2.value };
      handleAndDispatchCustomEvent(LISTBOX_SELECT, handleSelect2, eventDetail);
    }
    provideListboxItemContext({
      isSelected
    });
    return (_ctx, _cache) => {
      return openBlock72(), createBlock69(unref75(CollectionItem), { value: _ctx.value }, {
        default: withCtx69(() => [
          withMemo([isHighlighted.value, isSelected.value], () => createVNode15(unref75(Primitive), mergeProps37({ id: unref75(id) }, _ctx.$attrs, {
            ref: unref75(forwardRef),
            role: "option",
            tabindex: unref75(rootContext).focusable.value ? isHighlighted.value ? "0" : "-1" : -1,
            "aria-selected": isSelected.value,
            as: _ctx.as,
            "as-child": _ctx.asChild,
            disabled: disabled.value ? "" : void 0,
            "data-disabled": disabled.value ? "" : void 0,
            "data-highlighted": isHighlighted.value ? "" : void 0,
            "data-state": isSelected.value ? "checked" : "unchecked",
            onClick: handleSelectCustomEvent,
            onKeydown: withKeys7(withModifiers7(handleSelectCustomEvent, ["prevent"]), ["space"]),
            onPointermove: _cache[0] || (_cache[0] = (event) => {
              if (unref75(rootContext).highlightedElement.value === unref75(currentElement))
                return;
              if (unref75(rootContext).highlightOnHover.value)
                unref75(rootContext).changeHighlight(unref75(currentElement), false);
              else
                unref75(rootContext).focusable.value ? void 0 : unref75(rootContext).changeHighlight(unref75(currentElement), false);
            })
          }), {
            default: withCtx69(() => [
              renderSlot73(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["id", "tabindex", "aria-selected", "as", "as-child", "disabled", "data-disabled", "data-highlighted", "data-state", "onKeydown"]), _cache, 1)
        ]),
        _: 3
      }, 8, ["value"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxItem.js
var _sfc_main76 = defineComponent81({
  __name: "ComboboxItem",
  props: {
    textValue: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const id = useId2(void 0, "reka-combobox-item");
    const rootContext = injectComboboxRootContext();
    const groupContext = injectComboboxGroupContext(null);
    const { primitiveElement, currentElement } = usePrimitiveElement();
    if (props2.value === "") {
      throw new Error(
        "A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    const isRender = computed39(() => {
      if (rootContext.isVirtual.value || rootContext.ignoreFilter.value || !rootContext.filterState.search) {
        return true;
      } else {
        const filteredCurrentItem = rootContext.filterState.filtered.items.get(id);
        if (filteredCurrentItem === void 0) {
          return true;
        }
        return filteredCurrentItem > 0;
      }
    });
    onMounted17(() => {
      rootContext.allItems.value.set(id, props2.textValue || currentElement.value.textContent || currentElement.value.innerText);
      const groupId = groupContext?.id;
      if (groupId) {
        if (!rootContext.allGroups.value.has(groupId)) {
          rootContext.allGroups.value.set(groupId, /* @__PURE__ */ new Set([id]));
        } else {
          rootContext.allGroups.value.get(groupId)?.add(id);
        }
      }
    });
    onUnmounted9(() => {
      rootContext.allItems.value.delete(id);
    });
    return (_ctx, _cache) => {
      return isRender.value ? (openBlock73(), createBlock70(unref76(_sfc_main75), mergeProps38({ key: 0 }, props2, {
        id: unref76(id),
        ref_key: "primitiveElement",
        ref: primitiveElement,
        disabled: unref76(rootContext).disabled.value || _ctx.disabled,
        onSelect: _cache[0] || (_cache[0] = (event) => {
          emits("select", event);
          if (event.defaultPrevented)
            return;
          if (!unref76(rootContext).multiple.value && !_ctx.disabled && !unref76(rootContext).disabled.value) {
            event.preventDefault();
            unref76(rootContext).onOpenChange(false);
            unref76(rootContext).modelValue.value = props2.value;
          }
        })
      }), {
        default: withCtx70(() => [
          renderSlot74(_ctx.$slots, "default", {}, () => [
            createTextVNode6(toDisplayString4(_ctx.value), 1)
          ])
        ]),
        _: 3
      }, 16, ["id", "disabled"])) : createCommentVNode10("", true);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxItemIndicator.js
import { defineComponent as defineComponent83, createBlock as createBlock72, openBlock as openBlock75, unref as unref78, normalizeProps as normalizeProps14, guardReactiveProps as guardReactiveProps12, withCtx as withCtx72, renderSlot as renderSlot76 } from "vue";

// node_modules/reka-ui/dist/Listbox/ListboxItemIndicator.js
import { defineComponent as defineComponent82, createBlock as createBlock71, createCommentVNode as createCommentVNode11, unref as unref77, openBlock as openBlock74, mergeProps as mergeProps39, withCtx as withCtx71, renderSlot as renderSlot75 } from "vue";
var _sfc_main77 = defineComponent82({
  __name: "ListboxItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const itemContext = injectListboxItemContext();
    return (_ctx, _cache) => {
      return unref77(itemContext).isSelected.value ? (openBlock74(), createBlock71(unref77(Primitive), mergeProps39({
        key: 0,
        "aria-hidden": "true"
      }, props2), {
        default: withCtx71(() => [
          renderSlot75(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode11("", true);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxItemIndicator.js
var _sfc_main78 = defineComponent83({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock75(), createBlock72(unref78(_sfc_main77), normalizeProps14(guardReactiveProps12(props2)), {
        default: withCtx72(() => [
          renderSlot76(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxLabel.js
import { defineComponent as defineComponent84, createBlock as createBlock73, openBlock as openBlock76, unref as unref79, mergeProps as mergeProps40, withCtx as withCtx73, renderSlot as renderSlot77 } from "vue";
var _sfc_main79 = defineComponent84({
  __name: "ComboboxLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const groupContext = injectComboboxGroupContext({ id: "", labelId: "" });
    groupContext.labelId ||= useId2(void 0, "reka-combobox-group-label");
    return (_ctx, _cache) => {
      return openBlock76(), createBlock73(unref79(Primitive), mergeProps40(props2, {
        id: unref79(groupContext).labelId
      }), {
        default: withCtx73(() => [
          renderSlot77(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxPortal.js
import { defineComponent as defineComponent85, createBlock as createBlock74, openBlock as openBlock77, unref as unref80, normalizeProps as normalizeProps15, guardReactiveProps as guardReactiveProps13, withCtx as withCtx74, renderSlot as renderSlot78 } from "vue";
var _sfc_main80 = defineComponent85({
  __name: "ComboboxPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock77(), createBlock74(unref80(_sfc_main27), normalizeProps15(guardReactiveProps13(props2)), {
        default: withCtx74(() => [
          renderSlot78(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxSeparator.js
import { defineComponent as defineComponent86, createBlock as createBlock75, openBlock as openBlock78, unref as unref81, mergeProps as mergeProps41, withCtx as withCtx75, renderSlot as renderSlot79 } from "vue";
var _sfc_main81 = defineComponent86({
  __name: "ComboboxSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock78(), createBlock75(unref81(Primitive), mergeProps41(props2, { "aria-hidden": "true" }), {
        default: withCtx75(() => [
          renderSlot79(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxTrigger.js
import { defineComponent as defineComponent87, computed as computed40, onMounted as onMounted18, createBlock as createBlock76, openBlock as openBlock79, unref as unref82, mergeProps as mergeProps42, withCtx as withCtx76, renderSlot as renderSlot80 } from "vue";
var _sfc_main82 = defineComponent87({
  __name: "ComboboxTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectComboboxRootContext();
    const disabled = computed40(() => props2.disabled || rootContext.disabled.value || false);
    onMounted18(() => {
      if (currentElement.value)
        rootContext.onTriggerElementChange(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock79(), createBlock76(unref82(Primitive), mergeProps42(props2, {
        ref: unref82(forwardRef),
        type: _ctx.as === "button" ? "button" : void 0,
        tabindex: "-1",
        "aria-label": "Show popup",
        "aria-haspopup": "listbox",
        "aria-expanded": unref82(rootContext).open.value,
        "aria-controls": unref82(rootContext).contentId,
        "data-state": unref82(rootContext).open.value ? "open" : "closed",
        disabled: disabled.value,
        "data-disabled": disabled.value ? "" : void 0,
        "aria-disabled": disabled.value ?? void 0,
        onClick: _cache[0] || (_cache[0] = ($event) => unref82(rootContext).onOpenChange(!unref82(rootContext).open.value))
      }), {
        default: withCtx76(() => [
          renderSlot80(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "disabled", "data-disabled", "aria-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxViewport.js
import { defineComponent as defineComponent88, toRefs as toRefs14, createElementBlock as createElementBlock6, openBlock as openBlock80, Fragment as Fragment4, createVNode as createVNode16, unref as unref83, mergeProps as mergeProps43, withCtx as withCtx77, renderSlot as renderSlot81, createTextVNode as createTextVNode7 } from "vue";

// node_modules/reka-ui/dist/shared/useNonce.js
import { ref as ref33, computed as computed41 } from "vue";
function useNonce(nonce) {
  const context2 = injectConfigProviderContext({
    nonce: ref33()
  });
  return computed41(() => nonce?.value || context2.nonce?.value);
}

// node_modules/reka-ui/dist/Combobox/ComboboxViewport.js
var _sfc_main83 = defineComponent88({
  __name: "ComboboxViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const { nonce: propNonce } = toRefs14(props2);
    const nonce = useNonce(propNonce);
    const rootContext = injectComboboxRootContext();
    return (_ctx, _cache) => {
      return openBlock80(), createElementBlock6(Fragment4, null, [
        createVNode16(unref83(Primitive), mergeProps43({ ..._ctx.$attrs, ...props2 }, {
          ref: unref83(forwardRef),
          "data-reka-combobox-viewport": "",
          role: "presentation",
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: unref83(rootContext).isVirtual.value ? void 0 : 1,
            overflow: "auto"
          }
        }), {
          default: withCtx77(() => [
            renderSlot81(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["style"]),
        createVNode16(unref83(Primitive), {
          as: "style",
          nonce: unref83(nonce)
        }, {
          default: withCtx77(() => _cache[0] || (_cache[0] = [
            createTextVNode7(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")
          ])),
          _: 1
        }, 8, ["nonce"])
      ], 64);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxVirtualizer.js
import { defineComponent as defineComponent90, createBlock as createBlock78, openBlock as openBlock82, normalizeProps as normalizeProps16, guardReactiveProps as guardReactiveProps14, withCtx as withCtx78, renderSlot as renderSlot82 } from "vue";

// node_modules/reka-ui/dist/Listbox/ListboxVirtualizer.js
import { defineComponent as defineComponent89, useSlots, computed as computed43, Fragment as Fragment5, cloneVNode as cloneVNode2, createElementBlock as createElementBlock7, openBlock as openBlock81, normalizeStyle as normalizeStyle5, unref as unref85, renderList as renderList2, createBlock as createBlock77, resolveDynamicComponent as resolveDynamicComponent4 } from "vue";

// node_modules/@tanstack/virtual-core/dist/esm/utils.js
function memo(getDeps, fn, opts) {
  let deps = opts.initialDeps ?? [];
  let result;
  function memoizedFunction() {
    var _a, _b, _c, _d;
    let depTime;
    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();
    result = fn(...newDeps);
    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);
    return result;
  }
  memoizedFunction.updateDeps = (newDeps) => {
    deps = newDeps;
  };
  return memoizedFunction;
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ""}`);
  } else {
    return value;
  }
}
var approxEqual = (a, b) => Math.abs(a - b) < 1;
var debounce = (targetWindow, fn, ms) => {
  let timeoutId;
  return function(...args) {
    targetWindow.clearTimeout(timeoutId);
    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);
  };
};

// node_modules/@tanstack/virtual-core/dist/esm/index.js
var defaultKeyExtractor = (index) => index;
var defaultRangeExtractor = (range2) => {
  const start = Math.max(range2.startIndex - range2.overscan, 0);
  const end = Math.min(range2.endIndex + range2.overscan, range2.count - 1);
  const arr = [];
  for (let i = start; i <= end; i++) {
    arr.push(i);
  }
  return arr;
};
var observeElementRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(element.getBoundingClientRect());
  if (!targetWindow.ResizeObserver) {
    return () => {
    };
  }
  const observer = new targetWindow.ResizeObserver((entries) => {
    const run = () => {
      const entry = entries[0];
      if (entry == null ? void 0 : entry.borderBoxSize) {
        const box = entry.borderBoxSize[0];
        if (box) {
          handler({ width: box.inlineSize, height: box.blockSize });
          return;
        }
      }
      handler(element.getBoundingClientRect());
    };
    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
var addEventListenerOptions = {
  passive: true
};
var supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
var observeElementOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset3 = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb(offset3, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    const { horizontal, isRtl } = instance.options;
    offset3 = horizontal ? element["scrollLeft"] * (isRtl && -1 || 1) : element["scrollTop"];
    fallback();
    cb(offset3, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element.removeEventListener("scrollend", endHandler);
    }
  };
};
var measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size3 = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size3;
    }
  }
  return Math.round(
    element.getBoundingClientRect()[instance.options.horizontal ? "width" : "height"]
  );
};
var elementScroll = (offset3, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a, _b;
  const toOffset = offset3 + adjustments;
  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
var Virtualizer = class {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.targetWindow = null;
    this.isScrolling = false;
    this.scrollToIndexTimeoutId = null;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollRect = null;
    this.scrollOffset = null;
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.elementsCache = /* @__PURE__ */ new Map();
    this.observer = /* @__PURE__ */ (() => {
      let _ro = null;
      const get = () => {
        if (_ro) {
          return _ro;
        }
        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {
          return null;
        }
        return _ro = new this.targetWindow.ResizeObserver((entries) => {
          entries.forEach((entry) => {
            const run = () => {
              this._measureElement(entry.target, entry);
            };
            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
          });
        });
      };
      return {
        disconnect: () => {
          var _a;
          (_a = get()) == null ? void 0 : _a.disconnect();
          _ro = null;
        },
        observe: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined") delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: true,
        isRtl: false,
        useScrollendEvent: false,
        useAnimationFrameWithResizeObserver: false,
        ...opts2
      };
    };
    this.notify = (sync) => {
      var _a, _b;
      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);
    };
    this.maybeNotify = memo(
      () => {
        this.calculateRange();
        return [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ];
      },
      (isScrolling) => {
        this.notify(isScrolling);
      },
      {
        key: "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    );
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d) => d());
      this.unsubs = [];
      this.observer.disconnect();
      this.scrollElement = null;
      this.targetWindow = null;
    };
    this._didMount = () => {
      return () => {
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _a;
      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        if (!scrollElement) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = scrollElement;
        if (this.scrollElement && "ownerDocument" in this.scrollElement) {
          this.targetWindow = this.scrollElement.ownerDocument.defaultView;
        } else {
          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;
        }
        this.elementsCache.forEach((cached) => {
          this.observer.observe(cached);
        });
        this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.maybeNotify();
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset3, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset3 ? "forward" : "backward" : null;
            this.scrollOffset = offset3;
            this.isScrolling = isScrolling;
            this.maybeNotify();
          })
        );
      }
    };
    this.getSize = () => {
      if (!this.options.enabled) {
        this.scrollRect = null;
        return 0;
      }
      this.scrollRect = this.scrollRect ?? this.options.initialRect;
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getScrollOffset = () => {
      if (!this.options.enabled) {
        this.scrollOffset = null;
        return 0;
      }
      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
      return this.scrollOffset;
    };
    this.getFurthestMeasurement = (measurements, index) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m = index - 1; m >= 0; m--) {
        const measurement = measurements[m];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {
        if (a.end === b.end) {
          return a.index - b.index;
        }
        return a.end - b.end;
      })[0] : void 0;
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (count3, paddingStart, scrollMargin, getItemKey, enabled) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count: count3,
          paddingStart,
          scrollMargin,
          getItemKey,
          enabled
        };
      },
      {
        key: false
      }
    );
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: count3, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {
        if (!enabled) {
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          return [];
        }
        if (this.measurementsCache.length === 0) {
          this.measurementsCache = this.options.initialMeasurementsCache;
          this.measurementsCache.forEach((item) => {
            this.itemSizeCache.set(item.key, item.size);
          });
        }
        const min2 = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min2);
        for (let i = min2; i < count3; i++) {
          const key = getItemKey(i);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);
          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size3 = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i);
          const end = start + size3;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;
          measurements[i] = {
            index: i,
            start,
            size: size3,
            end,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: "getMeasurements",
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [
        this.getMeasurements(),
        this.getSize(),
        this.getScrollOffset(),
        this.options.lanes
      ],
      (measurements, outerSize, scrollOffset, lanes) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset,
          lanes
        }) : null;
      },
      {
        key: "calculateRange",
        debug: () => this.options.debug
      }
    );
    this.getVirtualIndexes = memo(
      () => {
        let startIndex = null;
        let endIndex = null;
        const range2 = this.calculateRange();
        if (range2) {
          startIndex = range2.startIndex;
          endIndex = range2.endIndex;
        }
        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);
        return [
          this.options.rangeExtractor,
          this.options.overscan,
          this.options.count,
          startIndex,
          endIndex
        ];
      },
      (rangeExtractor, overscan, count3, startIndex, endIndex) => {
        return startIndex === null || endIndex === null ? [] : rangeExtractor({
          startIndex,
          endIndex,
          overscan,
          count: count3
        });
      },
      {
        key: "getVirtualIndexes",
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, entry) => {
      const index = this.indexFromElement(node);
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const key = item.key;
      const prevNode = this.elementsCache.get(key);
      if (prevNode !== node) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node);
        this.elementsCache.set(key, node);
      }
      if (node.isConnected) {
        this.resizeItem(index, this.options.measureElement(node, entry, this));
      }
    };
    this.resizeItem = (index, size3) => {
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size3 - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
          if (this.options.debug) {
            console.info("correction", delta);
          }
          this._scrollToOffset(this.getScrollOffset(), {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size3));
        this.notify(false);
      }
    };
    this.measureElement = (node) => {
      if (!node) {
        this.elementsCache.forEach((cached, key) => {
          if (!cached.isConnected) {
            this.observer.unobserve(cached);
            this.elementsCache.delete(key);
          }
        });
        return;
      }
      this._measureElement(node, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getVirtualIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k = 0, len = indexes.length; k < len; k++) {
          const i = indexes[k];
          const measurement = measurements[i];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: "getVirtualItems",
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset3) => {
      const measurements = this.getMeasurements();
      if (measurements.length === 0) {
        return void 0;
      }
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index) => notUndefined(measurements[index]).start,
          offset3
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
      const size3 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        align = toOffset >= scrollOffset + size3 ? "end" : "start";
      }
      if (align === "center") {
        toOffset += (itemSize - size3) / 2;
      } else if (align === "end") {
        toOffset -= size3;
      }
      const scrollSizeProp = this.options.horizontal ? "scrollWidth" : "scrollHeight";
      const scrollSize = this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;
      const maxOffset = scrollSize - size3;
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index, align = "auto") => {
      index = Math.max(0, Math.min(index, this.options.count - 1));
      const item = this.measurementsCache[index];
      if (!item) {
        return void 0;
      }
      const size3 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (item.end >= scrollOffset + size3 - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
      return [
        this.getOffsetForAlignment(toOffset, align, item.size),
        align
      ];
    };
    this.isDynamicMode = () => this.elementsCache.size > 0;
    this.cancelScrollToIndex = () => {
      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {
        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);
        this.scrollToIndexTimeoutId = null;
      }
    };
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index, { align: initialAlign = "auto", behavior } = {}) => {
      index = Math.max(0, Math.min(index, this.options.count - 1));
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      const offsetAndAlign = this.getOffsetForIndex(index, initialAlign);
      if (!offsetAndAlign) return;
      const [offset3, align] = offsetAndAlign;
      this._scrollToOffset(offset3, { adjustments: void 0, behavior });
      if (behavior !== "smooth" && this.isDynamicMode() && this.targetWindow) {
        this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {
          this.scrollToIndexTimeoutId = null;
          const elementInDOM = this.elementsCache.has(
            this.options.getItemKey(index)
          );
          if (elementInDOM) {
            const [latestOffset] = notUndefined(
              this.getOffsetForIndex(index, align)
            );
            if (!approxEqual(latestOffset, this.getScrollOffset())) {
              this.scrollToIndex(index, { align, behavior });
            }
          } else {
            this.scrollToIndex(index, { align, behavior });
          }
        });
      }
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getScrollOffset() + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else if (this.options.lanes === 1) {
        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;
      } else {
        const endByLane = Array(this.options.lanes).fill(null);
        let endIndex = measurements.length - 1;
        while (endIndex >= 0 && endByLane.some((val) => val === null)) {
          const item = measurements[endIndex];
          if (endByLane[item.lane] === null) {
            endByLane[item.lane] = item.end;
          }
          endIndex--;
        }
        end = Math.max(...endByLane.filter((val) => val !== null));
      }
      return Math.max(
        end - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    };
    this._scrollToOffset = (offset3, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset3, { behavior, adjustments }, this);
    };
    this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map();
      this.notify(false);
    };
    this.setOptions(opts);
  }
};
var findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset,
  lanes
}) {
  const lastIndex = measurements.length - 1;
  const getOffset = (index) => measurements[index].start;
  if (measurements.length <= lanes) {
    return {
      startIndex: 0,
      endIndex: lastIndex
    };
  }
  let startIndex = findNearestBinarySearch(
    0,
    lastIndex,
    getOffset,
    scrollOffset
  );
  let endIndex = startIndex;
  if (lanes === 1) {
    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {
      endIndex++;
    }
  } else if (lanes > 1) {
    const endPerLane = Array(lanes).fill(0);
    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {
      const item = measurements[endIndex];
      endPerLane[item.lane] = item.end;
      endIndex++;
    }
    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);
    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {
      const item = measurements[startIndex];
      startPerLane[item.lane] = item.start;
      startIndex--;
    }
    startIndex = Math.max(0, startIndex - startIndex % lanes);
    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
  }
  return { startIndex, endIndex };
}

// node_modules/@tanstack/vue-virtual/dist/esm/index.js
import { computed as computed42, unref as unref84, shallowRef as shallowRef4, watch as watch18, triggerRef, onScopeDispose as onScopeDispose3 } from "vue";
function useVirtualizerBase(options) {
  const virtualizer = new Virtualizer(unref84(options));
  const state = shallowRef4(virtualizer);
  const cleanup = virtualizer._didMount();
  watch18(
    () => unref84(options).getScrollElement(),
    (el) => {
      if (el) {
        virtualizer._willUpdate();
      }
    },
    {
      immediate: true
    }
  );
  watch18(
    () => unref84(options),
    (options2) => {
      virtualizer.setOptions({
        ...options2,
        onChange: (instance, sync) => {
          var _a;
          triggerRef(state);
          (_a = options2.onChange) == null ? void 0 : _a.call(options2, instance, sync);
        }
      });
      virtualizer._willUpdate();
      triggerRef(state);
    },
    {
      immediate: true
    }
  );
  onScopeDispose3(cleanup);
  return state;
}
function useVirtualizer(options) {
  return useVirtualizerBase(
    computed42(() => ({
      observeElementRect,
      observeElementOffset,
      scrollToFn: elementScroll,
      ...unref84(options)
    }))
  );
}

// node_modules/reka-ui/dist/Listbox/ListboxVirtualizer.js
var _sfc_main84 = defineComponent89({
  __name: "ListboxVirtualizer",
  props: {
    options: {},
    overscan: {},
    estimateSize: {},
    textContent: { type: Function }
  },
  setup(__props) {
    const props2 = __props;
    const slots = useSlots();
    const rootContext = injectListboxRootContext();
    const parentEl = useParentElement();
    const { getItems } = useCollection();
    rootContext.isVirtual.value = true;
    const padding = computed43(() => {
      const el = parentEl.value;
      if (!el) {
        return { start: 0, end: 0 };
      } else {
        const styles = window.getComputedStyle(el);
        return {
          start: Number.parseFloat(styles.paddingBlockStart || styles.paddingTop),
          end: Number.parseFloat(styles.paddingBlockEnd || styles.paddingBottom)
        };
      }
    });
    const virtualizer = useVirtualizer(
      {
        get scrollPaddingStart() {
          return padding.value.start;
        },
        get scrollPaddingEnd() {
          return padding.value.end;
        },
        get count() {
          return props2.options.length;
        },
        get horizontal() {
          return rootContext.orientation.value === "horizontal";
        },
        estimateSize() {
          return props2.estimateSize ?? 28;
        },
        getScrollElement() {
          return parentEl.value;
        },
        overscan: props2.overscan ?? 12
      }
    );
    const virtualizedItems = computed43(() => virtualizer.value.getVirtualItems().map((item) => {
      const defaultNode = slots.default({
        option: props2.options[item.index],
        virtualizer: virtualizer.value,
        virtualItem: item
      })[0];
      const targetNode = defaultNode.type === Fragment5 && Array.isArray(defaultNode.children) ? defaultNode.children[0] : defaultNode;
      return {
        item,
        is: cloneVNode2(targetNode, {
          "key": `${item.key}`,
          "data-index": item.index,
          "aria-setsize": props2.options.length,
          "aria-posinset": item.index + 1,
          "style": {
            position: "absolute",
            top: 0,
            left: 0,
            transform: `translateY(${item.start}px)`,
            overflowAnchor: "none"
          }
        })
      };
    }));
    rootContext.virtualFocusHook.on((event) => {
      const index = props2.options.findIndex((option) => {
        if (Array.isArray(rootContext.modelValue.value))
          return compare(option, rootContext.modelValue.value[0], rootContext.by);
        else
          return compare(option, rootContext.modelValue.value, rootContext.by);
      });
      if (index !== -1) {
        event?.preventDefault();
        virtualizer.value.scrollToIndex(index, { align: "start" });
        requestAnimationFrame(() => {
          const item = queryCheckedElement(parentEl.value);
          if (item) {
            rootContext.changeHighlight(item);
            if (event)
              item?.focus();
          }
        });
      } else {
        rootContext.highlightFirstItem(event);
      }
    });
    rootContext.virtualHighlightHook.on((value) => {
      const index = props2.options.findIndex((option) => {
        return compare(option, value, rootContext.by);
      });
      virtualizer.value.scrollToIndex(index, { align: "start" });
      requestAnimationFrame(() => {
        const item = queryCheckedElement(parentEl.value);
        if (item)
          rootContext.changeHighlight(item);
      });
    });
    const search = refAutoReset("", 1e3);
    const optionsWithMetadata = computed43(() => {
      const parseTextContent = (option) => {
        if (props2.textContent)
          return props2.textContent(option);
        else
          return option?.toString().toLowerCase();
      };
      return props2.options.map((option, index) => ({
        index,
        textContent: parseTextContent(option)
      }));
    });
    function handleMultipleReplace(event, intent) {
      if (!rootContext.firstValue?.value || !rootContext.multiple.value || !Array.isArray(rootContext.modelValue.value))
        return;
      const collection = getItems().filter((i) => i.ref.dataset.disabled !== "");
      const lastValue = collection.find((i) => i.ref === rootContext.highlightedElement.value)?.value;
      if (!lastValue)
        return;
      let value = null;
      switch (intent) {
        case "prev":
        case "next": {
          value = findValuesBetween(props2.options, rootContext.firstValue.value, lastValue);
          break;
        }
        case "first": {
          value = findValuesBetween(props2.options, rootContext.firstValue.value, props2.options?.[0]);
          break;
        }
        case "last": {
          value = findValuesBetween(props2.options, rootContext.firstValue.value, props2.options?.[props2.options.length - 1]);
          break;
        }
      }
      rootContext.modelValue.value = value;
    }
    rootContext.virtualKeydownHook.on((event) => {
      const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
      const isTabKey = event.key === "Tab" && !isMetaKey;
      if (isTabKey)
        return;
      let intent = MAP_KEY_TO_FOCUS_INTENT[event.key];
      if (isMetaKey && event.key === "a" && rootContext.multiple.value) {
        event.preventDefault();
        rootContext.modelValue.value = [...props2.options];
        intent = "last";
      } else if (event.shiftKey && intent) {
        handleMultipleReplace(event, intent);
      }
      if (["first", "last"].includes(intent)) {
        event.preventDefault();
        const index = intent === "first" ? 0 : props2.options.length - 1;
        virtualizer.value.scrollToIndex(index);
        requestAnimationFrame(() => {
          const items = getItems();
          const item = intent === "first" ? items[0] : items[items.length - 1];
          if (item)
            rootContext.changeHighlight(item.ref);
        });
      } else if (!intent && !isMetaKey) {
        search.value += event.key;
        const currentIndex = Number(getActiveElement()?.getAttribute("data-index"));
        const currentMatch = optionsWithMetadata.value[currentIndex].textContent;
        const filteredOptions = optionsWithMetadata.value.map((i) => i.textContent ?? "");
        const next = getNextMatch(filteredOptions, search.value, currentMatch);
        const nextMatch = optionsWithMetadata.value.find((option) => option.textContent === next);
        if (nextMatch) {
          virtualizer.value.scrollToIndex(nextMatch.index, { align: "start" });
          requestAnimationFrame(() => {
            const item = parentEl.value.querySelector(`[data-index="${nextMatch.index}"]`);
            if (item instanceof HTMLElement)
              rootContext.changeHighlight(item);
          });
        }
      }
    });
    return (_ctx, _cache) => {
      return openBlock81(), createElementBlock7("div", {
        "data-reka-virtualizer": "",
        style: normalizeStyle5({
          position: "relative",
          width: "100%",
          height: `${unref85(virtualizer).getTotalSize()}px`
        })
      }, [
        (openBlock81(true), createElementBlock7(Fragment5, null, renderList2(virtualizedItems.value, ({ is, item }) => {
          return openBlock81(), createBlock77(resolveDynamicComponent4(is), {
            key: item.index
          });
        }), 128))
      ], 4);
    };
  }
});

// node_modules/reka-ui/dist/Combobox/ComboboxVirtualizer.js
var _sfc_main85 = defineComponent90({
  __name: "ComboboxVirtualizer",
  props: {
    options: {},
    overscan: {},
    estimateSize: {},
    textContent: { type: Function }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectComboboxRootContext();
    rootContext.isVirtual.value = true;
    return (_ctx, _cache) => {
      return openBlock82(), createBlock78(_sfc_main84, normalizeProps16(guardReactiveProps14(props2)), {
        default: withCtx78((slotProps) => [
          renderSlot82(_ctx.$slots, "default", normalizeProps16(guardReactiveProps14(slotProps)))
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuArrow.js
import { defineComponent as defineComponent92, createBlock as createBlock80, openBlock as openBlock84, unref as unref87, normalizeProps as normalizeProps18, guardReactiveProps as guardReactiveProps16, withCtx as withCtx80, renderSlot as renderSlot84 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuArrow.js
import { defineComponent as defineComponent91, createBlock as createBlock79, openBlock as openBlock83, unref as unref86, normalizeProps as normalizeProps17, guardReactiveProps as guardReactiveProps15, withCtx as withCtx79, renderSlot as renderSlot83 } from "vue";
var _sfc_main86 = defineComponent91({
  __name: "MenuArrow",
  props: {
    width: {},
    height: {},
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock83(), createBlock79(unref86(_sfc_main62), normalizeProps17(guardReactiveProps15(props2)), {
        default: withCtx79(() => [
          renderSlot83(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuArrow.js
var _sfc_main87 = defineComponent92({
  __name: "ContextMenuArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock84(), createBlock80(unref87(_sfc_main86), normalizeProps18(guardReactiveProps16(props2)), {
        default: withCtx80(() => [
          renderSlot84(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuCheckboxItem.js
import { defineComponent as defineComponent99, createBlock as createBlock87, openBlock as openBlock91, unref as unref94, normalizeProps as normalizeProps19, guardReactiveProps as guardReactiveProps17, withCtx as withCtx87, renderSlot as renderSlot91 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuCheckboxItem.js
import { defineComponent as defineComponent98, createBlock as createBlock86, openBlock as openBlock90, mergeProps as mergeProps46, unref as unref93, withCtx as withCtx86, renderSlot as renderSlot90 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuItem.js
import { defineComponent as defineComponent96, ref as ref38, createBlock as createBlock84, openBlock as openBlock88, mergeProps as mergeProps45, unref as unref91, nextTick as nextTick16, withCtx as withCtx84, renderSlot as renderSlot88 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuItemImpl.js
import { defineComponent as defineComponent95, ref as ref37, createBlock as createBlock83, openBlock as openBlock87, unref as unref90, withCtx as withCtx83, createVNode as createVNode18, mergeProps as mergeProps44, nextTick as nextTick15, renderSlot as renderSlot87 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuContentImpl.js
import { defineComponent as defineComponent94, mergeDefaults as mergeDefaults2, toRefs as toRefs16, ref as ref36, watch as watch19, onUnmounted as onUnmounted10, createBlock as createBlock82, openBlock as openBlock86, unref as unref89, withCtx as withCtx82, createVNode as createVNode17, renderSlot as renderSlot86 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuRoot.js
import { defineComponent as defineComponent93, toRefs as toRefs15, ref as ref35, createBlock as createBlock81, openBlock as openBlock85, unref as unref88, withCtx as withCtx81, renderSlot as renderSlot85 } from "vue";

// node_modules/reka-ui/dist/shared/useIsUsingKeyboard.js
import { ref as ref34, onMounted as onMounted19 } from "vue";
function useIsUsingKeyboardImpl() {
  const isUsingKeyboard = ref34(false);
  onMounted19(() => {
    useEventListener("keydown", () => {
      isUsingKeyboard.value = true;
    }, { capture: true, passive: true });
    useEventListener(["pointerdown", "pointermove"], () => {
      isUsingKeyboard.value = false;
    }, { capture: true, passive: true });
  });
  return isUsingKeyboard;
}
var useIsUsingKeyboard = createSharedComposable(useIsUsingKeyboardImpl);

// node_modules/reka-ui/dist/Menu/MenuRoot.js
var [injectMenuContext, provideMenuContext] = createContext(["MenuRoot", "MenuSub"], "MenuContext");
var [injectMenuRootContext, provideMenuRootContext] = createContext("MenuRoot");
var _sfc_main88 = defineComponent93({
  __name: "MenuRoot",
  props: {
    open: { type: Boolean, default: false },
    dir: {},
    modal: { type: Boolean, default: true }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { modal, dir: propDir } = toRefs15(props2);
    const dir = useDirection(propDir);
    const open = useVModel(props2, "open", emits);
    const content = ref35();
    const isUsingKeyboardRef = useIsUsingKeyboard();
    provideMenuContext({
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      content,
      onContentChange: (element) => {
        content.value = element;
      }
    });
    provideMenuRootContext({
      onClose: () => {
        open.value = false;
      },
      isUsingKeyboardRef,
      dir,
      modal
    });
    return (_ctx, _cache) => {
      return openBlock85(), createBlock81(unref88(_sfc_main57), null, {
        default: withCtx81(() => [
          renderSlot85(_ctx.$slots, "default")
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/shared/useFocusGuards.js
import { watchEffect as watchEffect8 } from "vue";
var count2 = 0;
function useFocusGuards() {
  watchEffect8((cleanupFn) => {
    if (!isClient)
      return;
    const edgeGuards = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement(
      "afterbegin",
      edgeGuards[0] ?? createFocusGuard()
    );
    document.body.insertAdjacentElement(
      "beforeend",
      edgeGuards[1] ?? createFocusGuard()
    );
    count2++;
    cleanupFn(() => {
      if (count2 === 1) {
        document.querySelectorAll("[data-reka-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    });
  });
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-reka-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// node_modules/reka-ui/dist/Menu/MenuContentImpl.js
var [injectMenuContentContext, provideMenuContentContext] = createContext("MenuContent");
var _sfc_main89 = defineComponent94({
  __name: "MenuContentImpl",
  props: mergeDefaults2({
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  }, {
    ...PopperContentPropsDefaultValue
  }),
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus", "dismiss"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    const { trapFocus, disableOutsidePointerEvents, loop } = toRefs16(props2);
    useFocusGuards();
    useBodyScrollLock(disableOutsidePointerEvents.value);
    const searchRef = ref36("");
    const timerRef = ref36(0);
    const pointerGraceTimerRef = ref36(0);
    const pointerGraceIntentRef = ref36(null);
    const pointerDirRef = ref36("right");
    const lastPointerXRef = ref36(0);
    const currentItemId = ref36(null);
    const rovingFocusGroupRef = ref36();
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const { handleTypeaheadSearch } = useTypeahead();
    watch19(contentElement, (el) => {
      menuContext.onContentChange(el);
    });
    onUnmounted10(() => {
      window.clearTimeout(timerRef.value);
    });
    function isPointerMovingToSubmenu(event) {
      const isMovingTowards = pointerDirRef.value === pointerGraceIntentRef.value?.side;
      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.value?.area);
    }
    async function handleMountAutoFocus(event) {
      emits("openAutoFocus", event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
      contentElement.value?.focus({
        preventScroll: true
      });
    }
    function handleKeyDown(event) {
      if (event.defaultPrevented)
        return;
      const target = event.target;
      const isKeyDownInside = target.closest("[data-reka-menu-content]") === event.currentTarget;
      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
      const isCharacterKey = event.key.length === 1;
      const el = useArrowNavigation(
        event,
        getActiveElement(),
        contentElement.value,
        {
          loop: loop.value,
          arrowKeyOptions: "vertical",
          dir: rootContext?.dir.value,
          focus: true,
          attributeName: "[data-reka-collection-item]:not([data-disabled])"
        }
      );
      if (el)
        return el?.focus();
      if (event.code === "Space")
        return;
      const collectionItems = rovingFocusGroupRef.value?.getItems() ?? [];
      if (isKeyDownInside) {
        if (event.key === "Tab")
          event.preventDefault();
        if (!isModifierKey && isCharacterKey)
          handleTypeaheadSearch(event.key, collectionItems);
      }
      if (event.target !== contentElement.value)
        return;
      if (!FIRST_LAST_KEYS.includes(event.key))
        return;
      event.preventDefault();
      const candidateNodes = [...collectionItems.map((item) => item.ref)];
      if (LAST_KEYS.includes(event.key))
        candidateNodes.reverse();
      focusFirst(candidateNodes);
    }
    function handleBlur(event) {
      if (!event?.currentTarget?.contains?.(event.target)) {
        window.clearTimeout(timerRef.value);
        searchRef.value = "";
      }
    }
    function handlePointerMove2(event) {
      if (!isMouseEvent(event))
        return;
      const target = event.target;
      const pointerXHasChanged = lastPointerXRef.value !== event.clientX;
      if (event?.currentTarget?.contains(target) && pointerXHasChanged) {
        const newDir = event.clientX > lastPointerXRef.value ? "right" : "left";
        pointerDirRef.value = newDir;
        lastPointerXRef.value = event.clientX;
      }
    }
    provideMenuContentContext({
      onItemEnter: (event) => {
        if (isPointerMovingToSubmenu(event))
          return true;
        else
          return false;
      },
      onItemLeave: (event) => {
        if (isPointerMovingToSubmenu(event))
          return;
        contentElement.value?.focus();
        currentItemId.value = null;
      },
      onTriggerLeave: (event) => {
        if (isPointerMovingToSubmenu(event))
          return true;
        else
          return false;
      },
      searchRef,
      pointerGraceTimerRef,
      onPointerGraceIntentChange: (intent) => {
        pointerGraceIntentRef.value = intent;
      }
    });
    return (_ctx, _cache) => {
      return openBlock86(), createBlock82(unref89(_sfc_main15), {
        "as-child": "",
        trapped: unref89(trapFocus),
        onMountAutoFocus: handleMountAutoFocus,
        onUnmountAutoFocus: _cache[7] || (_cache[7] = ($event) => emits("closeAutoFocus", $event))
      }, {
        default: withCtx82(() => [
          createVNode17(unref89(_sfc_main14), {
            "as-child": "",
            "disable-outside-pointer-events": unref89(disableOutsidePointerEvents),
            onEscapeKeyDown: _cache[2] || (_cache[2] = ($event) => emits("escapeKeyDown", $event)),
            onPointerDownOutside: _cache[3] || (_cache[3] = ($event) => emits("pointerDownOutside", $event)),
            onFocusOutside: _cache[4] || (_cache[4] = ($event) => emits("focusOutside", $event)),
            onInteractOutside: _cache[5] || (_cache[5] = ($event) => emits("interactOutside", $event)),
            onDismiss: _cache[6] || (_cache[6] = ($event) => emits("dismiss"))
          }, {
            default: withCtx82(() => [
              createVNode17(unref89(_sfc_main50), {
                ref_key: "rovingFocusGroupRef",
                ref: rovingFocusGroupRef,
                "current-tab-stop-id": currentItemId.value,
                "onUpdate:currentTabStopId": _cache[0] || (_cache[0] = ($event) => currentItemId.value = $event),
                "as-child": "",
                orientation: "vertical",
                dir: unref89(rootContext).dir.value,
                loop: unref89(loop),
                onEntryFocus: _cache[1] || (_cache[1] = (event) => {
                  emits("entryFocus", event);
                  if (!unref89(rootContext).isUsingKeyboardRef.value) event.preventDefault();
                })
              }, {
                default: withCtx82(() => [
                  createVNode17(unref89(_sfc_main61), {
                    ref: unref89(forwardRef),
                    role: "menu",
                    as: _ctx.as,
                    "as-child": _ctx.asChild,
                    "aria-orientation": "vertical",
                    "data-reka-menu-content": "",
                    "data-state": unref89(getOpenState)(unref89(menuContext).open.value),
                    dir: unref89(rootContext).dir.value,
                    side: _ctx.side,
                    "side-offset": _ctx.sideOffset,
                    align: _ctx.align,
                    "align-offset": _ctx.alignOffset,
                    "avoid-collisions": _ctx.avoidCollisions,
                    "collision-boundary": _ctx.collisionBoundary,
                    "collision-padding": _ctx.collisionPadding,
                    "arrow-padding": _ctx.arrowPadding,
                    "prioritize-position": _ctx.prioritizePosition,
                    "position-strategy": _ctx.positionStrategy,
                    "update-position-strategy": _ctx.updatePositionStrategy,
                    sticky: _ctx.sticky,
                    "hide-when-detached": _ctx.hideWhenDetached,
                    reference: _ctx.reference,
                    onKeydown: handleKeyDown,
                    onBlur: handleBlur,
                    onPointermove: handlePointerMove2
                  }, {
                    default: withCtx82(() => [
                      renderSlot86(_ctx.$slots, "default")
                    ]),
                    _: 3
                  }, 8, ["as", "as-child", "data-state", "dir", "side", "side-offset", "align", "align-offset", "avoid-collisions", "collision-boundary", "collision-padding", "arrow-padding", "prioritize-position", "position-strategy", "update-position-strategy", "sticky", "hide-when-detached", "reference"])
                ]),
                _: 3
              }, 8, ["current-tab-stop-id", "dir", "loop"])
            ]),
            _: 3
          }, 8, ["disable-outside-pointer-events"])
        ]),
        _: 3
      }, 8, ["trapped"]);
    };
  }
});

// node_modules/reka-ui/dist/Menu/MenuItemImpl.js
var _sfc_main90 = defineComponent95({
  ...{
    inheritAttrs: false
  },
  __name: "MenuItemImpl",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const contentContext = injectMenuContentContext();
    const { forwardRef } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const isFocused = ref37(false);
    async function handlePointerMove2(event) {
      if (event.defaultPrevented)
        return;
      if (!isMouseEvent(event))
        return;
      if (props2.disabled) {
        contentContext.onItemLeave(event);
      } else {
        const defaultPrevented = contentContext.onItemEnter(event);
        if (!defaultPrevented) {
          const item = event.currentTarget;
          item?.focus({ preventScroll: true });
        }
      }
    }
    async function handlePointerLeave(event) {
      await nextTick15();
      if (event.defaultPrevented)
        return;
      if (!isMouseEvent(event))
        return;
      contentContext.onItemLeave(event);
    }
    return (_ctx, _cache) => {
      return openBlock87(), createBlock83(unref90(CollectionItem), {
        value: { textValue: _ctx.textValue }
      }, {
        default: withCtx83(() => [
          createVNode18(unref90(Primitive), mergeProps44({
            ref: unref90(forwardRef),
            role: "menuitem",
            tabindex: "-1"
          }, _ctx.$attrs, {
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "aria-disabled": _ctx.disabled || void 0,
            "data-disabled": _ctx.disabled ? "" : void 0,
            "data-highlighted": isFocused.value ? "" : void 0,
            onPointermove: handlePointerMove2,
            onPointerleave: handlePointerLeave,
            onFocus: _cache[0] || (_cache[0] = async (event) => {
              await nextTick15();
              if (event.defaultPrevented || _ctx.disabled) return;
              isFocused.value = true;
            }),
            onBlur: _cache[1] || (_cache[1] = async (event) => {
              await nextTick15();
              if (event.defaultPrevented) return;
              isFocused.value = false;
            })
          }), {
            default: withCtx83(() => [
              renderSlot87(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child", "aria-disabled", "data-disabled", "data-highlighted"])
        ]),
        _: 3
      }, 8, ["value"]);
    };
  }
});

// node_modules/reka-ui/dist/Menu/MenuItem.js
var _sfc_main91 = defineComponent96({
  __name: "MenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectMenuRootContext();
    const contentContext = injectMenuContentContext();
    const isPointerDownRef = ref38(false);
    async function handleSelect2() {
      const menuItem = currentElement.value;
      if (!props2.disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, {
          bubbles: true,
          cancelable: true
        });
        emits("select", itemSelectEvent);
        await nextTick16();
        if (itemSelectEvent.defaultPrevented)
          isPointerDownRef.value = false;
        else rootContext.onClose();
      }
    }
    return (_ctx, _cache) => {
      return openBlock88(), createBlock84(_sfc_main90, mergeProps45(props2, {
        ref: unref91(forwardRef),
        onClick: handleSelect2,
        onPointerdown: _cache[0] || (_cache[0] = () => {
          isPointerDownRef.value = true;
        }),
        onPointerup: _cache[1] || (_cache[1] = async (event) => {
          await nextTick16();
          if (event.defaultPrevented) return;
          if (!isPointerDownRef.value) event.currentTarget?.click();
        }),
        onKeydown: _cache[2] || (_cache[2] = async (event) => {
          const isTypingAhead = unref91(contentContext).searchRef.value !== "";
          if (_ctx.disabled || isTypingAhead && event.key === " ") return;
          if (unref91(SELECTION_KEYS).includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }), {
        default: withCtx84(() => [
          renderSlot88(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menu/MenuItemIndicator.js
import { defineComponent as defineComponent97, ref as ref39, createBlock as createBlock85, openBlock as openBlock89, unref as unref92, withCtx as withCtx85, createVNode as createVNode19, renderSlot as renderSlot89 } from "vue";
var [injectMenuItemIndicatorContext, provideMenuItemIndicatorContext] = createContext(
  ["MenuCheckboxItem", "MenuRadioItem"],
  "MenuItemIndicatorContext"
);
var _sfc_main92 = defineComponent97({
  __name: "MenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const indicatorContext = injectMenuItemIndicatorContext({
      modelValue: ref39(false)
    });
    return (_ctx, _cache) => {
      return openBlock89(), createBlock85(unref92(Presence), {
        present: _ctx.forceMount || unref92(isIndeterminate)(unref92(indicatorContext).modelValue.value) || unref92(indicatorContext).modelValue.value === true
      }, {
        default: withCtx85(() => [
          createVNode19(unref92(Primitive), {
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "data-state": unref92(getCheckedState)(unref92(indicatorContext).modelValue.value)
          }, {
            default: withCtx85(() => [
              renderSlot89(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["as", "as-child", "data-state"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/Menu/MenuCheckboxItem.js
var _sfc_main93 = defineComponent98({
  __name: "MenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String], default: false },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const modelValue = useVModel(props2, "modelValue", emits);
    provideMenuItemIndicatorContext({ modelValue });
    return (_ctx, _cache) => {
      return openBlock90(), createBlock86(_sfc_main91, mergeProps46({ role: "menuitemcheckbox" }, props2, {
        "aria-checked": unref93(isIndeterminate)(unref93(modelValue)) ? "mixed" : unref93(modelValue),
        "data-state": unref93(getCheckedState)(unref93(modelValue)),
        onSelect: _cache[0] || (_cache[0] = async (event) => {
          emits("select", event);
          if (unref93(isIndeterminate)(unref93(modelValue))) {
            modelValue.value = true;
          } else {
            modelValue.value = !unref93(modelValue);
          }
        })
      }), {
        default: withCtx86(() => [
          renderSlot90(_ctx.$slots, "default", { modelValue: unref93(modelValue) })
        ]),
        _: 3
      }, 16, ["aria-checked", "data-state"]);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuCheckboxItem.js
var _sfc_main94 = defineComponent99({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock91(), createBlock87(unref94(_sfc_main93), normalizeProps19(guardReactiveProps17({ ...props2, ...unref94(emitsAsProps) })), {
        default: withCtx87(() => [
          renderSlot91(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuContent.js
import { defineComponent as defineComponent104, ref as ref41, createBlock as createBlock92, openBlock as openBlock96, unref as unref99, mergeProps as mergeProps50, withCtx as withCtx92, renderSlot as renderSlot96 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuContent.js
import { defineComponent as defineComponent102, createBlock as createBlock90, openBlock as openBlock94, unref as unref97, withCtx as withCtx90, normalizeProps as normalizeProps20, mergeProps as mergeProps49, renderSlot as renderSlot94 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuRootContentModal.js
import { defineComponent as defineComponent100, createBlock as createBlock88, openBlock as openBlock92, mergeProps as mergeProps47, unref as unref95, withModifiers as withModifiers8, withCtx as withCtx88, renderSlot as renderSlot92 } from "vue";
var _sfc_main95 = defineComponent100({
  __name: "MenuRootContentModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const menuContext = injectMenuContext();
    const { forwardRef, currentElement } = useForwardExpose();
    useHideOthers(currentElement);
    return (_ctx, _cache) => {
      return openBlock92(), createBlock88(_sfc_main89, mergeProps47(unref95(forwarded), {
        ref: unref95(forwardRef),
        "trap-focus": unref95(menuContext).open.value,
        "disable-outside-pointer-events": unref95(menuContext).open.value,
        "disable-outside-scroll": true,
        onDismiss: _cache[0] || (_cache[0] = ($event) => unref95(menuContext).onOpenChange(false)),
        onFocusOutside: _cache[1] || (_cache[1] = withModifiers8(($event) => emits("focusOutside", $event), ["prevent"]))
      }), {
        default: withCtx88(() => [
          renderSlot92(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["trap-focus", "disable-outside-pointer-events"]);
    };
  }
});

// node_modules/reka-ui/dist/Menu/MenuRootContentNonModal.js
import { defineComponent as defineComponent101, createBlock as createBlock89, openBlock as openBlock93, mergeProps as mergeProps48, unref as unref96, withCtx as withCtx89, renderSlot as renderSlot93 } from "vue";
var _sfc_main96 = defineComponent101({
  __name: "MenuRootContentNonModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const menuContext = injectMenuContext();
    return (_ctx, _cache) => {
      return openBlock93(), createBlock89(_sfc_main89, mergeProps48(unref96(forwarded), {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        "disable-outside-scroll": false,
        onDismiss: _cache[0] || (_cache[0] = ($event) => unref96(menuContext).onOpenChange(false))
      }), {
        default: withCtx89(() => [
          renderSlot93(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menu/MenuContent.js
var _sfc_main97 = defineComponent102({
  __name: "MenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    return (_ctx, _cache) => {
      return openBlock94(), createBlock90(unref97(Presence), {
        present: _ctx.forceMount || unref97(menuContext).open.value
      }, {
        default: withCtx90(() => [
          unref97(rootContext).modal.value ? (openBlock94(), createBlock90(_sfc_main95, normalizeProps20(mergeProps49({ key: 0 }, { ..._ctx.$attrs, ...unref97(forwarded) })), {
            default: withCtx90(() => [
              renderSlot94(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)) : (openBlock94(), createBlock90(_sfc_main96, normalizeProps20(mergeProps49({ key: 1 }, { ..._ctx.$attrs, ...unref97(forwarded) })), {
            default: withCtx90(() => [
              renderSlot94(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuRoot.js
import { defineComponent as defineComponent103, toRefs as toRefs17, ref as ref40, watch as watch20, createBlock as createBlock91, openBlock as openBlock95, unref as unref98, withCtx as withCtx91, renderSlot as renderSlot95 } from "vue";
var [injectContextMenuRootContext, provideContextMenuRootContext] = createContext("ContextMenuRoot");
var _sfc_main98 = defineComponent103({
  ...{
    inheritAttrs: false
  },
  __name: "ContextMenuRoot",
  props: {
    dir: {},
    modal: { type: Boolean, default: true }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { dir: propDir, modal } = toRefs17(props2);
    useForwardExpose();
    const dir = useDirection(propDir);
    const open = ref40(false);
    const triggerElement = ref40();
    provideContextMenuRootContext({
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      dir,
      modal,
      triggerElement
    });
    watch20(open, (value) => {
      emits("update:open", value);
    });
    return (_ctx, _cache) => {
      return openBlock95(), createBlock91(unref98(_sfc_main88), {
        open: open.value,
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => open.value = $event),
        dir: unref98(dir),
        modal: unref98(modal)
      }, {
        default: withCtx91(() => [
          renderSlot95(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["open", "dir", "modal"]);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuContent.js
var _sfc_main99 = defineComponent104({
  __name: "ContextMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    alignOffset: { default: 0 },
    avoidCollisions: { type: Boolean, default: true },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: false },
    positionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    const rootContext = injectContextMenuRootContext();
    const hasInteractedOutside = ref41(false);
    return (_ctx, _cache) => {
      return openBlock96(), createBlock92(unref99(_sfc_main97), mergeProps50(unref99(forwarded), {
        side: "right",
        "side-offset": 2,
        align: "start",
        "update-position-strategy": "always",
        style: {
          "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
          "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
          "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          if (!event.defaultPrevented && hasInteractedOutside.value) {
            event.preventDefault();
          }
          hasInteractedOutside.value = false;
        }),
        onInteractOutside: _cache[1] || (_cache[1] = (event) => {
          const originalEvent = event.detail.originalEvent;
          if (originalEvent.button === 2 && event.target === unref99(rootContext).triggerElement.value) {
            event.preventDefault();
          }
          if (!event.defaultPrevented && !unref99(rootContext).modal.value)
            hasInteractedOutside.value = true;
        })
      }), {
        default: withCtx92(() => [
          renderSlot96(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuGroup.js
import { defineComponent as defineComponent106, createBlock as createBlock94, openBlock as openBlock98, unref as unref101, normalizeProps as normalizeProps21, guardReactiveProps as guardReactiveProps18, withCtx as withCtx94, renderSlot as renderSlot98 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuGroup.js
import { defineComponent as defineComponent105, createBlock as createBlock93, openBlock as openBlock97, unref as unref100, mergeProps as mergeProps51, withCtx as withCtx93, renderSlot as renderSlot97 } from "vue";
var _sfc_main100 = defineComponent105({
  __name: "MenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock97(), createBlock93(unref100(Primitive), mergeProps51({ role: "group" }, props2), {
        default: withCtx93(() => [
          renderSlot97(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuGroup.js
var _sfc_main101 = defineComponent106({
  __name: "ContextMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock98(), createBlock94(unref101(_sfc_main100), normalizeProps21(guardReactiveProps18(props2)), {
        default: withCtx94(() => [
          renderSlot98(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuItem.js
import { defineComponent as defineComponent107, createBlock as createBlock95, openBlock as openBlock99, unref as unref102, normalizeProps as normalizeProps22, guardReactiveProps as guardReactiveProps19, withCtx as withCtx95, renderSlot as renderSlot99 } from "vue";
var _sfc_main102 = defineComponent107({
  __name: "ContextMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock99(), createBlock95(unref102(_sfc_main91), normalizeProps22(guardReactiveProps19({ ...props2, ...unref102(emitsAsProps) })), {
        default: withCtx95(() => [
          renderSlot99(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuItemIndicator.js
import { defineComponent as defineComponent108, createBlock as createBlock96, openBlock as openBlock100, unref as unref103, normalizeProps as normalizeProps23, guardReactiveProps as guardReactiveProps20, withCtx as withCtx96, renderSlot as renderSlot100 } from "vue";
var _sfc_main103 = defineComponent108({
  __name: "ContextMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock100(), createBlock96(unref103(_sfc_main92), normalizeProps23(guardReactiveProps20(props2)), {
        default: withCtx96(() => [
          renderSlot100(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuLabel.js
import { defineComponent as defineComponent110, createBlock as createBlock98, openBlock as openBlock102, unref as unref105, normalizeProps as normalizeProps25, guardReactiveProps as guardReactiveProps22, withCtx as withCtx98, renderSlot as renderSlot102 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuLabel.js
import { defineComponent as defineComponent109, createBlock as createBlock97, openBlock as openBlock101, unref as unref104, normalizeProps as normalizeProps24, guardReactiveProps as guardReactiveProps21, withCtx as withCtx97, renderSlot as renderSlot101 } from "vue";
var _sfc_main104 = defineComponent109({
  __name: "MenuLabel",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock101(), createBlock97(unref104(Primitive), normalizeProps24(guardReactiveProps21(props2)), {
        default: withCtx97(() => [
          renderSlot101(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuLabel.js
var _sfc_main105 = defineComponent110({
  __name: "ContextMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock102(), createBlock98(unref105(_sfc_main104), normalizeProps25(guardReactiveProps22(props2)), {
        default: withCtx98(() => [
          renderSlot102(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuPortal.js
import { defineComponent as defineComponent112, createBlock as createBlock100, openBlock as openBlock104, unref as unref107, normalizeProps as normalizeProps27, guardReactiveProps as guardReactiveProps24, withCtx as withCtx100, renderSlot as renderSlot104 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuPortal.js
import { defineComponent as defineComponent111, createBlock as createBlock99, openBlock as openBlock103, unref as unref106, normalizeProps as normalizeProps26, guardReactiveProps as guardReactiveProps23, withCtx as withCtx99, renderSlot as renderSlot103 } from "vue";
var _sfc_main106 = defineComponent111({
  __name: "MenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock103(), createBlock99(unref106(_sfc_main27), normalizeProps26(guardReactiveProps23(props2)), {
        default: withCtx99(() => [
          renderSlot103(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuPortal.js
var _sfc_main107 = defineComponent112({
  __name: "ContextMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock104(), createBlock100(unref107(_sfc_main106), normalizeProps27(guardReactiveProps24(props2)), {
        default: withCtx100(() => [
          renderSlot104(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuRadioGroup.js
import { defineComponent as defineComponent114, createBlock as createBlock102, openBlock as openBlock106, unref as unref109, normalizeProps as normalizeProps29, guardReactiveProps as guardReactiveProps26, withCtx as withCtx102, renderSlot as renderSlot106 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuRadioGroup.js
import { defineComponent as defineComponent113, createBlock as createBlock101, openBlock as openBlock105, normalizeProps as normalizeProps28, guardReactiveProps as guardReactiveProps25, withCtx as withCtx101, renderSlot as renderSlot105, unref as unref108 } from "vue";
var [injectMenuRadioGroupContext, provideMenuRadioGroupContext] = createContext("MenuRadioGroup");
var _sfc_main108 = defineComponent113({
  __name: "MenuRadioGroup",
  props: {
    modelValue: { default: "" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const modelValue = useVModel(props2, "modelValue", emits);
    provideMenuRadioGroupContext({
      modelValue,
      onValueChange: (payload) => {
        modelValue.value = payload;
      }
    });
    return (_ctx, _cache) => {
      return openBlock105(), createBlock101(_sfc_main100, normalizeProps28(guardReactiveProps25(props2)), {
        default: withCtx101(() => [
          renderSlot105(_ctx.$slots, "default", { modelValue: unref108(modelValue) })
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuRadioGroup.js
var _sfc_main109 = defineComponent114({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock106(), createBlock102(unref109(_sfc_main108), normalizeProps29(guardReactiveProps26({ ...props2, ...unref109(emitsAsProps) })), {
        default: withCtx102(() => [
          renderSlot106(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuRadioItem.js
import { defineComponent as defineComponent116, createBlock as createBlock104, openBlock as openBlock108, unref as unref111, normalizeProps as normalizeProps30, guardReactiveProps as guardReactiveProps27, withCtx as withCtx104, renderSlot as renderSlot108 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuRadioItem.js
import { defineComponent as defineComponent115, toRefs as toRefs18, computed as computed44, createBlock as createBlock103, openBlock as openBlock107, mergeProps as mergeProps52, unref as unref110, withCtx as withCtx103, renderSlot as renderSlot107 } from "vue";
var _sfc_main110 = defineComponent115({
  __name: "MenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { value } = toRefs18(props2);
    const radioGroupContext = injectMenuRadioGroupContext();
    const modelValue = computed44(
      () => radioGroupContext.modelValue.value === value?.value
    );
    provideMenuItemIndicatorContext({ modelValue });
    return (_ctx, _cache) => {
      return openBlock107(), createBlock103(_sfc_main91, mergeProps52({ role: "menuitemradio" }, props2, {
        "aria-checked": modelValue.value,
        "data-state": unref110(getCheckedState)(modelValue.value),
        onSelect: _cache[0] || (_cache[0] = async (event) => {
          emits("select", event);
          unref110(radioGroupContext).onValueChange(unref110(value));
        })
      }), {
        default: withCtx103(() => [
          renderSlot107(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-checked", "data-state"]);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuRadioItem.js
var _sfc_main111 = defineComponent116({
  __name: "ContextMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock108(), createBlock104(unref111(_sfc_main110), normalizeProps30(guardReactiveProps27({ ...props2, ...unref111(emitsAsProps) })), {
        default: withCtx104(() => [
          renderSlot108(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSeparator.js
import { defineComponent as defineComponent118, createBlock as createBlock106, openBlock as openBlock110, unref as unref113, normalizeProps as normalizeProps31, guardReactiveProps as guardReactiveProps28, withCtx as withCtx106, renderSlot as renderSlot110 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuSeparator.js
import { defineComponent as defineComponent117, createBlock as createBlock105, openBlock as openBlock109, unref as unref112, mergeProps as mergeProps53, withCtx as withCtx105, renderSlot as renderSlot109 } from "vue";
var _sfc_main112 = defineComponent117({
  __name: "MenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock109(), createBlock105(unref112(Primitive), mergeProps53(props2, {
        role: "separator",
        "aria-orientation": "horizontal"
      }), {
        default: withCtx105(() => [
          renderSlot109(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSeparator.js
var _sfc_main113 = defineComponent118({
  __name: "ContextMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock110(), createBlock106(unref113(_sfc_main112), normalizeProps31(guardReactiveProps28(props2)), {
        default: withCtx106(() => [
          renderSlot110(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSub.js
import { defineComponent as defineComponent120, createBlock as createBlock108, openBlock as openBlock112, unref as unref115, isRef as isRef5, withCtx as withCtx108, renderSlot as renderSlot112 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuSub.js
import { defineComponent as defineComponent119, ref as ref42, watchEffect as watchEffect9, createBlock as createBlock107, openBlock as openBlock111, unref as unref114, withCtx as withCtx107, renderSlot as renderSlot111 } from "vue";
var [injectMenuSubContext, provideMenuSubContext] = createContext("MenuSub");
var _sfc_main114 = defineComponent119({
  __name: "MenuSub",
  props: {
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const open = useVModel(props2, "open", emits, {
      defaultValue: false,
      passive: props2.open === void 0
    });
    const parentMenuContext = injectMenuContext();
    const trigger = ref42();
    const content = ref42();
    watchEffect9((cleanupFn) => {
      if (parentMenuContext?.open.value === false)
        open.value = false;
      cleanupFn(() => open.value = false);
    });
    provideMenuContext({
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      content,
      onContentChange: (element) => {
        content.value = element;
      }
    });
    provideMenuSubContext({
      triggerId: "",
      contentId: "",
      trigger,
      onTriggerChange: (element) => {
        trigger.value = element;
      }
    });
    return (_ctx, _cache) => {
      return openBlock111(), createBlock107(unref114(_sfc_main57), null, {
        default: withCtx107(() => [
          renderSlot111(_ctx.$slots, "default")
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSub.js
var _sfc_main115 = defineComponent120({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    useForwardExpose();
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    return (_ctx, _cache) => {
      return openBlock112(), createBlock108(unref115(_sfc_main114), {
        open: unref115(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef5(open) ? open.value = $event : null)
      }, {
        default: withCtx108(() => [
          renderSlot112(_ctx.$slots, "default", { open: unref115(open) })
        ]),
        _: 3
      }, 8, ["open"]);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSubContent.js
import { defineComponent as defineComponent122, createBlock as createBlock110, openBlock as openBlock114, unref as unref117, mergeProps as mergeProps55, withCtx as withCtx110, renderSlot as renderSlot114 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuSubContent.js
import { defineComponent as defineComponent121, createBlock as createBlock109, openBlock as openBlock113, unref as unref116, withCtx as withCtx109, createVNode as createVNode20, mergeProps as mergeProps54, withModifiers as withModifiers9, renderSlot as renderSlot113 } from "vue";
var _sfc_main116 = defineComponent121({
  __name: "MenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean, default: true },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    const menuSubContext = injectMenuSubContext();
    const { forwardRef, currentElement: subContentElement } = useForwardExpose();
    menuSubContext.contentId ||= useId2(void 0, "reka-menu-sub-content");
    return (_ctx, _cache) => {
      return openBlock113(), createBlock109(unref116(Presence), {
        present: _ctx.forceMount || unref116(menuContext).open.value
      }, {
        default: withCtx109(() => [
          createVNode20(_sfc_main89, mergeProps54(unref116(forwarded), {
            id: unref116(menuSubContext).contentId,
            ref: unref116(forwardRef),
            "aria-labelledby": unref116(menuSubContext).triggerId,
            align: "start",
            side: unref116(rootContext).dir.value === "rtl" ? "left" : "right",
            "disable-outside-pointer-events": false,
            "disable-outside-scroll": false,
            "trap-focus": false,
            onOpenAutoFocus: _cache[0] || (_cache[0] = withModifiers9((event) => {
              if (unref116(rootContext).isUsingKeyboardRef.value) unref116(subContentElement)?.focus();
            }, ["prevent"])),
            onCloseAutoFocus: _cache[1] || (_cache[1] = withModifiers9(() => {
            }, ["prevent"])),
            onFocusOutside: _cache[2] || (_cache[2] = (event) => {
              if (event.defaultPrevented) return;
              if (event.target !== unref116(menuSubContext).trigger.value)
                unref116(menuContext).onOpenChange(false);
            }),
            onEscapeKeyDown: _cache[3] || (_cache[3] = (event) => {
              unref116(rootContext).onClose();
              event.preventDefault();
            }),
            onKeydown: _cache[4] || (_cache[4] = (event) => {
              const isKeyDownInside = event.currentTarget?.contains(event.target);
              const isCloseKey = unref116(SUB_CLOSE_KEYS)[unref116(rootContext).dir.value].includes(event.key);
              if (isKeyDownInside && isCloseKey) {
                unref116(menuContext).onOpenChange(false);
                unref116(menuSubContext).trigger.value?.focus();
                event.preventDefault();
              }
            })
          }), {
            default: withCtx109(() => [
              renderSlot113(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["id", "aria-labelledby", "side"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSubContent.js
var _sfc_main117 = defineComponent122({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock114(), createBlock110(unref117(_sfc_main116), mergeProps55(unref117(forwarded), { style: {
        "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: withCtx110(() => [
          renderSlot114(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSubTrigger.js
import { defineComponent as defineComponent125, createBlock as createBlock113, openBlock as openBlock117, unref as unref120, normalizeProps as normalizeProps33, guardReactiveProps as guardReactiveProps30, withCtx as withCtx113, renderSlot as renderSlot117 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuSubTrigger.js
import { defineComponent as defineComponent124, ref as ref43, onUnmounted as onUnmounted11, createBlock as createBlock112, openBlock as openBlock116, withCtx as withCtx112, createVNode as createVNode21, mergeProps as mergeProps56, unref as unref119, renderSlot as renderSlot116, nextTick as nextTick17 } from "vue";

// node_modules/reka-ui/dist/Menu/MenuAnchor.js
import { defineComponent as defineComponent123, createBlock as createBlock111, openBlock as openBlock115, unref as unref118, normalizeProps as normalizeProps32, guardReactiveProps as guardReactiveProps29, withCtx as withCtx111, renderSlot as renderSlot115 } from "vue";
var _sfc_main118 = defineComponent123({
  __name: "MenuAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock115(), createBlock111(unref118(_sfc_main58), normalizeProps32(guardReactiveProps29(props2)), {
        default: withCtx111(() => [
          renderSlot115(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menu/MenuSubTrigger.js
var _sfc_main119 = defineComponent124({
  __name: "MenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    const subContext = injectMenuSubContext();
    const contentContext = injectMenuContentContext();
    const openTimerRef = ref43(null);
    subContext.triggerId ||= useId2(void 0, "reka-menu-sub-trigger");
    function clearOpenTimer() {
      if (openTimerRef.value)
        window.clearTimeout(openTimerRef.value);
      openTimerRef.value = null;
    }
    onUnmounted11(() => {
      clearOpenTimer();
    });
    function handlePointerMove2(event) {
      if (!isMouseEvent(event))
        return;
      const defaultPrevented = contentContext.onItemEnter(event);
      if (defaultPrevented)
        return;
      if (!props2.disabled && !menuContext.open.value && !openTimerRef.value) {
        contentContext.onPointerGraceIntentChange(null);
        openTimerRef.value = window.setTimeout(() => {
          menuContext.onOpenChange(true);
          clearOpenTimer();
        }, 100);
      }
    }
    async function handlePointerLeave(event) {
      if (!isMouseEvent(event))
        return;
      clearOpenTimer();
      const contentRect = menuContext.content.value?.getBoundingClientRect();
      if (contentRect?.width) {
        const side = menuContext.content.value?.dataset.side;
        const rightSide = side === "right";
        const bleed = rightSide ? -5 : 5;
        const contentNearEdge = contentRect[rightSide ? "left" : "right"];
        const contentFarEdge = contentRect[rightSide ? "right" : "left"];
        contentContext.onPointerGraceIntentChange({
          area: [
            // Apply a bleed on clientX to ensure that our exit point is
            // consistently within polygon bounds
            { x: event.clientX + bleed, y: event.clientY },
            { x: contentNearEdge, y: contentRect.top },
            { x: contentFarEdge, y: contentRect.top },
            { x: contentFarEdge, y: contentRect.bottom },
            { x: contentNearEdge, y: contentRect.bottom }
          ],
          side
        });
        window.clearTimeout(contentContext.pointerGraceTimerRef.value);
        contentContext.pointerGraceTimerRef.value = window.setTimeout(
          () => contentContext.onPointerGraceIntentChange(null),
          300
        );
      } else {
        const defaultPrevented = contentContext.onTriggerLeave(event);
        if (defaultPrevented)
          return;
        contentContext.onPointerGraceIntentChange(null);
      }
    }
    async function handleKeyDown(event) {
      const isTypingAhead = contentContext.searchRef.value !== "";
      if (props2.disabled || isTypingAhead && event.key === " ")
        return;
      if (SUB_OPEN_KEYS[rootContext.dir.value].includes(event.key)) {
        menuContext.onOpenChange(true);
        await nextTick17();
        menuContext.content.value?.focus();
        event.preventDefault();
      }
    }
    return (_ctx, _cache) => {
      return openBlock116(), createBlock112(_sfc_main118, { "as-child": "" }, {
        default: withCtx112(() => [
          createVNode21(_sfc_main90, mergeProps56(props2, {
            id: unref119(subContext).triggerId,
            ref: (vnode) => {
              unref119(subContext)?.onTriggerChange(vnode?.$el);
              return void 0;
            },
            "aria-haspopup": "menu",
            "aria-expanded": unref119(menuContext).open.value,
            "aria-controls": unref119(subContext).contentId,
            "data-state": unref119(getOpenState)(unref119(menuContext).open.value),
            onClick: _cache[0] || (_cache[0] = async (event) => {
              if (props2.disabled || event.defaultPrevented) return;
              event.currentTarget.focus();
              if (!unref119(menuContext).open.value) unref119(menuContext).onOpenChange(true);
            }),
            onPointermove: handlePointerMove2,
            onPointerleave: handlePointerLeave,
            onKeydown: handleKeyDown
          }), {
            default: withCtx112(() => [
              renderSlot116(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["id", "aria-expanded", "aria-controls", "data-state"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSubTrigger.js
var _sfc_main120 = defineComponent125({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock117(), createBlock113(unref120(_sfc_main119), normalizeProps33(guardReactiveProps30(props2)), {
        default: withCtx113(() => [
          renderSlot117(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/ContextMenu/ContextMenuTrigger.js
import { defineComponent as defineComponent126, toRefs as toRefs19, ref as ref44, computed as computed45, onMounted as onMounted20, createElementBlock as createElementBlock8, openBlock as openBlock118, Fragment as Fragment6, createVNode as createVNode22, unref as unref121, mergeProps as mergeProps57, withCtx as withCtx114, renderSlot as renderSlot118, nextTick as nextTick18 } from "vue";

// node_modules/reka-ui/dist/ContextMenu/utils.js
function isTouchOrPen(event) {
  return event.pointerType !== "mouse";
}

// node_modules/reka-ui/dist/ContextMenu/ContextMenuTrigger.js
var _sfc_main121 = defineComponent126({
  ...{
    inheritAttrs: false
  },
  __name: "ContextMenuTrigger",
  props: {
    disabled: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props2 = __props;
    const { disabled } = toRefs19(props2);
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectContextMenuRootContext();
    const point = ref44({ x: 0, y: 0 });
    const virtualEl = computed45(() => ({
      getBoundingClientRect: () => ({
        width: 0,
        height: 0,
        left: point.value.x,
        right: point.value.x,
        top: point.value.y,
        bottom: point.value.y,
        ...point.value
      })
    }));
    const longPressTimer = ref44(0);
    function clearLongPress() {
      window.clearTimeout(longPressTimer.value);
    }
    function handleOpen(event) {
      point.value = { x: event.clientX, y: event.clientY };
      rootContext.onOpenChange(true);
    }
    async function handleContextMenu(event) {
      if (!disabled.value) {
        await nextTick18();
        if (!event.defaultPrevented) {
          clearLongPress();
          handleOpen(event);
          event.preventDefault();
        }
      }
    }
    async function handlePointerDown2(event) {
      if (!disabled.value) {
        await nextTick18();
        if (isTouchOrPen(event) && !event.defaultPrevented) {
          clearLongPress();
          longPressTimer.value = window.setTimeout(() => handleOpen(event), 700);
        }
      }
    }
    async function handlePointerEvent(event) {
      if (!disabled.value) {
        await nextTick18();
        if (isTouchOrPen(event) && !event.defaultPrevented)
          clearLongPress();
      }
    }
    onMounted20(() => {
      if (currentElement.value) {
        rootContext.triggerElement.value = currentElement.value;
      }
    });
    return (_ctx, _cache) => {
      return openBlock118(), createElementBlock8(Fragment6, null, [
        createVNode22(unref121(_sfc_main118), {
          as: "template",
          reference: virtualEl.value
        }, null, 8, ["reference"]),
        createVNode22(unref121(Primitive), mergeProps57({
          ref: unref121(forwardRef),
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "data-state": unref121(rootContext).open.value ? "open" : "closed",
          "data-disabled": unref121(disabled) ? "" : void 0,
          style: {
            WebkitTouchCallout: "none",
            pointerEvents: "auto"
          }
        }, _ctx.$attrs, {
          onContextmenu: handleContextMenu,
          onPointerdown: handlePointerDown2,
          onPointermove: handlePointerEvent,
          onPointercancel: handlePointerEvent,
          onPointerup: handlePointerEvent
        }), {
          default: withCtx114(() => [
            renderSlot118(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "data-state", "data-disabled"])
      ], 64);
    };
  }
});

// node_modules/reka-ui/dist/DateField/DateFieldInput.js
import { defineComponent as defineComponent128, ref as ref46, computed as computed48, createBlock as createBlock115, openBlock as openBlock120, unref as unref123, mergeProps as mergeProps59, toHandlers, withCtx as withCtx116, renderSlot as renderSlot120 } from "vue";

// node_modules/reka-ui/dist/date/useDateField.js
import { computed as computed46 } from "vue";

// node_modules/reka-ui/dist/date/segment.js
function isSegmentNavigationKey(key) {
  const kbd = useKbd();
  if (key === kbd.ARROW_RIGHT || key === kbd.ARROW_LEFT)
    return true;
  return false;
}
function isNumberString(value) {
  if (Number.isNaN(Number.parseInt(value)))
    return false;
  return true;
}
function isAcceptableSegmentKey(key) {
  const kbd = useKbd();
  const acceptableSegmentKeys = [
    kbd.ENTER,
    kbd.ARROW_UP,
    kbd.ARROW_DOWN,
    kbd.ARROW_LEFT,
    kbd.ARROW_RIGHT,
    kbd.BACKSPACE,
    kbd.SPACE,
    "a",
    "A",
    "p",
    "P"
  ];
  if (acceptableSegmentKeys.includes(key))
    return true;
  if (isNumberString(key))
    return true;
  return false;
}
function getSegmentElements(parentElement) {
  return Array.from(parentElement.querySelectorAll("[data-reka-date-field-segment]")).filter((item) => item.getAttribute("data-reka-date-field-segment") !== "literal");
}
function getTimeFieldSegmentElements(parentElement) {
  return Array.from(parentElement.querySelectorAll("[data-reka-time-field-segment]")).filter((item) => item.getAttribute("data-reka-time-field-segment") !== "literal");
}

// node_modules/reka-ui/dist/date/useDateField.js
function commonSegmentAttrs(props2) {
  return {
    role: "spinbutton",
    contenteditable: true,
    tabindex: props2.disabled ? void 0 : 0,
    spellcheck: false,
    inputmode: "numeric",
    autocorrect: "off",
    enterkeyhint: "next",
    style: "caret-color: transparent;"
  };
}
function daySegmentAttrs(props2) {
  const { segmentValues, placeholder } = props2;
  const isEmpty = segmentValues.day === null;
  const date = segmentValues.day ? placeholder.set({ day: segmentValues.day }) : placeholder;
  const valueNow = date.day;
  const valueMin = 1;
  const valueMax = getDaysInMonth(date);
  const valueText = isEmpty ? "Empty" : `${valueNow}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "day,",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function monthSegmentAttrs(props2) {
  const { segmentValues, placeholder, formatter } = props2;
  const isEmpty = segmentValues.month === null;
  const date = segmentValues.month ? placeholder.set({ month: segmentValues.month }) : placeholder;
  const valueNow = date.month;
  const valueMin = 1;
  const valueMax = 12;
  const valueText = isEmpty ? "Empty" : `${valueNow} - ${formatter.fullMonth(toDate(date))}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "month, ",
    "contenteditable": true,
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function yearSegmentAttrs(props2) {
  const { segmentValues, placeholder } = props2;
  const isEmpty = segmentValues.year === null;
  const date = segmentValues.year ? placeholder.set({ year: segmentValues.year }) : placeholder;
  const valueMin = 1;
  const valueMax = 9999;
  const valueNow = date.year;
  const valueText = isEmpty ? "Empty" : `${valueNow}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "year, ",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function hourSegmentAttrs(props2) {
  const { segmentValues, hourCycle, placeholder } = props2;
  if (!("hour" in segmentValues) || !("hour" in placeholder))
    return {};
  const isEmpty = segmentValues.hour === null;
  const date = segmentValues.hour ? placeholder.set({ hour: segmentValues.hour }) : placeholder;
  const valueMin = hourCycle === 12 ? 1 : 0;
  const valueMax = hourCycle === 12 ? 12 : 23;
  const valueNow = date.hour;
  const valueText = isEmpty ? "Empty" : `${valueNow} ${segmentValues.dayPeriod ?? ""}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "hour, ",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function minuteSegmentAttrs(props2) {
  const { segmentValues, placeholder } = props2;
  if (!("minute" in segmentValues) || !("minute" in placeholder))
    return {};
  const isEmpty = segmentValues.minute === null;
  const date = segmentValues.minute ? placeholder.set({ minute: segmentValues.minute }) : placeholder;
  const valueNow = date.minute;
  const valueMin = 0;
  const valueMax = 59;
  const valueText = isEmpty ? "Empty" : `${valueNow}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "minute, ",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function secondSegmentAttrs(props2) {
  const { segmentValues, placeholder } = props2;
  if (!("second" in segmentValues) || !("second" in placeholder))
    return {};
  const isEmpty = segmentValues.second === null;
  const date = segmentValues.second ? placeholder.set({ second: segmentValues.second }) : placeholder;
  const valueNow = date.second;
  const valueMin = 0;
  const valueMax = 59;
  const valueText = isEmpty ? "Empty" : `${valueNow}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "second, ",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function dayPeriodSegmentAttrs(props2) {
  const { segmentValues } = props2;
  if (!("dayPeriod" in segmentValues))
    return {};
  const valueMin = 0;
  const valueMax = 12;
  const valueNow = segmentValues.hour ? segmentValues.hour > 12 ? segmentValues.hour - 12 : segmentValues.hour : 0;
  const valueText = segmentValues.dayPeriod ?? "AM";
  return {
    ...commonSegmentAttrs(props2),
    "inputmode": "text",
    "aria-label": "AM/PM",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText
  };
}
function literalSegmentAttrs(_props) {
  return {
    "aria-hidden": true,
    "data-segment": "literal"
  };
}
function timeZoneSegmentAttrs(props2) {
  return {
    "role": "textbox",
    "aria-label": "timezone, ",
    "data-readonly": true,
    "data-segment": "timeZoneName",
    "tabindex": props2.disabled ? void 0 : 0,
    "style": "caret-color: transparent;"
  };
}
function eraSegmentAttrs(props2) {
  const { segmentValues, placeholder } = props2;
  const valueMin = 0;
  const valueMax = 0;
  const valueNow = 0;
  const valueText = "era" in segmentValues ? segmentValues.era : placeholder.era;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "era",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText
  };
}
var segmentBuilders = {
  day: {
    attrs: daySegmentAttrs
  },
  month: {
    attrs: monthSegmentAttrs
  },
  year: {
    attrs: yearSegmentAttrs
  },
  hour: {
    attrs: hourSegmentAttrs
  },
  minute: {
    attrs: minuteSegmentAttrs
  },
  second: {
    attrs: secondSegmentAttrs
  },
  dayPeriod: {
    attrs: dayPeriodSegmentAttrs
  },
  literal: {
    attrs: literalSegmentAttrs
  },
  timeZoneName: {
    attrs: timeZoneSegmentAttrs
  },
  era: {
    attrs: eraSegmentAttrs
  }
};
function useDateField(props2) {
  const kbd = useKbd();
  function minuteSecondIncrementation({ e, part, dateRef, prevValue }) {
    const sign = e.key === kbd.ARROW_UP ? 1 : -1;
    const min2 = 0;
    const max2 = 59;
    if (prevValue === null)
      return sign > 0 ? min2 : max2;
    const cycleArgs = [part, sign];
    return dateRef.set({ [part]: prevValue }).cycle(...cycleArgs)[part];
  }
  function deleteValue(prevValue) {
    props2.hasLeftFocus.value = false;
    if (prevValue === null)
      return prevValue;
    const str = prevValue.toString();
    if (str.length === 1) {
      props2.modelValue.value = void 0;
      return null;
    }
    return Number.parseInt(str.slice(0, -1));
  }
  function dateTimeValueIncrementation({ e, part, dateRef, prevValue, hourCycle }) {
    const sign = e.key === kbd.ARROW_UP ? 1 : -1;
    if (prevValue === null)
      return dateRef[part];
    if (part === "hour" && "hour" in dateRef) {
      const cycleArgs2 = [part, sign, { hourCycle }];
      return dateRef.set({ [part]: prevValue }).cycle(...cycleArgs2)[part];
    }
    const cycleArgs = [part, sign];
    if (part === "day" && props2.segmentValues.value.month !== null)
      return dateRef.set({ [part]: prevValue, month: props2.segmentValues.value.month }).cycle(...cycleArgs)[part];
    return dateRef.set({ [part]: prevValue }).cycle(...cycleArgs)[part];
  }
  function updateDayOrMonth(max2, num, prev) {
    let moveToNext = false;
    const maxStart = Math.floor(max2 / 10);
    if (props2.hasLeftFocus.value) {
      props2.hasLeftFocus.value = false;
      prev = null;
    }
    if (prev === null) {
      if (num === 0) {
        props2.lastKeyZero.value = true;
        return { value: null, moveToNext };
      }
      if (props2.lastKeyZero.value || num > maxStart) {
        moveToNext = true;
      }
      props2.lastKeyZero.value = false;
      return { value: num, moveToNext };
    }
    const digits = prev.toString().length;
    const total = Number.parseInt(prev.toString() + num.toString());
    if (digits === 2 || total > max2) {
      if (num > maxStart || total > max2) {
        moveToNext = true;
      }
      return { value: num, moveToNext };
    }
    moveToNext = true;
    return { value: total, moveToNext };
  }
  function updateMinuteOrSecond(num, prev) {
    const max2 = 59;
    let moveToNext = false;
    const maxStart = Math.floor(max2 / 10);
    if (props2.hasLeftFocus.value) {
      props2.hasLeftFocus.value = false;
      prev = null;
    }
    if (prev === null) {
      if (num === 0) {
        props2.lastKeyZero.value = true;
        return { value: 0, moveToNext };
      }
      if (props2.lastKeyZero.value || num > maxStart) {
        moveToNext = true;
      }
      props2.lastKeyZero.value = false;
      return { value: num, moveToNext };
    }
    const digits = prev.toString().length;
    const total = Number.parseInt(prev.toString() + num.toString());
    if (digits === 2 || total > max2) {
      if (num > maxStart) {
        moveToNext = true;
      }
      return { value: num, moveToNext };
    }
    moveToNext = true;
    return { value: total, moveToNext };
  }
  function updateHour(num, prev) {
    const max2 = 24;
    let moveToNext = false;
    const maxStart = Math.floor(max2 / 10);
    if (props2.hasLeftFocus.value) {
      props2.hasLeftFocus.value = false;
      prev = null;
    }
    if (prev === null) {
      if (num === 0) {
        props2.lastKeyZero.value = true;
        return { value: 0, moveToNext };
      }
      if (props2.lastKeyZero.value || num > maxStart) {
        moveToNext = true;
      }
      props2.lastKeyZero.value = false;
      return { value: num, moveToNext };
    }
    const digits = prev.toString().length;
    const total = Number.parseInt(prev.toString() + num.toString());
    if (digits === 2 || total > max2) {
      if (num > maxStart) {
        moveToNext = true;
      }
      return { value: num, moveToNext };
    }
    moveToNext = true;
    return { value: total, moveToNext };
  }
  function updateYear(num, prev) {
    let moveToNext = false;
    if (props2.hasLeftFocus.value) {
      props2.hasLeftFocus.value = false;
      prev = null;
    }
    if (prev === null)
      return { value: num === 0 ? 1 : num, moveToNext };
    const str = prev.toString() + num.toString();
    if (str.length > 4)
      return { value: num === 0 ? 1 : num, moveToNext };
    if (str.length === 4)
      moveToNext = true;
    const int = Number.parseInt(str);
    return { value: int, moveToNext };
  }
  const attributes = computed46(() => segmentBuilders[props2.part]?.attrs({
    disabled: props2.disabled.value,
    placeholder: props2.placeholder.value,
    hourCycle: props2.hourCycle,
    segmentValues: props2.segmentValues.value,
    formatter: props2.formatter
  }) ?? {});
  function handleDaySegmentKeydown(e) {
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key))
      return;
    const prevValue = props2.segmentValues.value.day;
    if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {
      props2.segmentValues.value.day = dateTimeValueIncrementation({ e, part: "day", dateRef: props2.placeholder.value, prevValue });
      return;
    }
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const segmentMonthValue = props2.segmentValues.value.month;
      const daysInMonth = segmentMonthValue ? getDaysInMonth(props2.placeholder.value.set({ month: segmentMonthValue })) : getDaysInMonth(props2.placeholder.value);
      const { value, moveToNext } = updateDayOrMonth(daysInMonth, num, prevValue);
      props2.segmentValues.value.day = value;
      if (moveToNext)
        props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.day = deleteValue(prevValue);
    }
  }
  function handleMonthSegmentKeydown(e) {
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key))
      return;
    const prevValue = props2.segmentValues.value.month;
    if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {
      props2.segmentValues.value.month = dateTimeValueIncrementation({ e, part: "month", dateRef: props2.placeholder.value, prevValue });
      return;
    }
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const { value, moveToNext } = updateDayOrMonth(12, num, prevValue);
      props2.segmentValues.value.month = value;
      if (moveToNext)
        props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.month = deleteValue(prevValue);
    }
  }
  function handleYearSegmentKeydown(e) {
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key))
      return;
    const prevValue = props2.segmentValues.value.year;
    if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {
      props2.segmentValues.value.year = dateTimeValueIncrementation({ e, part: "year", dateRef: props2.placeholder.value, prevValue });
      return;
    }
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const { value, moveToNext } = updateYear(num, prevValue);
      props2.segmentValues.value.year = value;
      if (moveToNext)
        props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.year = deleteValue(prevValue);
    }
  }
  function handleHourSegmentKeydown(e) {
    const dateRef = props2.placeholder.value;
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !("hour" in dateRef) || !("hour" in props2.segmentValues.value))
      return;
    const prevValue = props2.segmentValues.value.hour;
    const hourCycle = props2.hourCycle;
    if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) {
      props2.segmentValues.value.hour = dateTimeValueIncrementation({ e, part: "hour", dateRef: props2.placeholder.value, prevValue, hourCycle });
      if ("dayPeriod" in props2.segmentValues.value) {
        if (props2.segmentValues.value.hour < 12)
          props2.segmentValues.value.dayPeriod = "AM";
        else if (props2.segmentValues.value.hour)
          props2.segmentValues.value.dayPeriod = "PM";
      }
      return;
    }
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const { value, moveToNext } = updateHour(num, prevValue);
      if ("dayPeriod" in props2.segmentValues.value && value && value > 12)
        props2.segmentValues.value.dayPeriod = "PM";
      else if ("dayPeriod" in props2.segmentValues.value && value)
        props2.segmentValues.value.dayPeriod = "AM";
      props2.segmentValues.value.hour = value;
      if (moveToNext)
        props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.hour = deleteValue(prevValue);
    }
  }
  function handleMinuteSegmentKeydown(e) {
    const dateRef = props2.placeholder.value;
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !("minute" in dateRef) || !("minute" in props2.segmentValues.value))
      return;
    const prevValue = props2.segmentValues.value.minute;
    props2.segmentValues.value.minute = minuteSecondIncrementation({ e, part: "minute", dateRef: props2.placeholder.value, prevValue });
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const { value, moveToNext } = updateMinuteOrSecond(num, prevValue);
      props2.segmentValues.value.minute = value;
      if (moveToNext)
        props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.minute = deleteValue(prevValue);
    }
  }
  function handleSecondSegmentKeydown(e) {
    const dateRef = props2.placeholder.value;
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !("second" in dateRef) || !("second" in props2.segmentValues.value))
      return;
    const prevValue = props2.segmentValues.value.second;
    props2.segmentValues.value.second = minuteSecondIncrementation({ e, part: "second", dateRef: props2.placeholder.value, prevValue });
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const { value, moveToNext } = updateMinuteOrSecond(num, prevValue);
      props2.segmentValues.value.second = value;
      if (moveToNext)
        props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.second = deleteValue(prevValue);
    }
  }
  function handleDayPeriodSegmentKeydown(e) {
    if ((!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key)) && e.key !== "a" && e.key !== "p" || !("hour" in props2.placeholder.value) || !("dayPeriod" in props2.segmentValues.value))
      return;
    if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) {
      if (props2.segmentValues.value.dayPeriod === "AM") {
        props2.segmentValues.value.dayPeriod = "PM";
        props2.segmentValues.value.hour = props2.segmentValues.value.hour + 12;
        return;
      }
      props2.segmentValues.value.dayPeriod = "AM";
      props2.segmentValues.value.hour = props2.segmentValues.value.hour - 12;
      return;
    }
    if (["a", "A"].includes(e.key) && props2.segmentValues.value.dayPeriod !== "AM") {
      props2.segmentValues.value.dayPeriod = "AM";
      props2.segmentValues.value.hour = props2.segmentValues.value.hour - 12;
      return;
    }
    if (["p", "P"].includes(e.key) && props2.segmentValues.value.dayPeriod !== "PM") {
      props2.segmentValues.value.dayPeriod = "PM";
      props2.segmentValues.value.hour = props2.segmentValues.value.hour + 12;
    }
  }
  function handleSegmentClick(e) {
    const disabled = props2.disabled.value;
    if (disabled)
      e.preventDefault();
  }
  function handleSegmentKeydown(e) {
    const disabled = props2.disabled.value;
    const readonly3 = props2.readonly.value;
    if (e.key !== kbd.TAB)
      e.preventDefault();
    if (disabled || readonly3)
      return;
    const segmentKeydownHandlers = {
      day: handleDaySegmentKeydown,
      month: handleMonthSegmentKeydown,
      year: handleYearSegmentKeydown,
      hour: handleHourSegmentKeydown,
      minute: handleMinuteSegmentKeydown,
      second: handleSecondSegmentKeydown,
      dayPeriod: handleDayPeriodSegmentKeydown,
      timeZoneName: () => {
      }
    };
    segmentKeydownHandlers[props2.part](e);
    if (![kbd.ARROW_LEFT, kbd.ARROW_RIGHT].includes(e.key) && e.key !== kbd.TAB && e.key !== kbd.SHIFT && isAcceptableSegmentKey(e.key)) {
      if (Object.values(props2.segmentValues.value).every((item) => item !== null)) {
        const updateObject = { ...props2.segmentValues.value };
        let dateRef = props2.placeholder.value.copy();
        Object.keys(updateObject).forEach((part) => {
          const value = updateObject[part];
          dateRef = dateRef.set({ [part]: value });
        });
        props2.modelValue.value = dateRef.copy();
      }
    }
  }
  return {
    handleSegmentClick,
    handleSegmentKeydown,
    attributes
  };
}

// node_modules/reka-ui/dist/DateField/DateFieldRoot.js
import { defineComponent as defineComponent127, toRefs as toRefs20, ref as ref45, onMounted as onMounted21, computed as computed47, watch as watch21, nextTick as nextTick19, createBlock as createBlock114, openBlock as openBlock119, unref as unref122, mergeProps as mergeProps58, withKeys as withKeys8, withCtx as withCtx115, renderSlot as renderSlot119, createVNode as createVNode23 } from "vue";

// node_modules/reka-ui/dist/date/parts.js
var DATE_SEGMENT_PARTS = ["day", "month", "year"];
var TIME_SEGMENT_PARTS = ["hour", "minute", "second", "dayPeriod"];
var EDITABLE_SEGMENT_PARTS = [...DATE_SEGMENT_PARTS, ...TIME_SEGMENT_PARTS];
function isDateSegmentPart(part) {
  return DATE_SEGMENT_PARTS.includes(part);
}
function isSegmentPart(part) {
  return EDITABLE_SEGMENT_PARTS.includes(part);
}

// node_modules/reka-ui/dist/date/placeholders.js
var supportedLocales = [
  "ach",
  "af",
  "am",
  "an",
  "ar",
  "ast",
  "az",
  "be",
  "bg",
  "bn",
  "br",
  "bs",
  "ca",
  "cak",
  "ckb",
  "cs",
  "cy",
  "da",
  "de",
  "dsb",
  "el",
  "en",
  "eo",
  "es",
  "et",
  "eu",
  "fa",
  "ff",
  "fi",
  "fr",
  "fy",
  "ga",
  "gd",
  "gl",
  "he",
  "hr",
  "hsb",
  "hu",
  "ia",
  "id",
  "it",
  "ja",
  "ka",
  "kk",
  "kn",
  "ko",
  "lb",
  "lo",
  "lt",
  "lv",
  "meh",
  "ml",
  "ms",
  "nl",
  "nn",
  "no",
  "oc",
  "pl",
  "pt",
  "rm",
  "ro",
  "ru",
  "sc",
  "scn",
  "sk",
  "sl",
  "sr",
  "sv",
  "szl",
  "tg",
  "th",
  "tr",
  "uk",
  "zh-CN",
  "zh-TW"
];
var placeholderFields = ["year", "month", "day"];
var placeholders = {
  "ach": { year: "mwaka", month: "dwe", day: "nino" },
  "af": { year: "jjjj", month: "mm", day: "dd" },
  "am": { year: "ዓዓዓዓ", month: "ሚሜ", day: "ቀቀ" },
  "an": { year: "aaaa", month: "mm", day: "dd" },
  "ar": { year: "سنة", month: "شهر", day: "يوم" },
  "ast": { year: "aaaa", month: "mm", day: "dd" },
  "az": { year: "iiii", month: "aa", day: "gg" },
  "be": { year: "гггг", month: "мм", day: "дд" },
  "bg": { year: "гггг", month: "мм", day: "дд" },
  "bn": { year: "yyyy", month: "মিমি", day: "dd" },
  "br": { year: "bbbb", month: "mm", day: "dd" },
  "bs": { year: "gggg", month: "mm", day: "dd" },
  "ca": { year: "aaaa", month: "mm", day: "dd" },
  "cak": { year: "jjjj", month: "ii", day: "q'q'" },
  "ckb": { year: "ساڵ", month: "مانگ", day: "ڕۆژ" },
  "cs": { year: "rrrr", month: "mm", day: "dd" },
  "cy": { year: "bbbb", month: "mm", day: "dd" },
  "da": { year: "åååå", month: "mm", day: "dd" },
  "de": { year: "jjjj", month: "mm", day: "tt" },
  "dsb": { year: "llll", month: "mm", day: "źź" },
  "el": { year: "εεεε", month: "μμ", day: "ηη" },
  "en": { year: "yyyy", month: "mm", day: "dd" },
  "eo": { year: "jjjj", month: "mm", day: "tt" },
  "es": { year: "aaaa", month: "mm", day: "dd" },
  "et": { year: "aaaa", month: "kk", day: "pp" },
  "eu": { year: "uuuu", month: "hh", day: "ee" },
  "fa": { year: "سال", month: "ماه", day: "روز" },
  "ff": { year: "hhhh", month: "ll", day: "ññ" },
  "fi": { year: "vvvv", month: "kk", day: "pp" },
  "fr": { year: "aaaa", month: "mm", day: "jj" },
  "fy": { year: "jjjj", month: "mm", day: "dd" },
  "ga": { year: "bbbb", month: "mm", day: "ll" },
  "gd": { year: "bbbb", month: "mm", day: "ll" },
  "gl": { year: "aaaa", month: "mm", day: "dd" },
  "he": { year: "שנה", month: "חודש", day: "יום" },
  "hr": { year: "gggg", month: "mm", day: "dd" },
  "hsb": { year: "llll", month: "mm", day: "dd" },
  "hu": { year: "éééé", month: "hh", day: "nn" },
  "ia": { year: "aaaa", month: "mm", day: "dd" },
  "id": { year: "tttt", month: "bb", day: "hh" },
  "it": { year: "aaaa", month: "mm", day: "gg" },
  "ja": { year: " 年 ", month: "月", day: "日" },
  "ka": { year: "წწწწ", month: "თთ", day: "რრ" },
  "kk": { year: "жжжж", month: "аа", day: "кк" },
  "kn": { year: "ವವವವ", month: "ಮಿಮೀ", day: "ದಿದಿ" },
  "ko": { year: "연도", month: "월", day: "일" },
  "lb": { year: "jjjj", month: "mm", day: "dd" },
  "lo": { year: "ປປປປ", month: "ດດ", day: "ວວ" },
  "lt": { year: "mmmm", month: "mm", day: "dd" },
  "lv": { year: "gggg", month: "mm", day: "dd" },
  "meh": { year: "aaaa", month: "mm", day: "dd" },
  "ml": { year: "വർഷം", month: "മാസം", day: "തീയതി" },
  "ms": { year: "tttt", month: "mm", day: "hh" },
  "nl": { year: "jjjj", month: "mm", day: "dd" },
  "nn": { year: "åååå", month: "mm", day: "dd" },
  "no": { year: "åååå", month: "mm", day: "dd" },
  "oc": { year: "aaaa", month: "mm", day: "jj" },
  "pl": { year: "rrrr", month: "mm", day: "dd" },
  "pt": { year: "aaaa", month: "mm", day: "dd" },
  "rm": { year: "oooo", month: "mm", day: "dd" },
  "ro": { year: "aaaa", month: "ll", day: "zz" },
  "ru": { year: "гггг", month: "мм", day: "дд" },
  "sc": { year: "aaaa", month: "mm", day: "dd" },
  "scn": { year: "aaaa", month: "mm", day: "jj" },
  "sk": { year: "rrrr", month: "mm", day: "dd" },
  "sl": { year: "llll", month: "mm", day: "dd" },
  "sr": { year: "гггг", month: "мм", day: "дд" },
  "sv": { year: "åååå", month: "mm", day: "dd" },
  "szl": { year: "rrrr", month: "mm", day: "dd" },
  "tg": { year: "сссс", month: "мм", day: "рр" },
  "th": { year: "ปปปป", month: "ดด", day: "วว" },
  "tr": { year: "yyyy", month: "aa", day: "gg" },
  "uk": { year: "рррр", month: "мм", day: "дд" },
  "zh-CN": { year: "年", month: "月", day: "日" },
  "zh-TW": { year: "年", month: "月", day: "日" }
};
function getPlaceholderObj(locale) {
  if (!isSupportedLocale(locale)) {
    const localeLanguage = getLocaleLanguage(locale);
    if (!isSupportedLocale(localeLanguage))
      return placeholders.en;
    else
      return placeholders[localeLanguage];
  } else {
    return placeholders[locale];
  }
}
function getPlaceholder(field, value, locale) {
  if (isPlaceholderField(field))
    return getPlaceholderObj(locale)[field];
  if (isDefaultField(field))
    return value;
  if (isTimeField(field))
    return "––";
  return "";
}
function isSupportedLocale(locale) {
  return supportedLocales.includes(locale);
}
function isPlaceholderField(field) {
  return placeholderFields.includes(field);
}
function isTimeField(field) {
  return field === "hour" || field === "minute" || field === "second";
}
function isDefaultField(field) {
  return field === "era" || field === "dayPeriod";
}
function getLocaleLanguage(locale) {
  if (Intl.Locale)
    return new Intl.Locale(locale).language;
  return locale.split("-")[0];
}

// node_modules/reka-ui/dist/date/parser.js
var calendarDateTimeGranularities = ["hour", "minute", "second"];
function syncTimeSegmentValues(props2) {
  return Object.fromEntries(TIME_SEGMENT_PARTS.map((part) => {
    if (part === "dayPeriod")
      return [part, props2.formatter.dayPeriod(toDate(props2.value))];
    return [part, props2.value[part]];
  }));
}
function syncSegmentValues(props2) {
  const { formatter } = props2;
  const dateValues = DATE_SEGMENT_PARTS.map((part) => {
    return [part, props2.value[part]];
  });
  if ("hour" in props2.value) {
    const timeValues = syncTimeSegmentValues({ value: props2.value, formatter });
    return { ...Object.fromEntries(dateValues), ...timeValues };
  }
  return Object.fromEntries(dateValues);
}
function initializeTimeSegmentValues(granularity) {
  return Object.fromEntries(
    TIME_SEGMENT_PARTS.map((part) => {
      if (part === "dayPeriod")
        return [part, "AM"];
      return [part, null];
    }).filter(([key]) => {
      if (key === "literal" || key === null)
        return false;
      if (granularity === "minute" && key === "second")
        return false;
      if (granularity === "hour" && (key === "second" || key === "minute"))
        return false;
      else return true;
    })
  );
}
function initializeSegmentValues(granularity) {
  const initialParts = EDITABLE_SEGMENT_PARTS.map((part) => {
    if (part === "dayPeriod")
      return [part, "AM"];
    return [part, null];
  }).filter(([key]) => {
    if (key === "literal" || key === null)
      return false;
    if (granularity === "minute" && key === "second")
      return false;
    if (granularity === "hour" && (key === "second" || key === "minute"))
      return false;
    if (granularity === "day")
      return !calendarDateTimeGranularities.includes(key) && key !== "dayPeriod";
    else return true;
  });
  return Object.fromEntries(initialParts);
}
function createContentObj(props2) {
  const { segmentValues, formatter, locale } = props2;
  function getPartContent(part) {
    if ("hour" in segmentValues) {
      const value = segmentValues[part];
      if (value !== null) {
        if (part === "day" && segmentValues.month !== null) {
          return formatter.part(props2.dateRef.set({ [part]: value, month: segmentValues.month }), part, {
            hourCycle: props2.hourCycle === 24 ? "h23" : void 0
          });
        }
        return formatter.part(props2.dateRef.set({ [part]: value }), part, {
          hourCycle: props2.hourCycle === 24 ? "h23" : void 0
        });
      } else {
        return getPlaceholder(part, "", locale.value);
      }
    } else {
      if (isDateSegmentPart(part)) {
        const value = segmentValues[part];
        if (value !== null) {
          if (part === "day" && segmentValues.month !== null)
            return formatter.part(props2.dateRef.set({ [part]: value, month: segmentValues.month }), part);
          return formatter.part(props2.dateRef.set({ [part]: value }), part);
        } else {
          return getPlaceholder(part, "", locale.value);
        }
      }
      return "";
    }
  }
  const content = Object.keys(segmentValues).reduce((obj, part) => {
    if (!isSegmentPart(part))
      return obj;
    if ("hour" in segmentValues && part === "dayPeriod") {
      const value = segmentValues[part];
      if (value !== null)
        obj[part] = value;
      else
        obj[part] = getPlaceholder(part, "AM", locale.value);
    } else {
      obj[part] = getPartContent(part);
    }
    return obj;
  }, {});
  return content;
}
function createContentArr(props2) {
  const { granularity, formatter, contentObj, hideTimeZone, hourCycle, isTimeValue } = props2;
  const parts = formatter.toParts(props2.dateRef, getOptsByGranularity(granularity, hourCycle, isTimeValue));
  const segmentContentArr = parts.map((part) => {
    const defaultParts = ["literal", "timeZoneName", null];
    if (defaultParts.includes(part.type) || !isSegmentPart(part.type)) {
      return {
        part: part.type,
        value: part.value
      };
    }
    return {
      part: part.type,
      value: contentObj[part.type]
    };
  }).filter((segment) => {
    if (segment.part === null || segment.value === null)
      return false;
    if (segment.part === "timeZoneName" && (!isZonedDateTime(props2.dateRef) || hideTimeZone))
      return false;
    return true;
  });
  return segmentContentArr;
}
function createContent(props2) {
  const contentObj = createContentObj(props2);
  const contentArr = createContentArr({
    contentObj,
    ...props2
  });
  return {
    obj: contentObj,
    arr: contentArr
  };
}

// node_modules/reka-ui/dist/DateField/DateFieldRoot.js
var [injectDateFieldRootContext, provideDateFieldRootContext] = createContext("DateFieldRoot");
var _sfc_main122 = defineComponent127({
  ...{
    inheritAttrs: false
  },
  __name: "DateFieldRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    isDateUnavailable: { type: Function, default: void 0 },
    id: {},
    dir: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, readonly: readonly3, isDateUnavailable: propsIsDateUnavailable, granularity, defaultValue, dir: propDir, locale: propLocale } = toRefs20(props2);
    const locale = useLocale(propLocale);
    const dir = useDirection(propDir);
    const formatter = useDateFormatter(locale.value);
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const segmentElements = ref45(/* @__PURE__ */ new Set());
    onMounted21(() => {
      getSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
    });
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: defaultValue.value,
      passive: props2.modelValue === void 0
    });
    const defaultDate = getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      granularity: granularity.value,
      defaultValue: modelValue.value,
      locale: props2.locale
    });
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    const inferredGranularity = computed47(() => {
      if (props2.granularity)
        return !hasTime(placeholder.value) ? "day" : props2.granularity;
      return hasTime(placeholder.value) ? "minute" : "day";
    });
    const isInvalid = computed47(() => {
      if (!modelValue.value)
        return false;
      if (propsIsDateUnavailable.value?.(modelValue.value))
        return true;
      if (props2.minValue && isBefore(modelValue.value, props2.minValue))
        return true;
      if (props2.maxValue && isBefore(props2.maxValue, modelValue.value))
        return true;
      return false;
    });
    const initialSegments = initializeSegmentValues(inferredGranularity.value);
    const segmentValues = ref45(modelValue.value ? { ...syncSegmentValues({ value: modelValue.value, formatter }) } : { ...initialSegments });
    const allSegmentContent = computed47(() => createContent({
      granularity: inferredGranularity.value,
      dateRef: placeholder.value,
      formatter,
      hideTimeZone: props2.hideTimeZone,
      hourCycle: props2.hourCycle,
      segmentValues: segmentValues.value,
      locale
    }));
    const segmentContents = computed47(() => allSegmentContent.value.arr);
    const editableSegmentContents = computed47(() => segmentContents.value.filter(({ part }) => part !== "literal"));
    watch21(locale, (value) => {
      if (formatter.getLocale() !== value) {
        formatter.setLocale(value);
        nextTick19(() => {
          segmentElements.value.clear();
          getSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
        });
      }
    });
    watch21(modelValue, (_modelValue) => {
      if (!isNullish(_modelValue) && placeholder.value.compare(_modelValue) !== 0) {
        placeholder.value = _modelValue.copy();
      }
    });
    watch21([modelValue, locale], ([_modelValue]) => {
      if (!isNullish(_modelValue)) {
        segmentValues.value = { ...syncSegmentValues({ value: _modelValue, formatter }) };
      } else if (Object.values(segmentValues.value).every((value) => value !== null) && isNullish(_modelValue)) {
        segmentValues.value = { ...initialSegments };
      }
    });
    const currentFocusedElement = ref45(null);
    const currentSegmentIndex = computed47(() => Array.from(segmentElements.value).findIndex((el) => el.getAttribute("data-reka-date-field-segment") === currentFocusedElement.value?.getAttribute("data-reka-date-field-segment")));
    const nextFocusableSegment = computed47(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const nextCondition = sign < 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (nextCondition)
        return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value + sign];
      return segmentToFocus;
    });
    const prevFocusableSegment = computed47(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const prevCondition = sign > 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (prevCondition)
        return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value - sign];
      return segmentToFocus;
    });
    const kbd = useKbd();
    function handleKeydown(e) {
      if (!isSegmentNavigationKey(e.key))
        return;
      if (e.key === kbd.ARROW_LEFT)
        prevFocusableSegment.value?.focus();
      if (e.key === kbd.ARROW_RIGHT)
        nextFocusableSegment.value?.focus();
    }
    function setFocusedElement(el) {
      currentFocusedElement.value = el;
    }
    provideDateFieldRootContext({
      isDateUnavailable: propsIsDateUnavailable.value,
      locale,
      modelValue,
      placeholder,
      disabled,
      formatter,
      hourCycle: props2.hourCycle,
      readonly: readonly3,
      segmentValues,
      isInvalid,
      segmentContents: editableSegmentContents,
      elements: segmentElements,
      setFocusedElement,
      focusNext() {
        nextFocusableSegment.value?.focus();
      }
    });
    __expose({
      /** Helper to set the focused element inside the DateField */
      setFocusedElement
    });
    return (_ctx, _cache) => {
      return openBlock119(), createBlock114(unref122(Primitive), mergeProps58(_ctx.$attrs, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        role: "group",
        "aria-disabled": unref122(disabled) ? true : void 0,
        "data-disabled": unref122(disabled) ? "" : void 0,
        "data-readonly": unref122(readonly3) ? "" : void 0,
        "data-invalid": isInvalid.value ? "" : void 0,
        dir: unref122(dir),
        onKeydown: withKeys8(handleKeydown, ["left", "right"])
      }), {
        default: withCtx115(() => [
          renderSlot119(_ctx.$slots, "default", {
            modelValue: unref122(modelValue),
            segments: segmentContents.value,
            isInvalid: isInvalid.value
          }),
          createVNode23(unref122(_sfc_main), {
            id: _ctx.id,
            as: "input",
            feature: "focusable",
            tabindex: "-1",
            value: unref122(modelValue) ? unref122(modelValue).toString() : "",
            name: _ctx.name,
            disabled: unref122(disabled),
            required: _ctx.required,
            onFocus: _cache[0] || (_cache[0] = ($event) => Array.from(segmentElements.value)?.[0]?.focus())
          }, null, 8, ["id", "value", "name", "disabled", "required"])
        ]),
        _: 3
      }, 16, ["aria-disabled", "data-disabled", "data-readonly", "data-invalid", "dir"]);
    };
  }
});

// node_modules/reka-ui/dist/DateField/DateFieldInput.js
var _sfc_main123 = defineComponent128({
  __name: "DateFieldInput",
  props: {
    part: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDateFieldRootContext();
    const hasLeftFocus = ref46(true);
    const lastKeyZero = ref46(false);
    const {
      handleSegmentClick,
      handleSegmentKeydown,
      attributes
    } = useDateField({
      hasLeftFocus,
      lastKeyZero,
      placeholder: rootContext.placeholder,
      hourCycle: rootContext.hourCycle,
      segmentValues: rootContext.segmentValues,
      formatter: rootContext.formatter,
      part: props2.part,
      disabled: rootContext.disabled,
      readonly: rootContext.readonly,
      focusNext: rootContext.focusNext,
      modelValue: rootContext.modelValue
    });
    const disabled = computed48(() => rootContext.disabled.value);
    const readonly3 = computed48(() => rootContext.readonly.value);
    const isInvalid = computed48(() => rootContext.isInvalid.value);
    return (_ctx, _cache) => {
      return openBlock120(), createBlock115(unref123(Primitive), mergeProps59({
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, unref123(attributes), {
        contenteditable: disabled.value || readonly3.value ? false : _ctx.part !== "literal",
        "data-reka-date-field-segment": _ctx.part,
        "aria-disabled": disabled.value ? true : void 0,
        "aria-readonly": readonly3.value ? true : void 0,
        "data-disabled": disabled.value ? "" : void 0,
        "data-invalid": isInvalid.value ? "" : void 0,
        "aria-invalid": isInvalid.value ? true : void 0
      }, toHandlers(_ctx.part !== "literal" ? {
        mousedown: unref123(handleSegmentClick),
        keydown: unref123(handleSegmentKeydown),
        focusout: () => {
          hasLeftFocus.value = true;
        },
        focusin: (e) => {
          unref123(rootContext).setFocusedElement(e.target);
        }
      } : {})), {
        default: withCtx116(() => [
          renderSlot120(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["as", "as-child", "contenteditable", "data-reka-date-field-segment", "aria-disabled", "aria-readonly", "data-disabled", "data-invalid", "aria-invalid"]);
    };
  }
});

// node_modules/reka-ui/dist/index.js
import { defineComponent as defineComponent375, createBlock as createBlock354, openBlock as openBlock364, unref as unref366, normalizeProps as normalizeProps108, guardReactiveProps as guardReactiveProps104, withCtx as withCtx359, renderSlot as renderSlot366 } from "vue";

// node_modules/reka-ui/dist/Popover/PopoverAnchor.js
import { defineComponent as defineComponent130, onBeforeMount as onBeforeMount2, onUnmounted as onUnmounted12, createBlock as createBlock117, openBlock as openBlock122, unref as unref125, normalizeProps as normalizeProps34, guardReactiveProps as guardReactiveProps31, withCtx as withCtx118, renderSlot as renderSlot122 } from "vue";

// node_modules/reka-ui/dist/Popover/PopoverRoot.js
import { defineComponent as defineComponent129, toRefs as toRefs21, ref as ref47, createBlock as createBlock116, openBlock as openBlock121, unref as unref124, withCtx as withCtx117, renderSlot as renderSlot121 } from "vue";
var [injectPopoverRootContext, providePopoverRootContext] = createContext("PopoverRoot");
var _sfc_main124 = defineComponent129({
  __name: "PopoverRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: false }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const { modal } = toRefs21(props2);
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const triggerElement = ref47();
    const hasCustomAnchor = ref47(false);
    providePopoverRootContext({
      contentId: "",
      triggerId: "",
      modal,
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      onOpenToggle: () => {
        open.value = !open.value;
      },
      triggerElement,
      hasCustomAnchor
    });
    return (_ctx, _cache) => {
      return openBlock121(), createBlock116(unref124(_sfc_main57), null, {
        default: withCtx117(() => [
          renderSlot121(_ctx.$slots, "default", { open: unref124(open) })
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Popover/PopoverAnchor.js
var _sfc_main125 = defineComponent130({
  __name: "PopoverAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPopoverRootContext();
    onBeforeMount2(() => {
      rootContext.hasCustomAnchor.value = true;
    });
    onUnmounted12(() => {
      rootContext.hasCustomAnchor.value = false;
    });
    return (_ctx, _cache) => {
      return openBlock122(), createBlock117(unref125(_sfc_main58), normalizeProps34(guardReactiveProps31(props2)), {
        default: withCtx118(() => [
          renderSlot122(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerArrow.js
import { defineComponent as defineComponent132, createBlock as createBlock119, openBlock as openBlock124, unref as unref127, normalizeProps as normalizeProps36, guardReactiveProps as guardReactiveProps33, withCtx as withCtx120, renderSlot as renderSlot124 } from "vue";

// node_modules/reka-ui/dist/Popover/PopoverArrow.js
import { defineComponent as defineComponent131, createBlock as createBlock118, openBlock as openBlock123, unref as unref126, normalizeProps as normalizeProps35, guardReactiveProps as guardReactiveProps32, withCtx as withCtx119, renderSlot as renderSlot123 } from "vue";
var _sfc_main126 = defineComponent131({
  __name: "PopoverArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock123(), createBlock118(unref126(_sfc_main62), normalizeProps35(guardReactiveProps32(props2)), {
        default: withCtx119(() => [
          renderSlot123(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerArrow.js
var _sfc_main127 = defineComponent132({
  __name: "DatePickerArrow",
  props: {
    width: {},
    height: {},
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock124(), createBlock119(unref127(_sfc_main126), normalizeProps36(guardReactiveProps33(props2)), {
        default: withCtx120(() => [
          renderSlot124(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerCalendar.js
import { defineComponent as defineComponent134, createBlock as createBlock121, openBlock as openBlock126, unref as unref129, mergeProps as mergeProps60, withCtx as withCtx122, renderSlot as renderSlot126 } from "vue";

// node_modules/reka-ui/dist/DatePicker/DatePickerRoot.js
import { defineComponent as defineComponent133, toRefs as toRefs22, computed as computed49, ref as ref48, watch as watch22, createBlock as createBlock120, openBlock as openBlock125, unref as unref128, isRef as isRef6, withCtx as withCtx121, renderSlot as renderSlot125 } from "vue";
var [injectDatePickerRootContext, provideDatePickerRootContext] = createContext("DatePickerRoot");
var _sfc_main128 = defineComponent133({
  ...{
    inheritAttrs: false
  },
  __name: "DatePickerRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: { default: "en" },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    isDateUnavailable: { type: Function, default: void 0 },
    id: {},
    dir: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: false },
    isDateDisabled: { type: Function, default: void 0 },
    pagedNavigation: { type: Boolean, default: false },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    fixedWeeks: { type: Boolean, default: false },
    numberOfMonths: { default: 1 },
    preventDeselect: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "update:placeholder", "update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const {
      locale,
      disabled,
      readonly: readonly3,
      pagedNavigation,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      numberOfMonths,
      preventDeselect,
      isDateDisabled: propsIsDateDisabled,
      isDateUnavailable: propsIsDateUnavailable,
      defaultOpen,
      modal,
      id,
      name,
      required,
      minValue,
      maxValue,
      granularity,
      hideTimeZone,
      hourCycle,
      defaultValue,
      dir: propDir
    } = toRefs22(props2);
    const dir = useDirection(propDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: defaultValue.value,
      passive: props2.modelValue === void 0
    });
    const defaultDate = computed49(() => getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      granularity: props2.granularity,
      defaultValue: modelValue.value,
      locale: props2.locale
    }));
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.value.copy(),
      passive: props2.placeholder === void 0
    });
    const open = useVModel(props2, "open", emits, {
      defaultValue: defaultOpen.value,
      passive: props2.open === void 0
    });
    const dateFieldRef = ref48();
    watch22(modelValue, (value) => {
      if (value && value.compare(placeholder.value) !== 0) {
        placeholder.value = value.copy();
      }
    });
    provideDatePickerRootContext({
      isDateUnavailable: propsIsDateUnavailable.value,
      isDateDisabled: propsIsDateDisabled.value,
      locale,
      disabled,
      pagedNavigation,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      numberOfMonths,
      readonly: readonly3,
      preventDeselect,
      modelValue,
      placeholder,
      defaultOpen,
      modal,
      open,
      id,
      name,
      required,
      minValue,
      maxValue,
      granularity,
      hideTimeZone,
      hourCycle,
      dateFieldRef,
      dir,
      onDateChange(date) {
        if (!date || !modelValue.value) {
          modelValue.value = date?.copy() ?? void 0;
        } else if (!preventDeselect.value && date && modelValue.value.compare(date) === 0) {
          modelValue.value = void 0;
        } else {
          modelValue.value = date.copy();
        }
      },
      onPlaceholderChange(date) {
        placeholder.value = date.copy();
      }
    });
    return (_ctx, _cache) => {
      return openBlock125(), createBlock120(unref128(_sfc_main124), {
        open: unref128(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef6(open) ? open.value = $event : null),
        "default-open": unref128(defaultOpen),
        modal: unref128(modal)
      }, {
        default: withCtx121(() => [
          renderSlot125(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["open", "default-open", "modal"]);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerCalendar.js
var _sfc_main129 = defineComponent134({
  __name: "DatePickerCalendar",
  setup(__props) {
    const rootContext = injectDatePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock126(), createBlock121(unref129(_sfc_main38), mergeProps60({
        isDateDisabled: unref129(rootContext).isDateDisabled,
        isDateUnavailable: unref129(rootContext).isDateUnavailable,
        minValue: unref129(rootContext).minValue.value,
        maxValue: unref129(rootContext).maxValue.value,
        locale: unref129(rootContext).locale.value,
        disabled: unref129(rootContext).disabled.value,
        pagedNavigation: unref129(rootContext).pagedNavigation.value,
        weekStartsOn: unref129(rootContext).weekStartsOn.value,
        weekdayFormat: unref129(rootContext).weekdayFormat.value,
        fixedWeeks: unref129(rootContext).fixedWeeks.value,
        numberOfMonths: unref129(rootContext).numberOfMonths.value,
        readonly: unref129(rootContext).readonly.value,
        preventDeselect: unref129(rootContext).preventDeselect.value,
        dir: unref129(rootContext).dir.value
      }, {
        "model-value": unref129(rootContext).modelValue.value,
        placeholder: unref129(rootContext).placeholder.value,
        "initial-focus": "",
        multiple: false,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = (date) => {
          if (date && unref129(rootContext).modelValue.value && unref129($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date, unref129(rootContext).modelValue.value)) return;
          unref129(rootContext).onDateChange(date);
        }),
        "onUpdate:placeholder": _cache[1] || (_cache[1] = (date) => {
          if (unref129($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date, unref129(rootContext).placeholder.value)) return;
          unref129(rootContext).onPlaceholderChange(date);
        })
      }), {
        default: withCtx122(({ weekDays, grid, date, weekStartsOn, locale, fixedWeeks }) => [
          renderSlot126(_ctx.$slots, "default", {
            date,
            grid,
            weekDays,
            weekStartsOn,
            locale,
            fixedWeeks
          })
        ]),
        _: 3
      }, 16, ["model-value", "placeholder"]);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerCell.js
import { defineComponent as defineComponent135, createBlock as createBlock122, openBlock as openBlock127, unref as unref130, normalizeProps as normalizeProps37, guardReactiveProps as guardReactiveProps34, withCtx as withCtx123, renderSlot as renderSlot127 } from "vue";
var _sfc_main130 = defineComponent135({
  __name: "DatePickerCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock127(), createBlock122(unref130(_sfc_main39), normalizeProps37(guardReactiveProps34(props2)), {
        default: withCtx123(() => [
          renderSlot127(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerCellTrigger.js
import { defineComponent as defineComponent136, createBlock as createBlock123, openBlock as openBlock128, unref as unref131, normalizeProps as normalizeProps38, guardReactiveProps as guardReactiveProps35, withCtx as withCtx124, renderSlot as renderSlot128 } from "vue";
var _sfc_main131 = defineComponent136({
  __name: "DatePickerCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock128(), createBlock123(unref131(_sfc_main40), normalizeProps38(guardReactiveProps35(props2)), {
        default: withCtx124((slotProps) => [
          renderSlot128(_ctx.$slots, "default", normalizeProps38(guardReactiveProps35(slotProps)))
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerClose.js
import { defineComponent as defineComponent138, createBlock as createBlock125, openBlock as openBlock130, unref as unref133, normalizeProps as normalizeProps39, guardReactiveProps as guardReactiveProps36, withCtx as withCtx126, renderSlot as renderSlot130 } from "vue";

// node_modules/reka-ui/dist/Popover/PopoverClose.js
import { defineComponent as defineComponent137, createBlock as createBlock124, openBlock as openBlock129, unref as unref132, withCtx as withCtx125, renderSlot as renderSlot129 } from "vue";
var _sfc_main132 = defineComponent137({
  __name: "PopoverClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPopoverRootContext();
    return (_ctx, _cache) => {
      return openBlock129(), createBlock124(unref132(Primitive), {
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "as-child": props2.asChild,
        onClick: _cache[0] || (_cache[0] = ($event) => unref132(rootContext).onOpenChange(false))
      }, {
        default: withCtx125(() => [
          renderSlot129(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child"]);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerClose.js
var _sfc_main133 = defineComponent138({
  __name: "DatePickerClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock130(), createBlock125(unref133(_sfc_main132), normalizeProps39(guardReactiveProps36(props2)), {
        default: withCtx126(() => [
          renderSlot130(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerContent.js
import { defineComponent as defineComponent144, createBlock as createBlock131, openBlock as openBlock136, unref as unref139, withCtx as withCtx132, createVNode as createVNode25, normalizeProps as normalizeProps41, guardReactiveProps as guardReactiveProps38, renderSlot as renderSlot136 } from "vue";

// node_modules/reka-ui/dist/Popover/PopoverPortal.js
import { defineComponent as defineComponent139, createBlock as createBlock126, openBlock as openBlock131, unref as unref134, normalizeProps as normalizeProps40, guardReactiveProps as guardReactiveProps37, withCtx as withCtx127, renderSlot as renderSlot131 } from "vue";
var _sfc_main134 = defineComponent139({
  __name: "PopoverPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock131(), createBlock126(unref134(_sfc_main27), normalizeProps40(guardReactiveProps37(props2)), {
        default: withCtx127(() => [
          renderSlot131(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Popover/PopoverContent.js
import { defineComponent as defineComponent143, createBlock as createBlock130, openBlock as openBlock135, unref as unref138, withCtx as withCtx131, mergeProps as mergeProps64, renderSlot as renderSlot135 } from "vue";

// node_modules/reka-ui/dist/Popover/PopoverContentModal.js
import { defineComponent as defineComponent141, ref as ref49, createBlock as createBlock128, openBlock as openBlock133, mergeProps as mergeProps62, unref as unref136, withModifiers as withModifiers10, withCtx as withCtx129, renderSlot as renderSlot133 } from "vue";

// node_modules/reka-ui/dist/Popover/PopoverContentImpl.js
import { defineComponent as defineComponent140, createBlock as createBlock127, openBlock as openBlock132, unref as unref135, withCtx as withCtx128, createVNode as createVNode24, mergeProps as mergeProps61, renderSlot as renderSlot132 } from "vue";
var _sfc_main135 = defineComponent140({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardProps(reactiveOmit(props2, "trapFocus", "disableOutsidePointerEvents"));
    const { forwardRef } = useForwardExpose();
    const rootContext = injectPopoverRootContext();
    useFocusGuards();
    return (_ctx, _cache) => {
      return openBlock132(), createBlock127(unref135(_sfc_main15), {
        "as-child": "",
        loop: "",
        trapped: _ctx.trapFocus,
        onMountAutoFocus: _cache[5] || (_cache[5] = ($event) => emits("openAutoFocus", $event)),
        onUnmountAutoFocus: _cache[6] || (_cache[6] = ($event) => emits("closeAutoFocus", $event))
      }, {
        default: withCtx128(() => [
          createVNode24(unref135(_sfc_main14), {
            "as-child": "",
            "disable-outside-pointer-events": _ctx.disableOutsidePointerEvents,
            onPointerDownOutside: _cache[0] || (_cache[0] = ($event) => emits("pointerDownOutside", $event)),
            onInteractOutside: _cache[1] || (_cache[1] = ($event) => emits("interactOutside", $event)),
            onEscapeKeyDown: _cache[2] || (_cache[2] = ($event) => emits("escapeKeyDown", $event)),
            onFocusOutside: _cache[3] || (_cache[3] = ($event) => emits("focusOutside", $event)),
            onDismiss: _cache[4] || (_cache[4] = ($event) => unref135(rootContext).onOpenChange(false))
          }, {
            default: withCtx128(() => [
              createVNode24(unref135(_sfc_main61), mergeProps61(unref135(forwarded), {
                id: unref135(rootContext).contentId,
                ref: unref135(forwardRef),
                "data-state": unref135(rootContext).open.value ? "open" : "closed",
                "aria-labelledby": unref135(rootContext).triggerId,
                style: {
                  "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
                  "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
                  "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
                  "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
                  "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
                },
                role: "dialog"
              }), {
                default: withCtx128(() => [
                  renderSlot132(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["id", "data-state", "aria-labelledby"])
            ]),
            _: 3
          }, 8, ["disable-outside-pointer-events"])
        ]),
        _: 3
      }, 8, ["trapped"]);
    };
  }
});

// node_modules/reka-ui/dist/Popover/PopoverContentModal.js
var _sfc_main136 = defineComponent141({
  __name: "PopoverContentModal",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const isRightClickOutsideRef = ref49(false);
    useBodyScrollLock(true);
    const forwarded = useForwardPropsEmits(props2, emits);
    const { forwardRef, currentElement } = useForwardExpose();
    useHideOthers(currentElement);
    return (_ctx, _cache) => {
      return openBlock133(), createBlock128(_sfc_main135, mergeProps62(unref136(forwarded), {
        ref: unref136(forwardRef),
        "trap-focus": unref136(rootContext).open.value,
        "disable-outside-pointer-events": "",
        onCloseAutoFocus: _cache[0] || (_cache[0] = withModifiers10(
          (event) => {
            emits("closeAutoFocus", event);
            if (!isRightClickOutsideRef.value) unref136(rootContext).triggerElement.value?.focus();
          },
          ["prevent"]
        )),
        onPointerDownOutside: _cache[1] || (_cache[1] = (event) => {
          emits("pointerDownOutside", event);
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          isRightClickOutsideRef.value = isRightClick;
        }),
        onFocusOutside: _cache[2] || (_cache[2] = withModifiers10(() => {
        }, ["prevent"]))
      }), {
        default: withCtx129(() => [
          renderSlot133(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["trap-focus"]);
    };
  }
});

// node_modules/reka-ui/dist/Popover/PopoverContentNonModal.js
import { defineComponent as defineComponent142, ref as ref50, createBlock as createBlock129, openBlock as openBlock134, mergeProps as mergeProps63, unref as unref137, withCtx as withCtx130, renderSlot as renderSlot134 } from "vue";
var _sfc_main137 = defineComponent142({
  __name: "PopoverContentNonModal",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const hasInteractedOutsideRef = ref50(false);
    const hasPointerDownOutsideRef = ref50(false);
    const forwarded = useForwardPropsEmits(props2, emits);
    return (_ctx, _cache) => {
      return openBlock134(), createBlock129(_sfc_main135, mergeProps63(unref137(forwarded), {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          emits("closeAutoFocus", event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.value) unref137(rootContext).triggerElement.value?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.value = false;
          hasPointerDownOutsideRef.value = false;
        }),
        onInteractOutside: _cache[1] || (_cache[1] = async (event) => {
          emits("interactOutside", event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.value = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.value = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = unref137(rootContext).triggerElement.value?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.value) {
            event.preventDefault();
          }
        })
      }), {
        default: withCtx130(() => [
          renderSlot134(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Popover/PopoverContent.js
var _sfc_main138 = defineComponent143({
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const forwarded = useForwardPropsEmits(props2, emits);
    const { forwardRef } = useForwardExpose();
    rootContext.contentId ||= useId2(void 0, "reka-popover-content");
    return (_ctx, _cache) => {
      return openBlock135(), createBlock130(unref138(Presence), {
        present: _ctx.forceMount || unref138(rootContext).open.value
      }, {
        default: withCtx131(() => [
          unref138(rootContext).modal.value ? (openBlock135(), createBlock130(_sfc_main136, mergeProps64({ key: 0 }, unref138(forwarded), { ref: unref138(forwardRef) }), {
            default: withCtx131(() => [
              renderSlot135(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)) : (openBlock135(), createBlock130(_sfc_main137, mergeProps64({ key: 1 }, unref138(forwarded), { ref: unref138(forwardRef) }), {
            default: withCtx131(() => [
              renderSlot135(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerContent.js
var _sfc_main139 = defineComponent144({
  __name: "DatePickerContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    return (_ctx, _cache) => {
      return openBlock136(), createBlock131(unref139(_sfc_main134), null, {
        default: withCtx132(() => [
          createVNode25(unref139(_sfc_main138), normalizeProps41(guardReactiveProps38({ ...unref139(forwarded), ..._ctx.$attrs })), {
            default: withCtx132(() => [
              renderSlot136(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerField.js
import { defineComponent as defineComponent145, createBlock as createBlock132, openBlock as openBlock137, unref as unref140, mergeProps as mergeProps65, withCtx as withCtx133, renderSlot as renderSlot137 } from "vue";
var _sfc_main140 = defineComponent145({
  __name: "DatePickerField",
  setup(__props) {
    const rootContext = injectDatePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock137(), createBlock132(unref140(_sfc_main122), mergeProps65({
        ref: unref140(rootContext).dateFieldRef,
        "model-value": unref140(rootContext).modelValue.value,
        placeholder: unref140(rootContext).placeholder.value
      }, {
        id: unref140(rootContext).id.value,
        name: unref140(rootContext).name.value,
        disabled: unref140(rootContext).disabled.value,
        minValue: unref140(rootContext).minValue.value,
        maxValue: unref140(rootContext).maxValue.value,
        readonly: unref140(rootContext).readonly.value,
        hourCycle: unref140(rootContext).hourCycle.value,
        granularity: unref140(rootContext).granularity.value,
        hideTimeZone: unref140(rootContext).hideTimeZone.value,
        locale: unref140(rootContext).locale.value,
        isDateUnavailable: unref140(rootContext).isDateUnavailable,
        required: unref140(rootContext).required.value,
        dir: unref140(rootContext).dir.value
      }, {
        "onUpdate:modelValue": _cache[0] || (_cache[0] = (date) => {
          if (date && unref140(rootContext).modelValue.value && date.compare(unref140(rootContext).modelValue.value) === 0) return;
          unref140(rootContext).onDateChange(date);
        }),
        "onUpdate:placeholder": _cache[1] || (_cache[1] = (date) => {
          if (date.compare(unref140(rootContext).placeholder.value) === 0) return;
          unref140(rootContext).onPlaceholderChange(date);
        })
      }), {
        default: withCtx133(({ segments, modelValue }) => [
          renderSlot137(_ctx.$slots, "default", {
            segments,
            modelValue
          })
        ]),
        _: 3
      }, 16, ["model-value", "placeholder"]);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerGrid.js
import { defineComponent as defineComponent146, createBlock as createBlock133, openBlock as openBlock138, unref as unref141, normalizeProps as normalizeProps42, guardReactiveProps as guardReactiveProps39, withCtx as withCtx134, renderSlot as renderSlot138 } from "vue";
var _sfc_main141 = defineComponent146({
  __name: "DatePickerGrid",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock138(), createBlock133(unref141(_sfc_main41), normalizeProps42(guardReactiveProps39(props2)), {
        default: withCtx134(() => [
          renderSlot138(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerGridBody.js
import { defineComponent as defineComponent147, createBlock as createBlock134, openBlock as openBlock139, unref as unref142, normalizeProps as normalizeProps43, guardReactiveProps as guardReactiveProps40, withCtx as withCtx135, renderSlot as renderSlot139 } from "vue";
var _sfc_main142 = defineComponent147({
  __name: "DatePickerGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock139(), createBlock134(unref142(_sfc_main42), normalizeProps43(guardReactiveProps40(props2)), {
        default: withCtx135(() => [
          renderSlot139(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerGridHead.js
import { defineComponent as defineComponent148, createBlock as createBlock135, openBlock as openBlock140, unref as unref143, normalizeProps as normalizeProps44, guardReactiveProps as guardReactiveProps41, withCtx as withCtx136, renderSlot as renderSlot140 } from "vue";
var _sfc_main143 = defineComponent148({
  __name: "DatePickerGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock140(), createBlock135(unref143(_sfc_main43), normalizeProps44(guardReactiveProps41(props2)), {
        default: withCtx136(() => [
          renderSlot140(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerGridRow.js
import { defineComponent as defineComponent149, createBlock as createBlock136, openBlock as openBlock141, unref as unref144, normalizeProps as normalizeProps45, guardReactiveProps as guardReactiveProps42, withCtx as withCtx137, renderSlot as renderSlot141 } from "vue";
var _sfc_main144 = defineComponent149({
  __name: "DatePickerGridRow",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock141(), createBlock136(unref144(_sfc_main44), normalizeProps45(guardReactiveProps42(props2)), {
        default: withCtx137(() => [
          renderSlot141(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerHeadCell.js
import { defineComponent as defineComponent150, createBlock as createBlock137, openBlock as openBlock142, unref as unref145, normalizeProps as normalizeProps46, guardReactiveProps as guardReactiveProps43, withCtx as withCtx138, renderSlot as renderSlot142 } from "vue";
var _sfc_main145 = defineComponent150({
  __name: "DatePickerHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock142(), createBlock137(unref145(_sfc_main45), normalizeProps46(guardReactiveProps43(props2)), {
        default: withCtx138(() => [
          renderSlot142(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerHeader.js
import { defineComponent as defineComponent151, createBlock as createBlock138, openBlock as openBlock143, unref as unref146, normalizeProps as normalizeProps47, guardReactiveProps as guardReactiveProps44, withCtx as withCtx139, renderSlot as renderSlot143 } from "vue";
var _sfc_main146 = defineComponent151({
  __name: "DatePickerHeader",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock143(), createBlock138(unref146(_sfc_main46), normalizeProps47(guardReactiveProps44(props2)), {
        default: withCtx139(() => [
          renderSlot143(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerHeading.js
import { defineComponent as defineComponent152, createBlock as createBlock139, openBlock as openBlock144, unref as unref147, normalizeProps as normalizeProps48, guardReactiveProps as guardReactiveProps45, withCtx as withCtx140, renderSlot as renderSlot144, createTextVNode as createTextVNode8, toDisplayString as toDisplayString5 } from "vue";
var _sfc_main147 = defineComponent152({
  __name: "DatePickerHeading",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock144(), createBlock139(unref147(_sfc_main47), normalizeProps48(guardReactiveProps45(props2)), {
        default: withCtx140(({ headingValue }) => [
          renderSlot144(_ctx.$slots, "default", { headingValue }, () => [
            createTextVNode8(toDisplayString5(headingValue), 1)
          ])
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerInput.js
import { defineComponent as defineComponent153, createBlock as createBlock140, openBlock as openBlock145, unref as unref148, normalizeProps as normalizeProps49, guardReactiveProps as guardReactiveProps46, withCtx as withCtx141, renderSlot as renderSlot145 } from "vue";
var _sfc_main148 = defineComponent153({
  __name: "DatePickerInput",
  props: {
    part: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock145(), createBlock140(unref148(_sfc_main123), normalizeProps49(guardReactiveProps46(props2)), {
        default: withCtx141(() => [
          renderSlot145(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerNext.js
import { defineComponent as defineComponent154, createBlock as createBlock141, openBlock as openBlock146, unref as unref149, normalizeProps as normalizeProps50, guardReactiveProps as guardReactiveProps47, withCtx as withCtx142, renderSlot as renderSlot146 } from "vue";
var _sfc_main149 = defineComponent154({
  __name: "DatePickerNext",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock146(), createBlock141(unref149(_sfc_main48), normalizeProps50(guardReactiveProps47(props2)), {
        default: withCtx142((slotProps) => [
          renderSlot146(_ctx.$slots, "default", normalizeProps50(guardReactiveProps47(slotProps)))
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerPrev.js
import { defineComponent as defineComponent155, createBlock as createBlock142, openBlock as openBlock147, unref as unref150, normalizeProps as normalizeProps51, guardReactiveProps as guardReactiveProps48, withCtx as withCtx143, renderSlot as renderSlot147 } from "vue";
var _sfc_main150 = defineComponent155({
  __name: "DatePickerPrev",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock147(), createBlock142(unref150(_sfc_main49), normalizeProps51(guardReactiveProps48(props2)), {
        default: withCtx143((slotProps) => [
          renderSlot147(_ctx.$slots, "default", normalizeProps51(guardReactiveProps48(slotProps)))
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerTrigger.js
import { defineComponent as defineComponent157, createBlock as createBlock144, openBlock as openBlock149, unref as unref152, mergeProps as mergeProps66, withCtx as withCtx145, renderSlot as renderSlot149 } from "vue";

// node_modules/reka-ui/dist/Popover/PopoverTrigger.js
import { defineComponent as defineComponent156, onMounted as onMounted22, createBlock as createBlock143, openBlock as openBlock148, resolveDynamicComponent as resolveDynamicComponent5, unref as unref151, withCtx as withCtx144, createVNode as createVNode26, renderSlot as renderSlot148 } from "vue";
var _sfc_main151 = defineComponent156({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectPopoverRootContext();
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    rootContext.triggerId ||= useId2(void 0, "reka-popover-trigger");
    onMounted22(() => {
      rootContext.triggerElement.value = triggerElement.value;
    });
    return (_ctx, _cache) => {
      return openBlock148(), createBlock143(resolveDynamicComponent5(unref151(rootContext).hasCustomAnchor.value ? unref151(Primitive) : unref151(_sfc_main58)), { "as-child": "" }, {
        default: withCtx144(() => [
          createVNode26(unref151(Primitive), {
            id: unref151(rootContext).triggerId,
            ref: unref151(forwardRef),
            type: _ctx.as === "button" ? "button" : void 0,
            "aria-haspopup": "dialog",
            "aria-expanded": unref151(rootContext).open.value,
            "aria-controls": unref151(rootContext).contentId,
            "data-state": unref151(rootContext).open.value ? "open" : "closed",
            as: _ctx.as,
            "as-child": props2.asChild,
            onClick: unref151(rootContext).onOpenToggle
          }, {
            default: withCtx144(() => [
              renderSlot148(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/DatePicker/DatePickerTrigger.js
var _sfc_main152 = defineComponent157({
  __name: "DatePickerTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDatePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock149(), createBlock144(unref152(_sfc_main151), mergeProps66({ "data-reka-date-field-segment": "trigger" }, props2, {
        disabled: unref152(rootContext).disabled.value,
        onFocusin: _cache[0] || (_cache[0] = (e) => {
          unref152(rootContext).dateFieldRef.value?.setFocusedElement(e.target);
        })
      }), {
        default: withCtx145(() => [
          renderSlot149(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangeField/DateRangeFieldInput.js
import { defineComponent as defineComponent159, ref as ref52, computed as computed51, createBlock as createBlock146, openBlock as openBlock151, unref as unref154, mergeProps as mergeProps68, toHandlers as toHandlers2, withCtx as withCtx147, renderSlot as renderSlot151 } from "vue";

// node_modules/reka-ui/dist/DateRangeField/DateRangeFieldRoot.js
import { defineComponent as defineComponent158, toRefs as toRefs23, ref as ref51, onMounted as onMounted23, computed as computed50, watch as watch23, nextTick as nextTick20, createBlock as createBlock145, openBlock as openBlock150, unref as unref153, mergeProps as mergeProps67, withKeys as withKeys9, withCtx as withCtx146, renderSlot as renderSlot150, createVNode as createVNode27 } from "vue";
var [injectDateRangeFieldRootContext, provideDateRangeFieldRootContext] = createContext("DateRangeFieldRoot");
var _sfc_main153 = defineComponent158({
  ...{
    inheritAttrs: false
  },
  __name: "DateRangeFieldRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    isDateUnavailable: { type: Function, default: void 0 },
    id: {},
    dir: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, readonly: readonly3, isDateUnavailable: propsIsDateUnavailable, dir: propDir, locale: propLocale } = toRefs23(props2);
    const locale = useLocale(propLocale);
    const dir = useDirection(propDir);
    const formatter = useDateFormatter(locale.value);
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const segmentElements = ref51(/* @__PURE__ */ new Set());
    onMounted23(() => {
      getSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
    });
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? { start: void 0, end: void 0 },
      passive: props2.modelValue === void 0
    });
    const defaultDate = getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      granularity: props2.granularity,
      defaultValue: modelValue.value?.start,
      locale: props2.locale
    });
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    const inferredGranularity = computed50(() => {
      if (props2.granularity)
        return !hasTime(placeholder.value) ? "day" : props2.granularity;
      return hasTime(placeholder.value) ? "minute" : "day";
    });
    const isStartInvalid = computed50(() => {
      if (!modelValue.value?.start)
        return false;
      if (propsIsDateUnavailable.value?.(modelValue.value.start))
        return true;
      if (props2.minValue && isBefore(modelValue.value.start, props2.minValue))
        return true;
      if (props2.maxValue && isBefore(props2.maxValue, modelValue.value.start))
        return true;
      return false;
    });
    const isEndInvalid = computed50(() => {
      if (!modelValue.value?.end)
        return false;
      if (propsIsDateUnavailable.value?.(modelValue.value.end))
        return true;
      if (props2.minValue && isBefore(modelValue.value.end, props2.minValue))
        return true;
      if (props2.maxValue && isBefore(props2.maxValue, modelValue.value.end))
        return true;
      return false;
    });
    const isInvalid = computed50(() => {
      if (isStartInvalid.value || isEndInvalid.value)
        return true;
      if (!modelValue.value?.start || !modelValue.value?.end)
        return false;
      if (!isBeforeOrSame(modelValue.value.start, modelValue.value.end))
        return true;
      if (propsIsDateUnavailable.value !== void 0) {
        const allValid = areAllDaysBetweenValid(
          modelValue.value.start,
          modelValue.value.end,
          propsIsDateUnavailable.value,
          void 0
        );
        if (!allValid)
          return true;
      }
      return false;
    });
    const initialSegments = initializeSegmentValues(inferredGranularity.value);
    const startSegmentValues = ref51(modelValue.value?.start ? { ...syncSegmentValues({ value: modelValue.value.start, formatter }) } : { ...initialSegments });
    const endSegmentValues = ref51(modelValue.value?.end ? { ...syncSegmentValues({ value: modelValue.value.end, formatter }) } : { ...initialSegments });
    const startSegmentContent = computed50(() => createContent({
      granularity: inferredGranularity.value,
      dateRef: placeholder.value,
      formatter,
      hideTimeZone: props2.hideTimeZone,
      hourCycle: props2.hourCycle,
      segmentValues: startSegmentValues.value,
      locale
    }));
    const endSegmentContent = computed50(() => createContent({
      granularity: inferredGranularity.value,
      dateRef: placeholder.value,
      formatter,
      hideTimeZone: props2.hideTimeZone,
      hourCycle: props2.hourCycle,
      segmentValues: endSegmentValues.value,
      locale
    }));
    const segmentContents = computed50(() => ({
      start: startSegmentContent.value.arr,
      end: endSegmentContent.value.arr
    }));
    const editableSegmentContents = computed50(() => ({ start: segmentContents.value.start.filter(({ part }) => part !== "literal"), end: segmentContents.value.end.filter(({ part }) => part !== "literal") }));
    const startValue = ref51(modelValue.value?.start?.copy());
    const endValue = ref51(modelValue.value?.end?.copy());
    watch23([startValue, endValue], ([_startValue, _endValue]) => {
      modelValue.value = { start: _startValue?.copy(), end: _endValue?.copy() };
    });
    watch23(modelValue, (_modelValue) => {
      if (_modelValue && _modelValue.start && _modelValue.end) {
        if (!startValue.value || _modelValue.start.compare(startValue.value) !== 0)
          startValue.value = _modelValue.start.copy();
        if (!endValue.value || _modelValue.end.compare(endValue.value) !== 0)
          endValue.value = _modelValue.end.copy();
      }
      if (!_modelValue) {
        startValue.value = void 0;
        endValue.value = void 0;
      }
    });
    watch23([startValue, locale], ([_startValue]) => {
      if (_startValue !== void 0) {
        startSegmentValues.value = { ...syncSegmentValues({ value: _startValue, formatter }) };
      } else if (Object.values(startSegmentValues.value).every((value) => value !== null) && _startValue === void 0) {
        startSegmentValues.value = { ...initialSegments };
      }
    });
    watch23(locale, (value) => {
      if (formatter.getLocale() !== value) {
        formatter.setLocale(value);
        nextTick20(() => {
          segmentElements.value.clear();
          getSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
        });
      }
    });
    watch23(modelValue, (_modelValue) => {
      if (_modelValue && _modelValue.start !== void 0 && placeholder.value.compare(_modelValue.start) !== 0)
        placeholder.value = _modelValue.start.copy();
    });
    watch23([endValue, locale], ([_endValue]) => {
      if (_endValue !== void 0) {
        endSegmentValues.value = { ...syncSegmentValues({ value: _endValue, formatter }) };
      } else if (Object.values(endSegmentValues.value).every((value) => value !== null) && _endValue === void 0) {
        endSegmentValues.value = { ...initialSegments };
      }
    });
    const currentFocusedElement = ref51(null);
    const currentSegmentIndex = computed50(() => Array.from(segmentElements.value).findIndex((el) => el.getAttribute("data-reka-date-field-segment") === currentFocusedElement.value?.getAttribute("data-reka-date-field-segment") && el.getAttribute("data-reka-date-range-field-segment-type") === currentFocusedElement.value?.getAttribute("data-reka-date-range-field-segment-type")));
    const nextFocusableSegment = computed50(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const nextCondition = sign < 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (nextCondition)
        return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value + sign];
      return segmentToFocus;
    });
    const prevFocusableSegment = computed50(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const prevCondition = sign > 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (prevCondition)
        return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value - sign];
      return segmentToFocus;
    });
    const kbd = useKbd();
    function handleKeydown(e) {
      if (!isSegmentNavigationKey(e.key))
        return;
      if (e.key === kbd.ARROW_LEFT)
        prevFocusableSegment.value?.focus();
      if (e.key === kbd.ARROW_RIGHT)
        nextFocusableSegment.value?.focus();
    }
    function setFocusedElement(el) {
      currentFocusedElement.value = el;
    }
    provideDateRangeFieldRootContext({
      isDateUnavailable: propsIsDateUnavailable.value,
      locale,
      startValue,
      endValue,
      placeholder,
      disabled,
      formatter,
      hourCycle: props2.hourCycle,
      readonly: readonly3,
      segmentValues: { start: startSegmentValues, end: endSegmentValues },
      isInvalid,
      segmentContents: editableSegmentContents,
      elements: segmentElements,
      setFocusedElement,
      focusNext() {
        nextFocusableSegment.value?.focus();
      }
    });
    __expose({
      setFocusedElement
    });
    return (_ctx, _cache) => {
      return openBlock150(), createBlock145(unref153(Primitive), mergeProps67(_ctx.$attrs, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        role: "group",
        "aria-disabled": unref153(disabled) ? true : void 0,
        "data-disabled": unref153(disabled) ? "" : void 0,
        "data-readonly": unref153(readonly3) ? "" : void 0,
        "data-invalid": isInvalid.value ? "" : void 0,
        dir: unref153(dir),
        onKeydown: withKeys9(handleKeydown, ["left", "right"])
      }), {
        default: withCtx146(() => [
          renderSlot150(_ctx.$slots, "default", {
            modelValue: unref153(modelValue),
            segments: segmentContents.value
          }),
          createVNode27(unref153(_sfc_main), {
            id: _ctx.id,
            as: "input",
            feature: "focusable",
            tabindex: "-1",
            value: `${unref153(modelValue)?.start?.toString()} - ${unref153(modelValue)?.end?.toString()}`,
            name: _ctx.name,
            disabled: unref153(disabled),
            required: _ctx.required,
            onFocus: _cache[0] || (_cache[0] = ($event) => Array.from(segmentElements.value)?.[0]?.focus())
          }, null, 8, ["id", "value", "name", "disabled", "required"])
        ]),
        _: 3
      }, 16, ["aria-disabled", "data-disabled", "data-readonly", "data-invalid", "dir"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangeField/DateRangeFieldInput.js
var _sfc_main154 = defineComponent159({
  __name: "DateRangeFieldInput",
  props: {
    part: {},
    type: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDateRangeFieldRootContext();
    const hasLeftFocus = ref52(true);
    const lastKeyZero = ref52(false);
    const {
      handleSegmentClick,
      handleSegmentKeydown,
      attributes
    } = useDateField({
      hasLeftFocus,
      lastKeyZero,
      placeholder: rootContext.placeholder,
      hourCycle: rootContext.hourCycle,
      segmentValues: rootContext.segmentValues[props2.type],
      formatter: rootContext.formatter,
      part: props2.part,
      disabled: rootContext.disabled,
      readonly: rootContext.readonly,
      focusNext: rootContext.focusNext,
      modelValue: props2.type === "start" ? rootContext.startValue : rootContext.endValue
    });
    const disabled = computed51(() => rootContext.disabled.value);
    const readonly3 = computed51(() => rootContext.readonly.value);
    const isInvalid = computed51(() => rootContext.isInvalid.value);
    return (_ctx, _cache) => {
      return openBlock151(), createBlock146(unref154(Primitive), mergeProps68({
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, unref154(attributes), {
        contenteditable: disabled.value || readonly3.value ? false : _ctx.part !== "literal",
        "data-reka-date-field-segment": _ctx.part,
        "aria-disabled": disabled.value ? true : void 0,
        "aria-readonly": readonly3.value ? true : void 0,
        "data-disabled": disabled.value ? "" : void 0,
        "data-reka-date-range-field-segment-type": _ctx.type,
        "data-invalid": isInvalid.value ? "" : void 0,
        "aria-invalid": isInvalid.value ? true : void 0
      }, toHandlers2(_ctx.part !== "literal" ? {
        mousedown: unref154(handleSegmentClick),
        keydown: unref154(handleSegmentKeydown),
        focusout: () => {
          hasLeftFocus.value = true;
        },
        focusin: (e) => {
          unref154(rootContext).setFocusedElement(e.target);
        }
      } : {})), {
        default: withCtx147(() => [
          renderSlot151(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["as", "as-child", "contenteditable", "data-reka-date-field-segment", "aria-disabled", "aria-readonly", "data-disabled", "data-reka-date-range-field-segment-type", "data-invalid", "aria-invalid"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerAnchor.js
import { defineComponent as defineComponent160, createBlock as createBlock147, openBlock as openBlock152, unref as unref155, normalizeProps as normalizeProps52, guardReactiveProps as guardReactiveProps49, withCtx as withCtx148, renderSlot as renderSlot152 } from "vue";
var _sfc_main155 = defineComponent160({
  __name: "DateRangePickerAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock152(), createBlock147(unref155(_sfc_main125), normalizeProps52(guardReactiveProps49(props2)), {
        default: withCtx148(() => [
          renderSlot152(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerArrow.js
import { defineComponent as defineComponent161, createBlock as createBlock148, openBlock as openBlock153, unref as unref156, normalizeProps as normalizeProps53, guardReactiveProps as guardReactiveProps50, withCtx as withCtx149, renderSlot as renderSlot153 } from "vue";
var _sfc_main156 = defineComponent161({
  __name: "DateRangePickerArrow",
  props: {
    width: {},
    height: {},
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock153(), createBlock148(unref156(_sfc_main126), normalizeProps53(guardReactiveProps50(props2)), {
        default: withCtx149(() => [
          renderSlot153(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerCalendar.js
import { defineComponent as defineComponent164, createBlock as createBlock151, openBlock as openBlock156, unref as unref159, mergeProps as mergeProps69, withCtx as withCtx152, renderSlot as renderSlot156 } from "vue";

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerRoot.js
import { defineComponent as defineComponent162, toRefs as toRefs24, ref as ref53, watch as watch24, createBlock as createBlock149, openBlock as openBlock154, unref as unref157, isRef as isRef7, withCtx as withCtx150, renderSlot as renderSlot154 } from "vue";
var [injectDateRangePickerRootContext, provideDateRangePickerRootContext] = createContext("DateRangePickerRoot");
var _sfc_main157 = defineComponent162({
  ...{
    inheritAttrs: false
  },
  __name: "DateRangePickerRoot",
  props: {
    defaultValue: { default: () => ({ start: void 0, end: void 0 }) },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: { default: "en" },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    isDateUnavailable: { type: Function, default: void 0 },
    id: {},
    dir: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: false },
    isDateDisabled: { type: Function, default: void 0 },
    pagedNavigation: { type: Boolean, default: false },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    fixedWeeks: { type: Boolean, default: false },
    numberOfMonths: { default: 1 },
    preventDeselect: { type: Boolean, default: false },
    isDateHighlightable: { type: Function, default: void 0 },
    allowNonContiguousRanges: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "update:placeholder", "update:startValue", "update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const {
      locale,
      disabled,
      readonly: readonly3,
      pagedNavigation,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      numberOfMonths,
      preventDeselect,
      isDateDisabled: propsIsDateDisabled,
      isDateUnavailable: propsIsDateUnavailable,
      isDateHighlightable: propsIsDateHighlightable,
      defaultOpen,
      modal,
      id,
      name,
      required,
      minValue,
      maxValue,
      granularity,
      hideTimeZone,
      hourCycle,
      dir: propsDir,
      allowNonContiguousRanges
    } = toRefs24(props2);
    const dir = useDirection(propsDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? { start: void 0, end: void 0 },
      passive: props2.modelValue === void 0
    });
    const defaultDate = getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      granularity: props2.granularity,
      defaultValue: modelValue.value?.start,
      locale: props2.locale
    });
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    const open = useVModel(props2, "open", emits, {
      defaultValue: defaultOpen.value,
      passive: props2.open === void 0
    });
    const dateFieldRef = ref53();
    watch24(modelValue, (value) => {
      if (value && value.start && value.start.compare(placeholder.value) !== 0) {
        placeholder.value = value.start.copy();
      }
    });
    provideDateRangePickerRootContext({
      allowNonContiguousRanges,
      isDateUnavailable: propsIsDateUnavailable.value,
      isDateDisabled: propsIsDateDisabled.value,
      isDateHighlightable: propsIsDateHighlightable.value,
      locale,
      disabled,
      pagedNavigation,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      numberOfMonths,
      readonly: readonly3,
      preventDeselect,
      modelValue,
      placeholder,
      defaultOpen,
      modal,
      open,
      id,
      name,
      required,
      minValue,
      maxValue,
      granularity,
      hideTimeZone,
      hourCycle,
      dateFieldRef,
      dir,
      onStartValueChange(date) {
        emits("update:startValue", date);
      },
      onDateChange(date) {
        modelValue.value = { start: date.start?.copy(), end: date.end?.copy() };
      },
      onPlaceholderChange(date) {
        placeholder.value = date.copy();
      }
    });
    return (_ctx, _cache) => {
      return openBlock154(), createBlock149(unref157(_sfc_main124), {
        open: unref157(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef7(open) ? open.value = $event : null),
        "default-open": unref157(defaultOpen),
        modal: unref157(modal)
      }, {
        default: withCtx150(() => [
          renderSlot154(_ctx.$slots, "default", {
            modelValue: unref157(modelValue),
            open: unref157(open)
          })
        ]),
        _: 3
      }, 8, ["open", "default-open", "modal"]);
    };
  }
});

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarRoot.js
import { defineComponent as defineComponent163, toRefs as toRefs25, ref as ref54, computed as computed53, watch as watch25, onMounted as onMounted24, createBlock as createBlock150, openBlock as openBlock155, unref as unref158, withCtx as withCtx151, createElementVNode as createElementVNode2, renderSlot as renderSlot155, toDisplayString as toDisplayString6 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/useRangeCalendar.js
import { computed as computed52 } from "vue";
function useRangeCalendarState(props2) {
  const isStartInvalid = computed52(() => {
    if (!props2.start.value)
      return false;
    if (props2.isDateDisabled(props2.start.value))
      return true;
    return false;
  });
  const isEndInvalid = computed52(() => {
    if (!props2.end.value)
      return false;
    if (props2.isDateDisabled(props2.end.value))
      return true;
    return false;
  });
  const isInvalid = computed52(
    () => {
      if (isStartInvalid.value || isEndInvalid.value)
        return false;
      if (props2.start.value && props2.end.value && isBefore(props2.end.value, props2.start.value))
        return true;
      return false;
    }
  );
  const isSelectionStart = (date) => {
    if (!props2.start.value)
      return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.start.value, date);
  };
  const isSelectionEnd = (date) => {
    if (!props2.end.value)
      return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.end.value, date);
  };
  const isSelected = (date) => {
    if (props2.start.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.start.value, date))
      return true;
    if (props2.end.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.end.value, date))
      return true;
    if (props2.end.value && props2.start.value)
      return isBetween(date, props2.start.value, props2.end.value);
    return false;
  };
  const isDateHighlightable = (date) => {
    if (props2.isDateHighlightable?.(date))
      return true;
    return false;
  };
  const highlightedRange = computed52(() => {
    if (props2.start.value && props2.end.value)
      return null;
    if (!props2.start.value || !props2.focusedValue.value)
      return null;
    const isStartBeforeFocused = isBefore(props2.start.value, props2.focusedValue.value);
    const start = isStartBeforeFocused ? props2.start.value : props2.focusedValue.value;
    const end = isStartBeforeFocused ? props2.focusedValue.value : props2.start.value;
    if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start, end)) {
      return {
        start,
        end
      };
    }
    const isValid = areAllDaysBetweenValid(start, end, props2.allowNonContiguousRanges.value ? () => false : props2.isDateUnavailable, props2.isDateDisabled, props2.isDateHighlightable);
    if (isValid) {
      return {
        start,
        end
      };
    }
    return null;
  });
  const isHighlightedStart = (date) => {
    if (!highlightedRange.value || !highlightedRange.value.start)
      return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(highlightedRange.value.start, date);
  };
  const isHighlightedEnd = (date) => {
    if (!highlightedRange.value || !highlightedRange.value.end)
      return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(highlightedRange.value.end, date);
  };
  return {
    isInvalid,
    isSelected,
    isDateHighlightable,
    highlightedRange,
    isSelectionStart,
    isSelectionEnd,
    isHighlightedStart,
    isHighlightedEnd
  };
}

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarRoot.js
var _hoisted_13 = { style: { "border": "0px", "clip": "rect(0px, 0px, 0px, 0px)", "clip-path": "inset(50%)", "height": "1px", "margin": "-1px", "overflow": "hidden", "padding": "0px", "position": "absolute", "white-space": "nowrap", "width": "1px" } };
var _hoisted_23 = {
  role: "heading",
  "aria-level": "2"
};
var [injectRangeCalendarRootContext, provideRangeCalendarRootContext] = createContext("RangeCalendarRoot");
var _sfc_main158 = defineComponent163({
  __name: "RangeCalendarRoot",
  props: {
    defaultPlaceholder: {},
    defaultValue: { default: () => ({ start: void 0, end: void 0 }) },
    modelValue: {},
    placeholder: { default: void 0 },
    allowNonContiguousRanges: { type: Boolean, default: false },
    pagedNavigation: { type: Boolean, default: false },
    preventDeselect: { type: Boolean, default: false },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    calendarLabel: {},
    fixedWeeks: { type: Boolean, default: false },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: { default: 1 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    initialFocus: { type: Boolean, default: false },
    isDateDisabled: { type: Function, default: void 0 },
    isDateUnavailable: { type: Function, default: void 0 },
    isDateHighlightable: { type: Function, default: void 0 },
    dir: {},
    nextPage: {},
    prevPage: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  emits: ["update:modelValue", "update:placeholder", "update:startValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const {
      disabled,
      readonly: readonly3,
      initialFocus,
      pagedNavigation,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      numberOfMonths,
      preventDeselect,
      isDateUnavailable: propsIsDateUnavailable,
      isDateHighlightable: propsIsDateHighlightable,
      isDateDisabled: propsIsDateDisabled,
      calendarLabel,
      maxValue,
      minValue,
      dir: propDir,
      locale: propLocale,
      nextPage: propsNextPage,
      prevPage: propsPrevPage,
      allowNonContiguousRanges
    } = toRefs25(props2);
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const dir = useDirection(propDir);
    const locale = useLocale(propLocale);
    const lastPressedDateValue = ref54();
    const focusedValue = ref54();
    const isEditing = ref54(false);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? { start: void 0, end: void 0 },
      passive: props2.modelValue === void 0
    });
    const currentModelValue = computed53(() => isNullish(modelValue.value) ? { start: void 0, end: void 0 } : modelValue.value);
    const defaultDate = getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      defaultValue: currentModelValue.value.start,
      locale: props2.locale
    });
    const startValue = ref54(currentModelValue.value.start);
    const endValue = ref54(currentModelValue.value.end);
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    function onPlaceholderChange(value) {
      placeholder.value = value.copy();
    }
    const {
      fullCalendarLabel,
      headingValue,
      isDateDisabled,
      isDateUnavailable,
      isNextButtonDisabled,
      isPrevButtonDisabled,
      grid,
      weekdays,
      isOutsideVisibleView,
      nextPage,
      prevPage,
      formatter
    } = useCalendar({
      locale,
      placeholder,
      weekStartsOn,
      fixedWeeks,
      numberOfMonths,
      minValue,
      maxValue,
      disabled,
      weekdayFormat,
      pagedNavigation,
      isDateDisabled: propsIsDateDisabled.value,
      isDateUnavailable: propsIsDateUnavailable.value,
      calendarLabel,
      nextPage: propsNextPage,
      prevPage: propsPrevPage
    });
    const {
      isInvalid,
      isSelected,
      isDateHighlightable,
      highlightedRange,
      isSelectionStart,
      isSelectionEnd,
      isHighlightedStart,
      isHighlightedEnd
    } = useRangeCalendarState({
      start: startValue,
      end: endValue,
      isDateDisabled,
      isDateUnavailable,
      isDateHighlightable: propsIsDateHighlightable.value,
      focusedValue,
      allowNonContiguousRanges
    });
    watch25(modelValue, (_modelValue, _prevValue) => {
      if (!_prevValue?.start && _modelValue?.start || !_modelValue || !_modelValue.start || startValue.value && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(_modelValue.start, startValue.value)) {
        startValue.value = _modelValue?.start?.copy?.();
      }
      if (!_prevValue?.end && _modelValue.end || !_modelValue || !_modelValue.end || endValue.value && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(_modelValue.end, endValue.value)) {
        endValue.value = _modelValue?.end?.copy?.();
      }
    });
    watch25(startValue, (_startValue) => {
      if (_startValue && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(_startValue, placeholder.value))
        onPlaceholderChange(_startValue);
      emits("update:startValue", _startValue);
    });
    watch25([startValue, endValue], ([_startValue, _endValue]) => {
      const value = currentModelValue.value;
      if (value && value.start && value.end && _startValue && _endValue && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value.start, _startValue) && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value.end, _endValue))
        return;
      isEditing.value = true;
      if (_startValue && _endValue) {
        isEditing.value = false;
        if (value.start && value.end && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value.start, _startValue) && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value.end, _endValue))
          return;
        if (isBefore(_endValue, _startValue)) {
          modelValue.value = {
            start: _endValue.copy(),
            end: _startValue.copy()
          };
        } else {
          modelValue.value = {
            start: _startValue.copy(),
            end: _endValue.copy()
          };
        }
      }
    });
    const kbd = useKbd();
    useEventListener("keydown", (ev) => {
      if (ev.key === kbd.ESCAPE && isEditing.value) {
        startValue.value = modelValue.value.start?.copy();
        endValue.value = modelValue.value.end?.copy();
      }
    });
    provideRangeCalendarRootContext({
      isDateUnavailable,
      isDateHighlightable,
      startValue,
      endValue,
      formatter,
      modelValue,
      placeholder,
      disabled,
      initialFocus,
      pagedNavigation,
      grid,
      weekDays: weekdays,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      numberOfMonths,
      readonly: readonly3,
      preventDeselect,
      fullCalendarLabel,
      headingValue,
      isInvalid,
      isDateDisabled,
      highlightedRange,
      focusedValue,
      lastPressedDateValue,
      isSelected,
      isSelectionEnd,
      isSelectionStart,
      isNextButtonDisabled,
      isPrevButtonDisabled,
      isOutsideVisibleView,
      nextPage,
      prevPage,
      parentElement,
      onPlaceholderChange,
      locale,
      dir,
      isHighlightedStart,
      isHighlightedEnd
    });
    onMounted24(() => {
      if (initialFocus.value)
        handleCalendarInitialFocus(parentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock155(), createBlock150(unref158(Primitive), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        role: "application",
        "aria-label": unref158(fullCalendarLabel),
        "data-readonly": unref158(readonly3) ? "" : void 0,
        "data-disabled": unref158(disabled) ? "" : void 0,
        "data-invalid": unref158(isInvalid) ? "" : void 0,
        dir: unref158(dir)
      }, {
        default: withCtx151(() => [
          createElementVNode2("div", _hoisted_13, [
            createElementVNode2("div", _hoisted_23, toDisplayString6(unref158(fullCalendarLabel)), 1)
          ]),
          renderSlot155(_ctx.$slots, "default", {
            date: unref158(placeholder),
            grid: unref158(grid),
            weekDays: unref158(weekdays),
            weekStartsOn: unref158(weekStartsOn),
            locale: unref158(locale),
            fixedWeeks: unref158(fixedWeeks),
            modelValue: unref158(modelValue)
          })
        ]),
        _: 3
      }, 8, ["as", "as-child", "aria-label", "data-readonly", "data-disabled", "data-invalid", "dir"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerCalendar.js
var _sfc_main159 = defineComponent164({
  __name: "DateRangePickerCalendar",
  setup(__props) {
    const rootContext = injectDateRangePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock156(), createBlock151(unref159(_sfc_main158), mergeProps69({
        allowNonContiguousRanges: unref159(rootContext).allowNonContiguousRanges.value,
        isDateDisabled: unref159(rootContext).isDateDisabled,
        isDateUnavailable: unref159(rootContext).isDateUnavailable,
        isDateHighlightable: unref159(rootContext).isDateHighlightable,
        locale: unref159(rootContext).locale.value,
        disabled: unref159(rootContext).disabled.value,
        pagedNavigation: unref159(rootContext).pagedNavigation.value,
        weekStartsOn: unref159(rootContext).weekStartsOn.value,
        weekdayFormat: unref159(rootContext).weekdayFormat.value,
        fixedWeeks: unref159(rootContext).fixedWeeks.value,
        numberOfMonths: unref159(rootContext).numberOfMonths.value,
        readonly: unref159(rootContext).readonly.value,
        preventDeselect: unref159(rootContext).preventDeselect.value,
        minValue: unref159(rootContext).minValue.value,
        maxValue: unref159(rootContext).maxValue.value,
        dir: unref159(rootContext).dir.value
      }, {
        "initial-focus": "",
        "model-value": unref159(rootContext).modelValue.value,
        placeholder: unref159(rootContext).placeholder.value,
        "onUpdate:startValue": _cache[0] || (_cache[0] = (date) => {
          unref159(rootContext).onStartValueChange(date);
        }),
        "onUpdate:modelValue": _cache[1] || (_cache[1] = (date) => {
          if (date.start && unref159(rootContext).modelValue.value?.start && date.end && unref159(rootContext).modelValue.value?.end && unref159($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date.start, unref159(rootContext).modelValue.value?.start) && unref159($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date.end, unref159(rootContext).modelValue.value?.end)) return;
          unref159(rootContext).onDateChange(date);
        }),
        "onUpdate:placeholder": _cache[2] || (_cache[2] = (date) => {
          if (unref159($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date, unref159(rootContext).placeholder.value)) return;
          unref159(rootContext).onPlaceholderChange(date);
        })
      }), {
        default: withCtx152(({ weekDays, grid, date, weekStartsOn, locale, fixedWeeks }) => [
          renderSlot156(_ctx.$slots, "default", {
            date,
            grid,
            weekDays,
            weekStartsOn,
            locale,
            fixedWeeks
          })
        ]),
        _: 3
      }, 16, ["model-value", "placeholder"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerCell.js
import { defineComponent as defineComponent166, createBlock as createBlock153, openBlock as openBlock158, unref as unref161, normalizeProps as normalizeProps54, guardReactiveProps as guardReactiveProps51, withCtx as withCtx154, renderSlot as renderSlot158 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarCell.js
import { defineComponent as defineComponent165, createBlock as createBlock152, openBlock as openBlock157, unref as unref160, withCtx as withCtx153, renderSlot as renderSlot157 } from "vue";
var _sfc_main160 = defineComponent165({
  __name: "RangeCalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: { default: "td" }
  },
  setup(__props) {
    const rootContext = injectRangeCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock157(), createBlock152(unref160(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        role: "gridcell",
        "aria-selected": unref160(rootContext).isSelected(_ctx.date) ? true : void 0,
        "aria-disabled": unref160(rootContext).isDateDisabled(_ctx.date) || unref160(rootContext).isDateUnavailable?.(_ctx.date),
        "data-disabled": unref160(rootContext).isDateDisabled(_ctx.date) ? "" : void 0
      }, {
        default: withCtx153(() => [
          renderSlot157(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "aria-selected", "aria-disabled", "data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerCell.js
var _sfc_main161 = defineComponent166({
  __name: "DateRangePickerCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock158(), createBlock153(unref161(_sfc_main160), normalizeProps54(guardReactiveProps51(props2)), {
        default: withCtx154(() => [
          renderSlot158(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerCellTrigger.js
import { defineComponent as defineComponent168, createBlock as createBlock155, openBlock as openBlock160, unref as unref163, normalizeProps as normalizeProps55, guardReactiveProps as guardReactiveProps52, withCtx as withCtx156, renderSlot as renderSlot160 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarCellTrigger.js
import { defineComponent as defineComponent167, computed as computed54, createBlock as createBlock154, openBlock as openBlock159, unref as unref162, mergeProps as mergeProps70, withKeys as withKeys10, withCtx as withCtx155, renderSlot as renderSlot159, createTextVNode as createTextVNode9, toDisplayString as toDisplayString7, nextTick as nextTick21 } from "vue";
var _sfc_main162 = defineComponent167({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectRangeCalendarRootContext();
    const kbd = useKbd();
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const labelText = computed54(() => rootContext.formatter.custom(toDate(props2.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    }));
    const isDisabled = computed54(() => rootContext.isDateDisabled(props2.day));
    const isUnavailable = computed54(() => rootContext.isDateUnavailable?.(props2.day) ?? false);
    const isSelectedDate = computed54(() => rootContext.isSelected(props2.day));
    const isSelectionStart = computed54(() => rootContext.isSelectionStart(props2.day));
    const isSelectionEnd = computed54(() => rootContext.isSelectionEnd(props2.day));
    const isHighlightStart = computed54(() => rootContext.isHighlightedStart(props2.day));
    const isHighlightEnd = computed54(() => rootContext.isHighlightedEnd(props2.day));
    const isHighlighted = computed54(() => rootContext.highlightedRange.value ? isBetweenInclusive(props2.day, rootContext.highlightedRange.value.start, rootContext.highlightedRange.value.end) : false);
    const isDateToday = computed54(() => {
      return $14e0f24ef4ac5c92$export$629b0a497aa65267(props2.day, $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
    });
    const isOutsideView = computed54(() => {
      return !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(props2.day, props2.month);
    });
    const isOutsideVisibleView = computed54(
      () => rootContext.isOutsideVisibleView(props2.day)
    );
    const dayValue = computed54(() => props2.day.day.toLocaleString(rootContext.locale.value));
    const isFocusedDate = computed54(() => {
      return !rootContext.disabled.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.day, rootContext.placeholder.value);
    });
    function changeDate(e, date) {
      if (rootContext.readonly.value)
        return;
      if (rootContext.isDateDisabled(date) || rootContext.isDateUnavailable?.(date))
        return;
      rootContext.lastPressedDateValue.value = date.copy();
      if (rootContext.startValue.value && rootContext.highlightedRange.value === null) {
        if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(date, rootContext.startValue.value) && !rootContext.preventDeselect.value && !rootContext.endValue.value) {
          rootContext.startValue.value = void 0;
          rootContext.onPlaceholderChange(date);
          return;
        } else if (!rootContext.endValue.value) {
          e.preventDefault();
          if (rootContext.lastPressedDateValue.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(rootContext.lastPressedDateValue.value, date))
            rootContext.startValue.value = date.copy();
          return;
        }
      }
      if (rootContext.startValue.value && rootContext.endValue.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(rootContext.endValue.value, date) && !rootContext.preventDeselect.value) {
        rootContext.startValue.value = void 0;
        rootContext.endValue.value = void 0;
        rootContext.onPlaceholderChange(date);
        return;
      }
      if (!rootContext.startValue.value) {
        rootContext.startValue.value = date.copy();
      } else if (!rootContext.endValue.value) {
        rootContext.endValue.value = date.copy();
      } else if (rootContext.endValue.value && rootContext.startValue.value) {
        rootContext.endValue.value = void 0;
        rootContext.startValue.value = date.copy();
      }
    }
    function handleClick(e) {
      changeDate(e, props2.day);
    }
    function handleFocus() {
      if (rootContext.isDateDisabled(props2.day) || rootContext.isDateUnavailable?.(props2.day))
        return;
      rootContext.focusedValue.value = props2.day.copy();
    }
    function handleArrowKey(e) {
      e.preventDefault();
      e.stopPropagation();
      const parentElement = rootContext.parentElement.value;
      const indexIncrementation = 7;
      const sign = rootContext.dir.value === "rtl" ? -1 : 1;
      switch (e.code) {
        case kbd.ARROW_RIGHT:
          shiftFocus(currentElement.value, sign);
          break;
        case kbd.ARROW_LEFT:
          shiftFocus(currentElement.value, -sign);
          break;
        case kbd.ARROW_UP:
          shiftFocus(currentElement.value, -7);
          break;
        case kbd.ARROW_DOWN:
          shiftFocus(currentElement.value, indexIncrementation);
          break;
        case kbd.ENTER:
        case kbd.SPACE_CODE:
          changeDate(e, props2.day);
      }
      function shiftFocus(node, add) {
        const allCollectionItems = getSelectableCells(parentElement);
        if (!allCollectionItems.length)
          return;
        const index = allCollectionItems.indexOf(node);
        const newIndex = index + add;
        if (newIndex >= 0 && newIndex < allCollectionItems.length) {
          if (allCollectionItems[newIndex].hasAttribute("data-disabled")) {
            shiftFocus(allCollectionItems[newIndex], add);
          }
          allCollectionItems[newIndex].focus();
          return;
        }
        if (newIndex < 0) {
          if (rootContext.isPrevButtonDisabled())
            return;
          rootContext.prevPage();
          nextTick21(() => {
            const newCollectionItems = getSelectableCells(parentElement);
            if (!newCollectionItems.length)
              return;
            if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {
              const numberOfDays = getDaysInMonth(rootContext.placeholder.value);
              const computedIndex2 = numberOfDays - Math.abs(newIndex);
              if (newCollectionItems[computedIndex2].hasAttribute("data-disabled")) {
                shiftFocus(newCollectionItems[computedIndex2], add);
              }
              newCollectionItems[computedIndex2].focus();
              return;
            }
            const computedIndex = newCollectionItems.length - Math.abs(newIndex);
            if (newCollectionItems[computedIndex].hasAttribute("data-disabled")) {
              shiftFocus(newCollectionItems[computedIndex], add);
            }
            newCollectionItems[computedIndex].focus();
          });
          return;
        }
        if (newIndex >= allCollectionItems.length) {
          if (rootContext.isNextButtonDisabled())
            return;
          rootContext.nextPage();
          nextTick21(() => {
            const newCollectionItems = getSelectableCells(parentElement);
            if (!newCollectionItems.length)
              return;
            if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {
              const numberOfDays = getDaysInMonth(
                rootContext.placeholder.value.add({ months: rootContext.numberOfMonths.value - 1 })
              );
              const computedIndex2 = newIndex - allCollectionItems.length + (newCollectionItems.length - numberOfDays);
              if (newCollectionItems[computedIndex2].hasAttribute("data-disabled")) {
                shiftFocus(newCollectionItems[computedIndex2], add);
              }
              newCollectionItems[computedIndex2].focus();
              return;
            }
            const computedIndex = newIndex - allCollectionItems.length;
            if (newCollectionItems[computedIndex].hasAttribute("data-disabled")) {
              shiftFocus(newCollectionItems[computedIndex], add);
            }
            newCollectionItems[computedIndex].focus();
          });
        }
      }
    }
    return (_ctx, _cache) => {
      return openBlock159(), createBlock154(unref162(Primitive), mergeProps70({
        ref_key: "primitiveElement",
        ref: primitiveElement
      }, props2, {
        role: "button",
        "aria-label": labelText.value,
        "data-reka-calendar-cell-trigger": "",
        "aria-selected": isSelectedDate.value && !isUnavailable.value ? true : void 0,
        "aria-disabled": isDisabled.value || isUnavailable.value ? true : void 0,
        "data-highlighted": isHighlighted.value && !isUnavailable.value ? "" : void 0,
        "data-selection-start": isSelectionStart.value ? true : void 0,
        "data-selection-end": isSelectionEnd.value ? true : void 0,
        "data-highlighted-start": isHighlightStart.value ? true : void 0,
        "data-highlighted-end": isHighlightEnd.value ? true : void 0,
        "data-selected": isSelectedDate.value && !isUnavailable.value ? true : void 0,
        "data-outside-visible-view": isOutsideVisibleView.value ? "" : void 0,
        "data-value": _ctx.day.toString(),
        "data-disabled": isDisabled.value ? "" : void 0,
        "data-unavailable": isUnavailable.value ? "" : void 0,
        "data-today": isDateToday.value ? "" : void 0,
        "data-outside-view": isOutsideView.value ? "" : void 0,
        "data-focused": isFocusedDate.value ? "" : void 0,
        tabindex: isFocusedDate.value ? 0 : isOutsideView.value || isDisabled.value ? void 0 : -1,
        onClick: handleClick,
        onFocusin: handleFocus,
        onMouseenter: handleFocus,
        onKeydown: withKeys10(handleArrowKey, ["up", "down", "left", "right", "enter", "space"])
      }), {
        default: withCtx155(() => [
          renderSlot159(_ctx.$slots, "default", {
            dayValue: dayValue.value,
            disabled: isDisabled.value,
            today: isDateToday.value,
            selected: isSelectedDate.value,
            outsideView: isOutsideView.value,
            outsideVisibleView: isOutsideVisibleView.value,
            unavailable: isUnavailable.value,
            highlighted: isHighlighted.value && !isUnavailable.value,
            highlightedStart: isHighlightStart.value,
            highlightedEnd: isHighlightEnd.value,
            selectionStart: isSelectionStart.value,
            selectionEnd: isSelectionEnd.value
          }, () => [
            createTextVNode9(toDisplayString7(dayValue.value), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-label", "aria-selected", "aria-disabled", "data-highlighted", "data-selection-start", "data-selection-end", "data-highlighted-start", "data-highlighted-end", "data-selected", "data-outside-visible-view", "data-value", "data-disabled", "data-unavailable", "data-today", "data-outside-view", "data-focused", "tabindex"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerCellTrigger.js
var _sfc_main163 = defineComponent168({
  __name: "DateRangePickerCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock160(), createBlock155(unref163(_sfc_main162), normalizeProps55(guardReactiveProps52(props2)), {
        default: withCtx156((slotProps) => [
          renderSlot160(_ctx.$slots, "default", normalizeProps55(guardReactiveProps52(slotProps)))
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerClose.js
import { defineComponent as defineComponent169, createBlock as createBlock156, openBlock as openBlock161, unref as unref164, normalizeProps as normalizeProps56, guardReactiveProps as guardReactiveProps53, withCtx as withCtx157, renderSlot as renderSlot161 } from "vue";
var _sfc_main164 = defineComponent169({
  __name: "DateRangePickerClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock161(), createBlock156(unref164(_sfc_main132), normalizeProps56(guardReactiveProps53(props2)), {
        default: withCtx157(() => [
          renderSlot161(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerContent.js
import { defineComponent as defineComponent170, createBlock as createBlock157, openBlock as openBlock162, unref as unref165, withCtx as withCtx158, createVNode as createVNode28, normalizeProps as normalizeProps57, guardReactiveProps as guardReactiveProps54, renderSlot as renderSlot162 } from "vue";
var _sfc_main165 = defineComponent170({
  __name: "DateRangePickerContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    return (_ctx, _cache) => {
      return openBlock162(), createBlock157(unref165(_sfc_main134), null, {
        default: withCtx158(() => [
          createVNode28(unref165(_sfc_main138), normalizeProps57(guardReactiveProps54({ ...unref165(forwarded), ..._ctx.$attrs })), {
            default: withCtx158(() => [
              renderSlot162(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerField.js
import { defineComponent as defineComponent171, createBlock as createBlock158, openBlock as openBlock163, unref as unref166, mergeProps as mergeProps71, withCtx as withCtx159, renderSlot as renderSlot163 } from "vue";
var _sfc_main166 = defineComponent171({
  __name: "DateRangePickerField",
  setup(__props) {
    const rootContext = injectDateRangePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock163(), createBlock158(unref166(_sfc_main153), mergeProps71({
        ref: unref166(rootContext).dateFieldRef,
        "model-value": unref166(rootContext).modelValue.value,
        placeholder: unref166(rootContext).placeholder.value
      }, {
        id: unref166(rootContext).id.value,
        name: unref166(rootContext).name.value,
        disabled: unref166(rootContext).disabled.value,
        minValue: unref166(rootContext).minValue.value,
        maxValue: unref166(rootContext).maxValue.value,
        readonly: unref166(rootContext).readonly.value,
        hourCycle: unref166(rootContext).hourCycle.value,
        granularity: unref166(rootContext).granularity.value,
        hideTimeZone: unref166(rootContext).hideTimeZone.value,
        locale: unref166(rootContext).locale.value,
        isDateUnavailable: unref166(rootContext).isDateUnavailable,
        required: unref166(rootContext).required.value,
        dir: unref166(rootContext).dir.value
      }, {
        "onUpdate:modelValue": _cache[0] || (_cache[0] = (date) => {
          if (date.start && unref166(rootContext).modelValue.value.start && date.end && unref166(rootContext).modelValue.value.end && date.start.compare(unref166(rootContext).modelValue.value.start) === 0 && date.end.compare(unref166(rootContext).modelValue.value.end) === 0) return;
          unref166(rootContext).onDateChange(date);
        }),
        "onUpdate:placeholder": _cache[1] || (_cache[1] = (date) => {
          if (unref166($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date, unref166(rootContext).placeholder.value) && date.compare(unref166(rootContext).placeholder.value) === 0) return;
          unref166(rootContext).onPlaceholderChange(date);
        })
      }), {
        default: withCtx159(({ segments, modelValue }) => [
          renderSlot163(_ctx.$slots, "default", {
            segments,
            modelValue
          })
        ]),
        _: 3
      }, 16, ["model-value", "placeholder"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGrid.js
import { defineComponent as defineComponent173, createBlock as createBlock160, openBlock as openBlock165, unref as unref168, normalizeProps as normalizeProps58, guardReactiveProps as guardReactiveProps55, withCtx as withCtx161, renderSlot as renderSlot165 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarGrid.js
import { defineComponent as defineComponent172, computed as computed55, createBlock as createBlock159, openBlock as openBlock164, unref as unref167, mergeProps as mergeProps72, withCtx as withCtx160, renderSlot as renderSlot164 } from "vue";
var _sfc_main167 = defineComponent172({
  __name: "RangeCalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: { default: "table" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectRangeCalendarRootContext();
    const disabled = computed55(() => rootContext.disabled.value ? true : void 0);
    const readonly3 = computed55(() => rootContext.readonly.value ? true : void 0);
    return (_ctx, _cache) => {
      return openBlock164(), createBlock159(unref167(Primitive), mergeProps72(props2, {
        tabindex: "-1",
        role: "grid",
        "aria-readonly": readonly3.value,
        "aria-disabled": disabled.value,
        "data-readonly": readonly3.value && "",
        "data-disabled": disabled.value && ""
      }), {
        default: withCtx160(() => [
          renderSlot164(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-readonly", "aria-disabled", "data-readonly", "data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGrid.js
var _sfc_main168 = defineComponent173({
  __name: "DateRangePickerGrid",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock165(), createBlock160(unref168(_sfc_main167), normalizeProps58(guardReactiveProps55(props2)), {
        default: withCtx161(() => [
          renderSlot165(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGridBody.js
import { defineComponent as defineComponent175, createBlock as createBlock162, openBlock as openBlock167, unref as unref170, normalizeProps as normalizeProps60, guardReactiveProps as guardReactiveProps57, withCtx as withCtx163, renderSlot as renderSlot167 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarGridBody.js
import { defineComponent as defineComponent174, createBlock as createBlock161, openBlock as openBlock166, unref as unref169, normalizeProps as normalizeProps59, guardReactiveProps as guardReactiveProps56, withCtx as withCtx162, renderSlot as renderSlot166 } from "vue";
var _sfc_main169 = defineComponent174({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: { default: "tbody" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock166(), createBlock161(unref169(Primitive), normalizeProps59(guardReactiveProps56(props2)), {
        default: withCtx162(() => [
          renderSlot166(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGridBody.js
var _sfc_main170 = defineComponent175({
  __name: "DateRangePickerGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock167(), createBlock162(unref170(_sfc_main169), normalizeProps60(guardReactiveProps57(props2)), {
        default: withCtx163(() => [
          renderSlot167(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGridHead.js
import { defineComponent as defineComponent177, createBlock as createBlock164, openBlock as openBlock169, unref as unref172, normalizeProps as normalizeProps61, guardReactiveProps as guardReactiveProps58, withCtx as withCtx165, renderSlot as renderSlot169 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarGridHead.js
import { defineComponent as defineComponent176, createBlock as createBlock163, openBlock as openBlock168, unref as unref171, mergeProps as mergeProps73, withCtx as withCtx164, renderSlot as renderSlot168 } from "vue";
var _sfc_main171 = defineComponent176({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: { default: "thead" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock168(), createBlock163(unref171(Primitive), mergeProps73(props2, { "aria-hidden": "true" }), {
        default: withCtx164(() => [
          renderSlot168(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGridHead.js
var _sfc_main172 = defineComponent177({
  __name: "DateRangePickerGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock169(), createBlock164(unref172(_sfc_main171), normalizeProps61(guardReactiveProps58(props2)), {
        default: withCtx165(() => [
          renderSlot169(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGridRow.js
import { defineComponent as defineComponent179, createBlock as createBlock166, openBlock as openBlock171, unref as unref174, normalizeProps as normalizeProps63, guardReactiveProps as guardReactiveProps60, withCtx as withCtx167, renderSlot as renderSlot171 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarGridRow.js
import { defineComponent as defineComponent178, createBlock as createBlock165, openBlock as openBlock170, unref as unref173, normalizeProps as normalizeProps62, guardReactiveProps as guardReactiveProps59, withCtx as withCtx166, renderSlot as renderSlot170 } from "vue";
var _sfc_main173 = defineComponent178({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: { default: "tr" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock170(), createBlock165(unref173(Primitive), normalizeProps62(guardReactiveProps59(props2)), {
        default: withCtx166(() => [
          renderSlot170(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGridRow.js
var _sfc_main174 = defineComponent179({
  __name: "DateRangePickerGridRow",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock171(), createBlock166(unref174(_sfc_main173), normalizeProps63(guardReactiveProps60(props2)), {
        default: withCtx167(() => [
          renderSlot171(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerHeadCell.js
import { defineComponent as defineComponent181, createBlock as createBlock168, openBlock as openBlock173, unref as unref176, normalizeProps as normalizeProps65, guardReactiveProps as guardReactiveProps62, withCtx as withCtx169, renderSlot as renderSlot173 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarHeadCell.js
import { defineComponent as defineComponent180, createBlock as createBlock167, openBlock as openBlock172, unref as unref175, normalizeProps as normalizeProps64, guardReactiveProps as guardReactiveProps61, withCtx as withCtx168, renderSlot as renderSlot172 } from "vue";
var _sfc_main175 = defineComponent180({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: { default: "th" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock172(), createBlock167(unref175(Primitive), normalizeProps64(guardReactiveProps61(props2)), {
        default: withCtx168(() => [
          renderSlot172(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerHeadCell.js
var _sfc_main176 = defineComponent181({
  __name: "DateRangePickerHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock173(), createBlock168(unref176(_sfc_main175), normalizeProps65(guardReactiveProps62(props2)), {
        default: withCtx169(() => [
          renderSlot173(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerHeader.js
import { defineComponent as defineComponent183, createBlock as createBlock170, openBlock as openBlock175, unref as unref178, normalizeProps as normalizeProps67, guardReactiveProps as guardReactiveProps64, withCtx as withCtx171, renderSlot as renderSlot175 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarHeader.js
import { defineComponent as defineComponent182, createBlock as createBlock169, openBlock as openBlock174, unref as unref177, normalizeProps as normalizeProps66, guardReactiveProps as guardReactiveProps63, withCtx as withCtx170, renderSlot as renderSlot174 } from "vue";
var _sfc_main177 = defineComponent182({
  __name: "RangeCalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock174(), createBlock169(unref177(Primitive), normalizeProps66(guardReactiveProps63(props2)), {
        default: withCtx170(() => [
          renderSlot174(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerHeader.js
var _sfc_main178 = defineComponent183({
  __name: "DateRangePickerHeader",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock175(), createBlock170(unref178(_sfc_main177), normalizeProps67(guardReactiveProps64(props2)), {
        default: withCtx171(() => [
          renderSlot175(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerHeading.js
import { defineComponent as defineComponent185, createBlock as createBlock172, openBlock as openBlock177, unref as unref180, normalizeProps as normalizeProps68, guardReactiveProps as guardReactiveProps65, withCtx as withCtx173, renderSlot as renderSlot177, createTextVNode as createTextVNode11, toDisplayString as toDisplayString9 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarHeading.js
import { defineComponent as defineComponent184, createBlock as createBlock171, openBlock as openBlock176, unref as unref179, mergeProps as mergeProps74, withCtx as withCtx172, renderSlot as renderSlot176, createTextVNode as createTextVNode10, toDisplayString as toDisplayString8 } from "vue";
var _sfc_main179 = defineComponent184({
  __name: "RangeCalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectRangeCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock176(), createBlock171(unref179(Primitive), mergeProps74(props2, {
        "data-disabled": unref179(rootContext).disabled.value ? "" : void 0
      }), {
        default: withCtx172(() => [
          renderSlot176(_ctx.$slots, "default", {
            headingValue: unref179(rootContext).headingValue.value
          }, () => [
            createTextVNode10(toDisplayString8(unref179(rootContext).headingValue.value), 1)
          ])
        ]),
        _: 3
      }, 16, ["data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerHeading.js
var _sfc_main180 = defineComponent185({
  __name: "DateRangePickerHeading",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock177(), createBlock172(unref180(_sfc_main179), normalizeProps68(guardReactiveProps65(props2)), {
        default: withCtx173(({ headingValue }) => [
          renderSlot177(_ctx.$slots, "default", { headingValue }, () => [
            createTextVNode11(toDisplayString9(headingValue), 1)
          ])
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerInput.js
import { defineComponent as defineComponent186, createBlock as createBlock173, openBlock as openBlock178, unref as unref181, normalizeProps as normalizeProps69, guardReactiveProps as guardReactiveProps66, withCtx as withCtx174, renderSlot as renderSlot178 } from "vue";
var _sfc_main181 = defineComponent186({
  __name: "DateRangePickerInput",
  props: {
    part: {},
    type: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock178(), createBlock173(unref181(_sfc_main154), normalizeProps69(guardReactiveProps66(props2)), {
        default: withCtx174(() => [
          renderSlot178(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerNext.js
import { defineComponent as defineComponent188, createBlock as createBlock175, openBlock as openBlock180, unref as unref183, normalizeProps as normalizeProps70, guardReactiveProps as guardReactiveProps67, withCtx as withCtx176, renderSlot as renderSlot180 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarNext.js
import { defineComponent as defineComponent187, computed as computed56, createBlock as createBlock174, openBlock as openBlock179, unref as unref182, mergeProps as mergeProps75, withCtx as withCtx175, renderSlot as renderSlot179, createTextVNode as createTextVNode12 } from "vue";
var _sfc_main182 = defineComponent187({
  __name: "RangeCalendarNext",
  props: {
    nextPage: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const disabled = computed56(() => rootContext.disabled.value || rootContext.isNextButtonDisabled(props2.nextPage));
    const rootContext = injectRangeCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock179(), createBlock174(unref182(Primitive), mergeProps75(props2, {
        "aria-label": "Next page",
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-disabled": disabled.value || void 0,
        "data-disabled": disabled.value || void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => unref182(rootContext).nextPage(props2.nextPage))
      }), {
        default: withCtx175(() => [
          renderSlot179(_ctx.$slots, "default", { disabled: disabled.value }, () => [
            _cache[1] || (_cache[1] = createTextVNode12(" Next page "))
          ])
        ]),
        _: 3
      }, 16, ["type", "aria-disabled", "data-disabled", "disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerNext.js
var _sfc_main183 = defineComponent188({
  __name: "DateRangePickerNext",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock180(), createBlock175(unref183(_sfc_main182), normalizeProps70(guardReactiveProps67(props2)), {
        default: withCtx176((slotProps) => [
          renderSlot180(_ctx.$slots, "default", normalizeProps70(guardReactiveProps67(slotProps)))
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerPrev.js
import { defineComponent as defineComponent190, createBlock as createBlock177, openBlock as openBlock182, unref as unref185, normalizeProps as normalizeProps71, guardReactiveProps as guardReactiveProps68, withCtx as withCtx178, renderSlot as renderSlot182 } from "vue";

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarPrev.js
import { defineComponent as defineComponent189, computed as computed57, createBlock as createBlock176, openBlock as openBlock181, unref as unref184, mergeProps as mergeProps76, withCtx as withCtx177, renderSlot as renderSlot181, createTextVNode as createTextVNode13 } from "vue";
var _sfc_main184 = defineComponent189({
  __name: "RangeCalendarPrev",
  props: {
    prevPage: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const disabled = computed57(() => rootContext.disabled.value || rootContext.isPrevButtonDisabled(props2.prevPage));
    const rootContext = injectRangeCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock181(), createBlock176(unref184(Primitive), mergeProps76(props2, {
        "aria-label": "Previous page",
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-disabled": disabled.value || void 0,
        "data-disabled": disabled.value || void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => unref184(rootContext).prevPage(props2.prevPage))
      }), {
        default: withCtx177(() => [
          renderSlot181(_ctx.$slots, "default", { disabled: disabled.value }, () => [
            _cache[1] || (_cache[1] = createTextVNode13(" Prev page "))
          ])
        ]),
        _: 3
      }, 16, ["type", "aria-disabled", "data-disabled", "disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerPrev.js
var _sfc_main185 = defineComponent190({
  __name: "DateRangePickerPrev",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock182(), createBlock177(unref185(_sfc_main184), normalizeProps71(guardReactiveProps68(props2)), {
        default: withCtx178((slotProps) => [
          renderSlot182(_ctx.$slots, "default", normalizeProps71(guardReactiveProps68(slotProps)))
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerTrigger.js
import { defineComponent as defineComponent191, createBlock as createBlock178, openBlock as openBlock183, unref as unref186, mergeProps as mergeProps77, withCtx as withCtx179, renderSlot as renderSlot183 } from "vue";
var _sfc_main186 = defineComponent191({
  __name: "DateRangePickerTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDateRangePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock183(), createBlock178(unref186(_sfc_main151), mergeProps77({ "data-reka-date-field-segment": "trigger" }, props2, {
        disabled: unref186(rootContext).disabled.value,
        onFocusin: _cache[0] || (_cache[0] = (e) => {
          unref186(rootContext).dateFieldRef.value?.setFocusedElement(e.target);
        })
      }), {
        default: withCtx179(() => [
          renderSlot183(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Dialog/DialogPortal.js
import { defineComponent as defineComponent192, createBlock as createBlock179, openBlock as openBlock184, unref as unref187, normalizeProps as normalizeProps72, guardReactiveProps as guardReactiveProps69, withCtx as withCtx180, renderSlot as renderSlot184 } from "vue";
var _sfc_main187 = defineComponent192({
  __name: "DialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock184(), createBlock179(unref187(_sfc_main27), normalizeProps72(guardReactiveProps69(props2)), {
        default: withCtx180(() => [
          renderSlot184(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuArrow.js
import { defineComponent as defineComponent193, createBlock as createBlock180, openBlock as openBlock185, unref as unref188, normalizeProps as normalizeProps73, guardReactiveProps as guardReactiveProps70, withCtx as withCtx181, renderSlot as renderSlot185 } from "vue";
var _sfc_main188 = defineComponent193({
  __name: "DropdownMenuArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock185(), createBlock180(unref188(_sfc_main86), normalizeProps73(guardReactiveProps70(props2)), {
        default: withCtx181(() => [
          renderSlot185(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuCheckboxItem.js
import { defineComponent as defineComponent194, createBlock as createBlock181, openBlock as openBlock186, unref as unref189, normalizeProps as normalizeProps74, guardReactiveProps as guardReactiveProps71, withCtx as withCtx182, renderSlot as renderSlot186 } from "vue";
var _sfc_main189 = defineComponent194({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock186(), createBlock181(unref189(_sfc_main93), normalizeProps74(guardReactiveProps71({ ...props2, ...unref189(emitsAsProps) })), {
        default: withCtx182(() => [
          renderSlot186(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuContent.js
import { defineComponent as defineComponent196, ref as ref56, createBlock as createBlock183, openBlock as openBlock188, unref as unref191, mergeProps as mergeProps78, withCtx as withCtx184, renderSlot as renderSlot188 } from "vue";

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuRoot.js
import { defineComponent as defineComponent195, ref as ref55, toRefs as toRefs26, createBlock as createBlock182, openBlock as openBlock187, unref as unref190, isRef as isRef8, withCtx as withCtx183, renderSlot as renderSlot187 } from "vue";
var [injectDropdownMenuRootContext, provideDropdownMenuRootContext] = createContext("DropdownMenuRoot");
var _sfc_main190 = defineComponent195({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 },
    dir: {},
    modal: { type: Boolean, default: true }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    useForwardExpose();
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const triggerElement = ref55();
    const { modal, dir: propDir } = toRefs26(props2);
    const dir = useDirection(propDir);
    provideDropdownMenuRootContext({
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      onOpenToggle: () => {
        open.value = !open.value;
      },
      triggerId: "",
      triggerElement,
      contentId: "",
      modal,
      dir
    });
    return (_ctx, _cache) => {
      return openBlock187(), createBlock182(unref190(_sfc_main88), {
        open: unref190(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef8(open) ? open.value = $event : null),
        dir: unref190(dir),
        modal: unref190(modal)
      }, {
        default: withCtx183(() => [
          renderSlot187(_ctx.$slots, "default", { open: unref190(open) })
        ]),
        _: 3
      }, 8, ["open", "dir", "modal"]);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuContent.js
var _sfc_main191 = defineComponent196({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    const rootContext = injectDropdownMenuRootContext();
    const hasInteractedOutsideRef = ref56(false);
    function handleCloseAutoFocus(event) {
      if (event.defaultPrevented)
        return;
      if (!hasInteractedOutsideRef.value) {
        setTimeout(() => {
          rootContext.triggerElement.value?.focus();
        }, 0);
      }
      hasInteractedOutsideRef.value = false;
      event.preventDefault();
    }
    rootContext.contentId ||= useId2(void 0, "reka-dropdown-menu-content");
    return (_ctx, _cache) => {
      return openBlock188(), createBlock183(unref191(_sfc_main97), mergeProps78(unref191(forwarded), {
        id: unref191(rootContext).contentId,
        "aria-labelledby": unref191(rootContext)?.triggerId,
        style: {
          "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
          "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
          "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onCloseAutoFocus: handleCloseAutoFocus,
        onInteractOutside: _cache[0] || (_cache[0] = (event) => {
          if (event.defaultPrevented) return;
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!unref191(rootContext).modal.value || isRightClick) hasInteractedOutsideRef.value = true;
          if (unref191(rootContext).triggerElement.value?.contains(event.target)) event.preventDefault();
        })
      }), {
        default: withCtx184(() => [
          renderSlot188(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby"]);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuGroup.js
import { defineComponent as defineComponent197, createBlock as createBlock184, openBlock as openBlock189, unref as unref192, normalizeProps as normalizeProps75, guardReactiveProps as guardReactiveProps72, withCtx as withCtx185, renderSlot as renderSlot189 } from "vue";
var _sfc_main192 = defineComponent197({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock189(), createBlock184(unref192(_sfc_main100), normalizeProps75(guardReactiveProps72(props2)), {
        default: withCtx185(() => [
          renderSlot189(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuItem.js
import { defineComponent as defineComponent198, createBlock as createBlock185, openBlock as openBlock190, unref as unref193, normalizeProps as normalizeProps76, guardReactiveProps as guardReactiveProps73, withCtx as withCtx186, renderSlot as renderSlot190 } from "vue";
var _sfc_main193 = defineComponent198({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock190(), createBlock185(unref193(_sfc_main91), normalizeProps76(guardReactiveProps73({ ...props2, ...unref193(emitsAsProps) })), {
        default: withCtx186(() => [
          renderSlot190(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuItemIndicator.js
import { defineComponent as defineComponent199, createBlock as createBlock186, openBlock as openBlock191, unref as unref194, normalizeProps as normalizeProps77, guardReactiveProps as guardReactiveProps74, withCtx as withCtx187, renderSlot as renderSlot191 } from "vue";
var _sfc_main194 = defineComponent199({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock191(), createBlock186(unref194(_sfc_main92), normalizeProps77(guardReactiveProps74(props2)), {
        default: withCtx187(() => [
          renderSlot191(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuLabel.js
import { defineComponent as defineComponent200, createBlock as createBlock187, openBlock as openBlock192, unref as unref195, normalizeProps as normalizeProps78, guardReactiveProps as guardReactiveProps75, withCtx as withCtx188, renderSlot as renderSlot192 } from "vue";
var _sfc_main195 = defineComponent200({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock192(), createBlock187(unref195(_sfc_main104), normalizeProps78(guardReactiveProps75(props2)), {
        default: withCtx188(() => [
          renderSlot192(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuPortal.js
import { defineComponent as defineComponent201, createBlock as createBlock188, openBlock as openBlock193, unref as unref196, normalizeProps as normalizeProps79, guardReactiveProps as guardReactiveProps76, withCtx as withCtx189, renderSlot as renderSlot193 } from "vue";
var _sfc_main196 = defineComponent201({
  __name: "DropdownMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock193(), createBlock188(unref196(_sfc_main106), normalizeProps79(guardReactiveProps76(props2)), {
        default: withCtx189(() => [
          renderSlot193(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuRadioGroup.js
import { defineComponent as defineComponent202, createBlock as createBlock189, openBlock as openBlock194, unref as unref197, normalizeProps as normalizeProps80, guardReactiveProps as guardReactiveProps77, withCtx as withCtx190, renderSlot as renderSlot194 } from "vue";
var _sfc_main197 = defineComponent202({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock194(), createBlock189(unref197(_sfc_main108), normalizeProps80(guardReactiveProps77({ ...props2, ...unref197(emitsAsProps) })), {
        default: withCtx190(() => [
          renderSlot194(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuRadioItem.js
import { defineComponent as defineComponent203, createBlock as createBlock190, openBlock as openBlock195, unref as unref198, normalizeProps as normalizeProps81, guardReactiveProps as guardReactiveProps78, withCtx as withCtx191, renderSlot as renderSlot195 } from "vue";
var _sfc_main198 = defineComponent203({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock195(), createBlock190(unref198(_sfc_main110), normalizeProps81(guardReactiveProps78(unref198(forwarded))), {
        default: withCtx191(() => [
          renderSlot195(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuSeparator.js
import { defineComponent as defineComponent204, createBlock as createBlock191, openBlock as openBlock196, unref as unref199, normalizeProps as normalizeProps82, guardReactiveProps as guardReactiveProps79, withCtx as withCtx192, renderSlot as renderSlot196 } from "vue";
var _sfc_main199 = defineComponent204({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock196(), createBlock191(unref199(_sfc_main112), normalizeProps82(guardReactiveProps79(props2)), {
        default: withCtx192(() => [
          renderSlot196(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuSub.js
import { defineComponent as defineComponent205, createBlock as createBlock192, openBlock as openBlock197, unref as unref200, isRef as isRef9, withCtx as withCtx193, renderSlot as renderSlot197 } from "vue";
var _sfc_main200 = defineComponent205({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const open = useVModel(props2, "open", emit, {
      passive: props2.open === void 0,
      defaultValue: props2.defaultOpen ?? false
    });
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock197(), createBlock192(unref200(_sfc_main114), {
        open: unref200(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef9(open) ? open.value = $event : null)
      }, {
        default: withCtx193(() => [
          renderSlot197(_ctx.$slots, "default", { open: unref200(open) })
        ]),
        _: 3
      }, 8, ["open"]);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuSubContent.js
import { defineComponent as defineComponent206, createBlock as createBlock193, openBlock as openBlock198, unref as unref201, mergeProps as mergeProps79, withCtx as withCtx194, renderSlot as renderSlot198 } from "vue";
var _sfc_main201 = defineComponent206({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock198(), createBlock193(unref201(_sfc_main116), mergeProps79(unref201(forwarded), { style: {
        "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: withCtx194(() => [
          renderSlot198(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuSubTrigger.js
import { defineComponent as defineComponent207, createBlock as createBlock194, openBlock as openBlock199, unref as unref202, normalizeProps as normalizeProps83, guardReactiveProps as guardReactiveProps80, withCtx as withCtx195, renderSlot as renderSlot199 } from "vue";
var _sfc_main202 = defineComponent207({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock199(), createBlock194(unref202(_sfc_main119), normalizeProps83(guardReactiveProps80(props2)), {
        default: withCtx195(() => [
          renderSlot199(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuTrigger.js
import { defineComponent as defineComponent208, onMounted as onMounted25, createBlock as createBlock195, openBlock as openBlock200, unref as unref203, withCtx as withCtx196, createVNode as createVNode29, withKeys as withKeys11, nextTick as nextTick22, renderSlot as renderSlot200 } from "vue";
var _sfc_main203 = defineComponent208({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDropdownMenuRootContext();
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    onMounted25(() => {
      rootContext.triggerElement = triggerElement;
    });
    rootContext.triggerId ||= useId2(void 0, "reka-dropdown-menu-trigger");
    return (_ctx, _cache) => {
      return openBlock200(), createBlock195(unref203(_sfc_main118), { "as-child": "" }, {
        default: withCtx196(() => [
          createVNode29(unref203(Primitive), {
            id: unref203(rootContext).triggerId,
            ref: unref203(forwardRef),
            type: _ctx.as === "button" ? "button" : void 0,
            "as-child": props2.asChild,
            as: _ctx.as,
            "aria-haspopup": "menu",
            "aria-expanded": unref203(rootContext).open.value,
            "aria-controls": unref203(rootContext).open.value ? unref203(rootContext).contentId : void 0,
            "data-disabled": _ctx.disabled ? "" : void 0,
            disabled: _ctx.disabled,
            "data-state": unref203(rootContext).open.value ? "open" : "closed",
            onClick: _cache[0] || (_cache[0] = async (event) => {
              if (!_ctx.disabled && event.button === 0 && event.ctrlKey === false) {
                unref203(rootContext)?.onOpenToggle();
                await nextTick22();
                if (unref203(rootContext).open.value) event.preventDefault();
              }
            }),
            onKeydown: _cache[1] || (_cache[1] = withKeys11(
              (event) => {
                if (_ctx.disabled) return;
                if (["Enter", " "].includes(event.key)) unref203(rootContext).onOpenToggle();
                if (event.key === "ArrowDown") unref203(rootContext).onOpenChange(true);
                if (["Enter", " ", "ArrowDown"].includes(event.key))
                  event.preventDefault();
              },
              ["enter", "space", "arrow-down"]
            ))
          }, {
            default: withCtx196(() => [
              renderSlot200(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "type", "as-child", "as", "aria-expanded", "aria-controls", "data-disabled", "disabled", "data-state"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Editable/EditableArea.js
import { defineComponent as defineComponent210, createBlock as createBlock197, openBlock as openBlock202, unref as unref205, mergeProps as mergeProps81, withCtx as withCtx198, renderSlot as renderSlot202 } from "vue";

// node_modules/reka-ui/dist/Editable/EditableRoot.js
import { defineComponent as defineComponent209, toRefs as toRefs27, ref as ref57, computed as computed58, watch as watch26, createBlock as createBlock196, openBlock as openBlock201, unref as unref204, mergeProps as mergeProps80, withCtx as withCtx197, renderSlot as renderSlot201, createCommentVNode as createCommentVNode12 } from "vue";
var [injectEditableRootContext, provideEditableRootContext] = createContext("EditableRoot");
var _sfc_main204 = defineComponent209({
  ...{
    inheritAttrs: false
  },
  __name: "EditableRoot",
  props: {
    defaultValue: {},
    modelValue: {},
    placeholder: { default: "Enter text..." },
    dir: {},
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean },
    activationMode: { default: "focus" },
    selectOnFocus: { type: Boolean, default: false },
    submitMode: { default: "blur" },
    startWithEditMode: { type: Boolean },
    maxLength: {},
    autoResize: { type: Boolean, default: false },
    id: {},
    asChild: { type: Boolean },
    as: { default: "div" },
    name: {},
    required: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "submit", "update:state"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const {
      id,
      name,
      defaultValue,
      startWithEditMode,
      placeholder: propPlaceholder,
      maxLength,
      disabled,
      dir: propDir,
      submitMode,
      activationMode,
      selectOnFocus,
      readonly: readonly3,
      autoResize,
      required
    } = toRefs27(props2);
    const inputRef = ref57();
    const dir = useDirection(propDir);
    const isEditing = ref57(startWithEditMode.value ?? false);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: defaultValue.value ?? "",
      passive: props2.modelValue === void 0
    });
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const isFormControl = useFormControl(currentElement);
    const placeholder = computed58(() => {
      return typeof propPlaceholder.value === "string" ? { edit: propPlaceholder.value, preview: propPlaceholder.value } : propPlaceholder.value;
    });
    const inputValue = ref57(modelValue.value);
    watch26(() => modelValue.value, () => {
      inputValue.value = modelValue.value;
    }, { immediate: true, deep: true });
    function cancel() {
      isEditing.value = false;
      emits("update:state", "cancel");
    }
    function edit() {
      isEditing.value = true;
      inputValue.value = modelValue.value;
      emits("update:state", "edit");
    }
    function submit() {
      modelValue.value = inputValue.value;
      isEditing.value = false;
      emits("update:state", "submit");
      emits("submit", modelValue.value);
    }
    function handleDismiss() {
      if (isEditing.value) {
        if (submitMode.value === "blur" || submitMode.value === "both")
          submit();
        else
          cancel();
      }
    }
    const pointerDownOutside = usePointerDownOutside(() => handleDismiss(), currentElement);
    const focusOutside = useFocusOutside(() => handleDismiss(), currentElement);
    const isEmpty = computed58(() => modelValue.value === "");
    __expose({
      /** Function to submit the value of the editable */
      submit,
      /** Function to cancel the value of the editable */
      cancel,
      /** Function to set the editable in edit mode */
      edit
    });
    provideEditableRootContext({
      id,
      name,
      disabled,
      isEditing,
      maxLength,
      modelValue,
      inputValue,
      placeholder,
      edit,
      cancel,
      submit,
      activationMode,
      submitMode,
      selectOnFocus,
      inputRef,
      startWithEditMode,
      isEmpty,
      readonly: readonly3,
      autoResize
    });
    return (_ctx, _cache) => {
      return openBlock201(), createBlock196(unref204(Primitive), mergeProps80(_ctx.$attrs, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        dir: unref204(dir),
        "data-dismissable-layer": "",
        onFocusCapture: unref204(focusOutside).onFocusCapture,
        onBlurCapture: unref204(focusOutside).onBlurCapture,
        onPointerdownCapture: unref204(pointerDownOutside).onPointerDownCapture
      }), {
        default: withCtx197(() => [
          renderSlot201(_ctx.$slots, "default", {
            modelValue: unref204(modelValue),
            isEditing: isEditing.value,
            isEmpty: isEmpty.value,
            submit,
            cancel,
            edit
          }),
          unref204(isFormControl) && unref204(name) ? (openBlock201(), createBlock196(unref204(_sfc_main52), {
            key: 0,
            type: "text",
            value: unref204(modelValue),
            name: unref204(name),
            disabled: unref204(disabled),
            required: unref204(required)
          }, null, 8, ["value", "name", "disabled", "required"])) : createCommentVNode12("", true)
        ]),
        _: 3
      }, 16, ["as", "as-child", "dir", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]);
    };
  }
});

// node_modules/reka-ui/dist/Editable/EditableArea.js
var _sfc_main205 = defineComponent210({
  __name: "EditableArea",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectEditableRootContext();
    return (_ctx, _cache) => {
      return openBlock202(), createBlock197(unref205(Primitive), mergeProps81(props2, {
        "data-placeholder-shown": unref205(context2).isEditing.value ? void 0 : "",
        "data-focus": unref205(context2).isEditing.value ? "" : void 0,
        "data-focused": unref205(context2).isEditing.value ? "" : void 0,
        "data-empty": unref205(context2).isEmpty.value ? "" : void 0,
        "data-readonly": unref205(context2).readonly.value ? "" : void 0,
        "data-disabled": unref205(context2).disabled.value ? "" : void 0,
        style: unref205(context2).autoResize.value ? { display: "inline-grid" } : void 0
      }), {
        default: withCtx198(() => [
          renderSlot202(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["data-placeholder-shown", "data-focus", "data-focused", "data-empty", "data-readonly", "data-disabled", "style"]);
    };
  }
});

// node_modules/reka-ui/dist/Editable/EditableCancelTrigger.js
import { defineComponent as defineComponent211, createBlock as createBlock198, openBlock as openBlock203, unref as unref206, mergeProps as mergeProps82, withCtx as withCtx199, renderSlot as renderSlot203, createTextVNode as createTextVNode14 } from "vue";
var _sfc_main206 = defineComponent211({
  __name: "EditableCancelTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectEditableRootContext();
    return (_ctx, _cache) => {
      return openBlock203(), createBlock198(unref206(Primitive), mergeProps82(props2, {
        "aria-label": "cancel",
        "aria-disabled": unref206(context2).disabled.value ? "" : void 0,
        "data-disabled": unref206(context2).disabled.value ? "" : void 0,
        disabled: unref206(context2).disabled.value,
        type: _ctx.as === "button" ? "button" : void 0,
        hidden: unref206(context2).isEditing.value ? void 0 : "",
        onClick: unref206(context2).cancel
      }), {
        default: withCtx199(() => [
          renderSlot203(_ctx.$slots, "default", {}, () => [
            _cache[0] || (_cache[0] = createTextVNode14("Cancel"))
          ])
        ]),
        _: 3
      }, 16, ["aria-disabled", "data-disabled", "disabled", "type", "hidden", "onClick"]);
    };
  }
});

// node_modules/reka-ui/dist/Editable/EditableEditTrigger.js
import { defineComponent as defineComponent212, createBlock as createBlock199, openBlock as openBlock204, unref as unref207, mergeProps as mergeProps83, withCtx as withCtx200, renderSlot as renderSlot204, createTextVNode as createTextVNode15 } from "vue";
var _sfc_main207 = defineComponent212({
  __name: "EditableEditTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectEditableRootContext();
    return (_ctx, _cache) => {
      return openBlock204(), createBlock199(unref207(Primitive), mergeProps83(props2, {
        "aria-label": "edit",
        "aria-disabled": unref207(context2).disabled.value ? "" : void 0,
        "data-disabled": unref207(context2).disabled.value ? "" : void 0,
        disabled: unref207(context2).disabled.value,
        type: _ctx.as === "button" ? "button" : void 0,
        hidden: unref207(context2).isEditing.value ? "" : void 0,
        onClick: unref207(context2).edit
      }), {
        default: withCtx200(() => [
          renderSlot204(_ctx.$slots, "default", {}, () => [
            _cache[0] || (_cache[0] = createTextVNode15("Edit"))
          ])
        ]),
        _: 3
      }, 16, ["aria-disabled", "data-disabled", "disabled", "type", "hidden", "onClick"]);
    };
  }
});

// node_modules/reka-ui/dist/Editable/EditableInput.js
import { defineComponent as defineComponent213, computed as computed59, onMounted as onMounted26, watch as watch27, nextTick as nextTick23, createBlock as createBlock200, openBlock as openBlock205, unref as unref208, mergeProps as mergeProps84, withKeys as withKeys12, withCtx as withCtx201, renderSlot as renderSlot205 } from "vue";
var _sfc_main208 = defineComponent213({
  __name: "EditableInput",
  props: {
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(__props) {
    const props2 = __props;
    const kbd = useKbd();
    const context2 = injectEditableRootContext();
    const disabled = computed59(() => context2.disabled.value);
    const placeholder = computed59(() => context2.placeholder.value?.edit);
    const { primitiveElement, currentElement: inputRef } = usePrimitiveElement();
    onMounted26(() => {
      context2.inputRef.value = inputRef.value;
      if (context2.startWithEditMode.value) {
        context2.inputRef.value?.focus({ preventScroll: true });
        if (context2.selectOnFocus.value)
          context2.inputRef.value?.select();
      }
    });
    watch27(context2.isEditing, (value) => {
      if (value) {
        nextTick23(() => {
          context2.inputRef.value?.focus({ preventScroll: true });
          if (context2.selectOnFocus.value)
            context2.inputRef.value?.select();
        });
      }
    });
    function handleSubmitKeyDown(event) {
      if ((context2.submitMode.value === "enter" || context2.submitMode.value === "both") && event.key === kbd.ENTER && !event.shiftKey && !event.metaKey)
        context2.submit();
    }
    return (_ctx, _cache) => {
      return openBlock205(), createBlock200(unref208(Primitive), mergeProps84({
        ref_key: "primitiveElement",
        ref: primitiveElement
      }, props2, {
        value: unref208(context2).inputValue.value,
        placeholder: placeholder.value,
        disabled: disabled.value,
        maxlength: unref208(context2).maxLength.value,
        "data-disabled": disabled.value ? "" : void 0,
        "data-readonly": unref208(context2).readonly.value ? "" : void 0,
        readonly: unref208(context2).readonly.value,
        "aria-label": "editable input",
        hidden: unref208(context2).autoResize.value ? void 0 : !unref208(context2).isEditing.value,
        style: unref208(context2).autoResize.value ? { all: "unset", gridArea: "1 / 1 / auto / auto", visibility: !unref208(context2).isEditing.value ? "hidden" : void 0 } : void 0,
        onInput: _cache[0] || (_cache[0] = ($event) => unref208(context2).inputValue.value = $event.target.value),
        onKeydown: [
          withKeys12(handleSubmitKeyDown, ["enter", "space"]),
          withKeys12(unref208(context2).cancel, ["esc"])
        ]
      }), {
        default: withCtx201(() => [
          renderSlot205(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["value", "placeholder", "disabled", "maxlength", "data-disabled", "data-readonly", "readonly", "hidden", "style", "onKeydown"]);
    };
  }
});

// node_modules/reka-ui/dist/Editable/EditablePreview.js
import { defineComponent as defineComponent214, computed as computed60, createBlock as createBlock201, openBlock as openBlock206, unref as unref209, mergeProps as mergeProps85, withCtx as withCtx202, renderSlot as renderSlot206, createTextVNode as createTextVNode16, toDisplayString as toDisplayString10 } from "vue";
var _sfc_main209 = defineComponent214({
  __name: "EditablePreview",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectEditableRootContext();
    const placeholder = computed60(() => context2.placeholder.value?.preview);
    function handleFocus() {
      if (context2.activationMode.value === "focus")
        context2.edit();
    }
    function handleDoubleClick() {
      if (context2.activationMode.value === "dblclick")
        context2.edit();
    }
    return (_ctx, _cache) => {
      return openBlock206(), createBlock201(unref209(Primitive), mergeProps85(props2, {
        tabindex: "0",
        "data-placeholder-shown": unref209(context2).isEditing.value ? void 0 : "",
        hidden: unref209(context2).autoResize.value ? void 0 : unref209(context2).isEditing.value,
        style: unref209(context2).autoResize.value ? {
          whiteSpace: "pre",
          userSelect: "none",
          gridArea: "1 / 1 / auto / auto",
          visibility: unref209(context2).isEditing.value ? "hidden" : void 0,
          overflow: "hidden",
          textOverflow: "ellipsis"
        } : void 0,
        onFocusin: handleFocus,
        onDblclick: handleDoubleClick
      }), {
        default: withCtx202(() => [
          renderSlot206(_ctx.$slots, "default", {}, () => [
            createTextVNode16(toDisplayString10(unref209(context2).modelValue.value || placeholder.value), 1)
          ])
        ]),
        _: 3
      }, 16, ["data-placeholder-shown", "hidden", "style"]);
    };
  }
});

// node_modules/reka-ui/dist/Editable/EditableSubmitTrigger.js
import { defineComponent as defineComponent215, createBlock as createBlock202, openBlock as openBlock207, unref as unref210, mergeProps as mergeProps86, withCtx as withCtx203, renderSlot as renderSlot207, createTextVNode as createTextVNode17 } from "vue";
var _sfc_main210 = defineComponent215({
  __name: "EditableSubmitTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectEditableRootContext();
    return (_ctx, _cache) => {
      return openBlock207(), createBlock202(unref210(Primitive), mergeProps86(props2, {
        "aria-label": "submit",
        "aria-disabled": unref210(context2).disabled.value ? "" : void 0,
        "data-disabled": unref210(context2).disabled.value ? "" : void 0,
        disabled: unref210(context2).disabled.value,
        type: _ctx.as === "button" ? "button" : void 0,
        hidden: unref210(context2).isEditing.value ? void 0 : "",
        onClick: unref210(context2).submit
      }), {
        default: withCtx203(() => [
          renderSlot207(_ctx.$slots, "default", {}, () => [
            _cache[0] || (_cache[0] = createTextVNode17("Submit"))
          ])
        ]),
        _: 3
      }, 16, ["aria-disabled", "data-disabled", "disabled", "type", "hidden", "onClick"]);
    };
  }
});

// node_modules/reka-ui/dist/HoverCard/HoverCardArrow.js
import { defineComponent as defineComponent216, createBlock as createBlock203, openBlock as openBlock208, unref as unref211, normalizeProps as normalizeProps84, guardReactiveProps as guardReactiveProps81, withCtx as withCtx204, renderSlot as renderSlot208 } from "vue";
var _sfc_main211 = defineComponent216({
  __name: "HoverCardArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock208(), createBlock203(unref211(_sfc_main62), normalizeProps84(guardReactiveProps81(props2)), {
        default: withCtx204(() => [
          renderSlot208(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/HoverCard/HoverCardContent.js
import { defineComponent as defineComponent219, createBlock as createBlock206, openBlock as openBlock211, unref as unref214, withCtx as withCtx207, createVNode as createVNode31, mergeProps as mergeProps88, renderSlot as renderSlot211 } from "vue";

// node_modules/reka-ui/dist/HoverCard/HoverCardContentImpl.js
import { defineComponent as defineComponent218, ref as ref60, watchEffect as watchEffect11, onMounted as onMounted27, onUnmounted as onUnmounted13, createBlock as createBlock205, openBlock as openBlock210, unref as unref213, withModifiers as withModifiers11, withCtx as withCtx206, createVNode as createVNode30, mergeProps as mergeProps87, renderSlot as renderSlot210, nextTick as nextTick24 } from "vue";

// node_modules/reka-ui/dist/HoverCard/utils.js
function excludeTouch(eventHandler) {
  return (event) => event.pointerType === "touch" ? void 0 : eventHandler();
}
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}

// node_modules/reka-ui/dist/HoverCard/HoverCardRoot.js
import { defineComponent as defineComponent217, toRefs as toRefs28, ref as ref58, createBlock as createBlock204, openBlock as openBlock209, unref as unref212, withCtx as withCtx205, renderSlot as renderSlot209 } from "vue";
var [injectHoverCardRootContext, provideHoverCardRootContext] = createContext("HoverCardRoot");
var _sfc_main212 = defineComponent217({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    openDelay: { default: 700 },
    closeDelay: { default: 300 }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const { openDelay, closeDelay } = toRefs28(props2);
    useForwardExpose();
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const openTimerRef = ref58(0);
    const closeTimerRef = ref58(0);
    const hasSelectionRef = ref58(false);
    const isPointerDownOnContentRef = ref58(false);
    const isPointerInTransitRef = ref58(false);
    const triggerElement = ref58();
    function handleOpen() {
      clearTimeout(closeTimerRef.value);
      openTimerRef.value = window.setTimeout(() => open.value = true, openDelay.value);
    }
    function handleClose() {
      clearTimeout(openTimerRef.value);
      if (!hasSelectionRef.value && !isPointerDownOnContentRef.value)
        closeTimerRef.value = window.setTimeout(() => open.value = false, closeDelay.value);
    }
    function handleDismiss() {
      open.value = false;
    }
    provideHoverCardRootContext({
      open,
      onOpenChange(value) {
        open.value = value;
      },
      onOpen: handleOpen,
      onClose: handleClose,
      onDismiss: handleDismiss,
      hasSelectionRef,
      isPointerDownOnContentRef,
      isPointerInTransitRef,
      triggerElement
    });
    return (_ctx, _cache) => {
      return openBlock209(), createBlock204(unref212(_sfc_main57), null, {
        default: withCtx205(() => [
          renderSlot209(_ctx.$slots, "default", { open: unref212(open) })
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/shared/useGraceArea.js
import { ref as ref59, watchEffect as watchEffect10 } from "vue";
function useGraceArea(triggerElement, containerElement) {
  const isPointerInTransit = refAutoReset(false, 300);
  const pointerGraceArea = ref59(null);
  const pointerExit = createEventHook();
  function handleRemoveGraceArea() {
    pointerGraceArea.value = null;
    isPointerInTransit.value = false;
  }
  function handleCreateGraceArea(event, hoverTarget) {
    const currentTarget = event.currentTarget;
    const exitPoint = { x: event.clientX, y: event.clientY };
    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
    pointerGraceArea.value = graceArea;
    isPointerInTransit.value = true;
  }
  watchEffect10((cleanupFn) => {
    if (triggerElement.value && containerElement.value) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, containerElement.value);
      const handleContentLeave = (event) => handleCreateGraceArea(event, triggerElement.value);
      triggerElement.value.addEventListener("pointerleave", handleTriggerLeave);
      containerElement.value.addEventListener("pointerleave", handleContentLeave);
      cleanupFn(() => {
        triggerElement.value?.removeEventListener("pointerleave", handleTriggerLeave);
        containerElement.value?.removeEventListener("pointerleave", handleContentLeave);
      });
    }
  });
  watchEffect10((cleanupFn) => {
    if (pointerGraceArea.value) {
      const handleTrackPointerGrace = (event) => {
        if (!pointerGraceArea.value || !(event.target instanceof HTMLElement))
          return;
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = triggerElement.value?.contains(target) || containerElement.value?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon2(pointerPosition, pointerGraceArea.value);
        const isAnotherGraceAreaTrigger = !!target.closest("[data-grace-area-trigger]");
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea || isAnotherGraceAreaTrigger) {
          handleRemoveGraceArea();
          pointerExit.trigger();
        }
      };
      triggerElement.value?.ownerDocument.addEventListener("pointermove", handleTrackPointerGrace);
      cleanupFn(() => triggerElement.value?.ownerDocument.removeEventListener("pointermove", handleTrackPointerGrace));
    }
  });
  return {
    isPointerInTransit,
    onPointerExit: pointerExit.on
  };
}
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon2(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x)
      return -1;
    else if (a.x > b.x)
      return 1;
    else if (a.y < b.y)
      return -1;
    else if (a.y > b.y)
      return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        upperHull.pop();
      else break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        lowerHull.pop();
      else break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}

// node_modules/reka-ui/dist/HoverCard/HoverCardContentImpl.js
var _sfc_main213 = defineComponent218({
  __name: "HoverCardContentImpl",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardProps(props2);
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    const { isPointerInTransit, onPointerExit } = useGraceArea(rootContext.triggerElement, contentElement);
    syncRef(rootContext.isPointerInTransitRef, isPointerInTransit, { direction: "rtl" });
    onPointerExit(() => {
      rootContext.onClose();
    });
    const containSelection = ref60(false);
    let originalBodyUserSelect;
    watchEffect11((cleanupFn) => {
      if (containSelection.value) {
        const body = document.body;
        originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
        body.style.userSelect = "none";
        body.style.webkitUserSelect = "none";
        cleanupFn(() => {
          body.style.userSelect = originalBodyUserSelect;
          body.style.webkitUserSelect = originalBodyUserSelect;
        });
      }
    });
    function handlePointerUp2() {
      containSelection.value = false;
      rootContext.isPointerDownOnContentRef.value = false;
      nextTick24(() => {
        const hasSelection = document.getSelection()?.toString() !== "";
        if (hasSelection)
          rootContext.hasSelectionRef.value = true;
      });
    }
    onMounted27(() => {
      if (contentElement.value) {
        document.addEventListener("pointerup", handlePointerUp2);
        const tabbables = getTabbableNodes(contentElement.value);
        tabbables.forEach((tabbable) => tabbable.setAttribute("tabindex", "-1"));
      }
    });
    onUnmounted13(() => {
      document.removeEventListener("pointerup", handlePointerUp2);
      rootContext.hasSelectionRef.value = false;
      rootContext.isPointerDownOnContentRef.value = false;
    });
    return (_ctx, _cache) => {
      return openBlock210(), createBlock205(unref213(_sfc_main14), {
        "as-child": "",
        "disable-outside-pointer-events": false,
        onEscapeKeyDown: _cache[1] || (_cache[1] = ($event) => emits("escapeKeyDown", $event)),
        onPointerDownOutside: _cache[2] || (_cache[2] = ($event) => emits("pointerDownOutside", $event)),
        onFocusOutside: _cache[3] || (_cache[3] = withModifiers11(($event) => emits("focusOutside", $event), ["prevent"])),
        onDismiss: unref213(rootContext).onDismiss
      }, {
        default: withCtx206(() => [
          createVNode30(unref213(_sfc_main61), mergeProps87({ ...unref213(forwarded), ..._ctx.$attrs }, {
            ref: unref213(forwardRef),
            "data-state": unref213(rootContext).open.value ? "open" : "closed",
            style: {
              "userSelect": containSelection.value ? "text" : void 0,
              // Safari requires prefix
              "WebkitUserSelect": containSelection.value ? "text" : void 0,
              // re-namespace exposed content custom properties
              "--reka-hover-card-content-transform-origin": "var(--reka-popper-transform-origin)",
              "--reka-hover-card-content-available-width": "var(--reka-popper-available-width)",
              "--reka-hover-card-content-available-height": "var(--reka-popper-available-height)",
              "--reka-hover-card-trigger-width": "var(--reka-popper-anchor-width)",
              "--reka-hover-card-trigger-height": "var(--reka-popper-anchor-height)"
            },
            onPointerdown: _cache[0] || (_cache[0] = (event) => {
              if (event.currentTarget.contains(event.target)) {
                containSelection.value = true;
              }
              unref213(rootContext).hasSelectionRef.value = false;
              unref213(rootContext).isPointerDownOnContentRef.value = true;
            })
          }), {
            default: withCtx206(() => [
              renderSlot210(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["data-state", "style"])
        ]),
        _: 3
      }, 8, ["onDismiss"]);
    };
  }
});

// node_modules/reka-ui/dist/HoverCard/HoverCardContent.js
var _sfc_main214 = defineComponent219({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const { forwardRef } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    return (_ctx, _cache) => {
      return openBlock211(), createBlock206(unref214(Presence), {
        present: _ctx.forceMount || unref214(rootContext).open.value
      }, {
        default: withCtx207(() => [
          createVNode31(_sfc_main213, mergeProps88(unref214(forwarded), {
            ref: unref214(forwardRef),
            onPointerenter: _cache[0] || (_cache[0] = ($event) => unref214(excludeTouch)(unref214(rootContext).onOpen)($event))
          }), {
            default: withCtx207(() => [
              renderSlot211(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/HoverCard/HoverCardPortal.js
import { defineComponent as defineComponent220, createBlock as createBlock207, openBlock as openBlock212, unref as unref215, normalizeProps as normalizeProps85, guardReactiveProps as guardReactiveProps82, withCtx as withCtx208, renderSlot as renderSlot212 } from "vue";
var _sfc_main215 = defineComponent220({
  __name: "HoverCardPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock212(), createBlock207(unref215(_sfc_main27), normalizeProps85(guardReactiveProps82(props2)), {
        default: withCtx208(() => [
          renderSlot212(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/HoverCard/HoverCardTrigger.js
import { defineComponent as defineComponent221, createBlock as createBlock208, openBlock as openBlock213, unref as unref216, withCtx as withCtx209, createVNode as createVNode32, renderSlot as renderSlot213 } from "vue";
var _sfc_main216 = defineComponent221({
  __name: "HoverCardTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(__props) {
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    rootContext.triggerElement = currentElement;
    function handleLeave() {
      setTimeout(() => {
        if (!rootContext.isPointerInTransitRef.value && !rootContext.open.value) {
          rootContext.onClose();
        }
      }, 0);
    }
    return (_ctx, _cache) => {
      return openBlock213(), createBlock208(unref216(_sfc_main58), {
        "as-child": "",
        reference: _ctx.reference
      }, {
        default: withCtx209(() => [
          createVNode32(unref216(Primitive), {
            ref: unref216(forwardRef),
            "as-child": _ctx.asChild,
            as: _ctx.as,
            "data-state": unref216(rootContext).open.value ? "open" : "closed",
            "data-grace-area-trigger": "",
            onPointerenter: _cache[0] || (_cache[0] = ($event) => unref216(excludeTouch)(unref216(rootContext).onOpen)($event)),
            onPointerleave: _cache[1] || (_cache[1] = ($event) => unref216(excludeTouch)(handleLeave)($event)),
            onFocus: _cache[2] || (_cache[2] = ($event) => unref216(rootContext).onOpen()),
            onBlur: _cache[3] || (_cache[3] = ($event) => unref216(rootContext).onClose())
          }, {
            default: withCtx209(() => [
              renderSlot213(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["as-child", "as", "data-state"])
        ]),
        _: 3
      }, 8, ["reference"]);
    };
  }
});

// node_modules/reka-ui/dist/Label/Label.js
import { defineComponent as defineComponent222, createBlock as createBlock209, openBlock as openBlock214, unref as unref217, mergeProps as mergeProps89, withCtx as withCtx210, renderSlot as renderSlot214 } from "vue";
var _sfc_main217 = defineComponent222({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "label" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock214(), createBlock209(unref217(Primitive), mergeProps89(props2, {
        onMousedown: _cache[0] || (_cache[0] = (event) => {
          if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
        })
      }), {
        default: withCtx210(() => [
          renderSlot214(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Listbox/ListboxGroupLabel.js
import { defineComponent as defineComponent223, createBlock as createBlock210, openBlock as openBlock215, unref as unref218, mergeProps as mergeProps90, withCtx as withCtx211, renderSlot as renderSlot215 } from "vue";
var _sfc_main218 = defineComponent223({
  __name: "ListboxGroupLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    const groupContext = injectListboxGroupContext({ id: "" });
    return (_ctx, _cache) => {
      return openBlock215(), createBlock210(unref218(Primitive), mergeProps90(props2, {
        id: unref218(groupContext).id
      }), {
        default: withCtx211(() => [
          renderSlot215(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarArrow.js
import { defineComponent as defineComponent224, createBlock as createBlock211, openBlock as openBlock216, unref as unref219, normalizeProps as normalizeProps86, guardReactiveProps as guardReactiveProps83, withCtx as withCtx212, renderSlot as renderSlot216 } from "vue";
var _sfc_main219 = defineComponent224({
  __name: "MenubarArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock216(), createBlock211(unref219(_sfc_main86), normalizeProps86(guardReactiveProps83(props2)), {
        default: withCtx212(() => [
          renderSlot216(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarCheckboxItem.js
import { defineComponent as defineComponent225, createBlock as createBlock212, openBlock as openBlock217, unref as unref220, normalizeProps as normalizeProps87, guardReactiveProps as guardReactiveProps84, withCtx as withCtx213, renderSlot as renderSlot217 } from "vue";
var _sfc_main220 = defineComponent225({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock217(), createBlock212(unref220(_sfc_main93), normalizeProps87(guardReactiveProps84({ ...props2, ...unref220(emitsAsProps) })), {
        default: withCtx213(() => [
          renderSlot217(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarContent.js
import { defineComponent as defineComponent228, ref as ref63, createBlock as createBlock215, openBlock as openBlock220, unref as unref223, mergeProps as mergeProps91, withKeys as withKeys13, withCtx as withCtx216, renderSlot as renderSlot220 } from "vue";

// node_modules/reka-ui/dist/Menubar/MenubarMenu.js
import { defineComponent as defineComponent227, ref as ref62, computed as computed61, watch as watch28, createBlock as createBlock214, openBlock as openBlock219, unref as unref222, withCtx as withCtx215, renderSlot as renderSlot219 } from "vue";

// node_modules/reka-ui/dist/Menubar/MenubarRoot.js
import { defineComponent as defineComponent226, ref as ref61, toRefs as toRefs29, createBlock as createBlock213, openBlock as openBlock218, unref as unref221, withCtx as withCtx214, createVNode as createVNode33, renderSlot as renderSlot218 } from "vue";
var [injectMenubarRootContext, provideMenubarRootContext] = createContext("MenubarRoot");
var _sfc_main221 = defineComponent226({
  __name: "MenubarRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const { forwardRef } = useForwardExpose();
    const { CollectionSlot } = useCollection({ key: "Menubar", isProvider: true });
    const modelValue = useVModel(props2, "modelValue", emit, {
      defaultValue: props2.defaultValue ?? "",
      passive: props2.modelValue === void 0
    });
    const currentTabStopId = ref61(null);
    const { dir: propDir, loop } = toRefs29(props2);
    const dir = useDirection(propDir);
    provideMenubarRootContext({
      modelValue,
      dir,
      loop,
      onMenuOpen: (value) => {
        modelValue.value = value;
        currentTabStopId.value = value;
      },
      onMenuClose: () => {
        modelValue.value = "";
      },
      onMenuToggle: (value) => {
        modelValue.value = modelValue.value ? "" : value;
        currentTabStopId.value = value;
      }
    });
    return (_ctx, _cache) => {
      return openBlock218(), createBlock213(unref221(CollectionSlot), null, {
        default: withCtx214(() => [
          createVNode33(unref221(_sfc_main50), {
            "current-tab-stop-id": currentTabStopId.value,
            "onUpdate:currentTabStopId": _cache[0] || (_cache[0] = ($event) => currentTabStopId.value = $event),
            orientation: "horizontal",
            loop: unref221(loop),
            dir: unref221(dir),
            "as-child": ""
          }, {
            default: withCtx214(() => [
              createVNode33(unref221(Primitive), {
                ref: unref221(forwardRef),
                role: "menubar"
              }, {
                default: withCtx214(() => [
                  renderSlot218(_ctx.$slots, "default", { modelValue: unref221(modelValue) })
                ]),
                _: 3
              }, 512)
            ]),
            _: 3
          }, 8, ["current-tab-stop-id", "loop", "dir"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarMenu.js
var [injectMenubarMenuContext, provideMenubarMenuContext] = createContext("MenubarMenu");
var _sfc_main222 = defineComponent227({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(__props) {
    const props2 = __props;
    const value = useId2(props2.value);
    const rootContext = injectMenubarRootContext();
    useForwardExpose();
    const triggerElement = ref62();
    const wasKeyboardTriggerOpenRef = ref62(false);
    const open = computed61(() => rootContext.modelValue.value === value);
    watch28(open, () => {
      if (!open.value)
        wasKeyboardTriggerOpenRef.value = false;
    });
    provideMenubarMenuContext({
      value,
      triggerElement,
      triggerId: value,
      contentId: "",
      wasKeyboardTriggerOpenRef
    });
    return (_ctx, _cache) => {
      return openBlock219(), createBlock214(unref222(_sfc_main88), {
        open: open.value,
        modal: false,
        dir: unref222(rootContext).dir.value,
        "onUpdate:open": _cache[0] || (_cache[0] = (value2) => {
          if (!value2) unref222(rootContext).onMenuClose();
        })
      }, {
        default: withCtx215(() => [
          renderSlot219(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["open", "dir"]);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarContent.js
var _sfc_main223 = defineComponent228({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    const rootContext = injectMenubarRootContext();
    const menuContext = injectMenubarMenuContext();
    menuContext.contentId ||= useId2(void 0, "reka-menubar-content");
    const { getItems } = useCollection({ key: "Menubar" });
    const hasInteractedOutsideRef = ref63(false);
    function handleArrowNavigation(event) {
      const target = event.target;
      const targetIsSubTrigger = target.hasAttribute(
        "data-reka-menubar-subtrigger"
      );
      const prevMenuKey = rootContext.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft";
      const isPrevKey = prevMenuKey === event.key;
      const isNextKey = !isPrevKey;
      if (isNextKey && targetIsSubTrigger)
        return;
      let candidateValues = getItems().filter((i) => i.ref.dataset.disabled !== "").map((i) => i.ref.dataset.value);
      if (isPrevKey)
        candidateValues.reverse();
      const currentIndex = candidateValues.indexOf(menuContext.value);
      candidateValues = rootContext.loop.value ? wrapArray2(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
      const [nextValue] = candidateValues;
      if (nextValue)
        rootContext.onMenuOpen(nextValue);
    }
    return (_ctx, _cache) => {
      return openBlock220(), createBlock215(unref223(_sfc_main97), mergeProps91(unref223(forwarded), {
        id: unref223(menuContext).contentId,
        "data-reka-menubar-content": "",
        "aria-labelledby": unref223(menuContext).triggerId,
        style: {
          "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
          "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
          "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          const menubarOpen = Boolean(unref223(rootContext).modelValue.value);
          if (!menubarOpen && !hasInteractedOutsideRef.value) {
            unref223(menuContext).triggerElement.value?.focus();
          }
          hasInteractedOutsideRef.value = false;
          event.preventDefault();
        }),
        onFocusOutside: _cache[1] || (_cache[1] = (event) => {
          const target = event.target;
          const isMenubarTrigger = unref223(getItems)().filter((i) => i.ref.dataset.disabled !== "").some((i) => i.ref.contains(target));
          if (isMenubarTrigger) event.preventDefault();
        }),
        onInteractOutside: _cache[2] || (_cache[2] = (event) => {
          hasInteractedOutsideRef.value = true;
        }),
        onEntryFocus: _cache[3] || (_cache[3] = (event) => {
          if (!unref223(menuContext).wasKeyboardTriggerOpenRef.value) event.preventDefault();
        }),
        onKeydown: withKeys13(handleArrowNavigation, ["arrow-right", "arrow-left"])
      }), {
        default: withCtx216(() => [
          renderSlot220(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby"]);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarGroup.js
import { defineComponent as defineComponent229, createBlock as createBlock216, openBlock as openBlock221, unref as unref224, normalizeProps as normalizeProps88, guardReactiveProps as guardReactiveProps85, withCtx as withCtx217, renderSlot as renderSlot221 } from "vue";
var _sfc_main224 = defineComponent229({
  __name: "MenubarGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock221(), createBlock216(unref224(_sfc_main100), normalizeProps88(guardReactiveProps85(props2)), {
        default: withCtx217(() => [
          renderSlot221(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarItem.js
import { defineComponent as defineComponent230, createBlock as createBlock217, openBlock as openBlock222, unref as unref225, normalizeProps as normalizeProps89, guardReactiveProps as guardReactiveProps86, withCtx as withCtx218, renderSlot as renderSlot222 } from "vue";
var _sfc_main225 = defineComponent230({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock222(), createBlock217(unref225(_sfc_main91), normalizeProps89(guardReactiveProps86({ ...props2, ...unref225(emitsAsProps) })), {
        default: withCtx218(() => [
          renderSlot222(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarItemIndicator.js
import { defineComponent as defineComponent231, createBlock as createBlock218, openBlock as openBlock223, unref as unref226, normalizeProps as normalizeProps90, guardReactiveProps as guardReactiveProps87, withCtx as withCtx219, renderSlot as renderSlot223 } from "vue";
var _sfc_main226 = defineComponent231({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock223(), createBlock218(unref226(_sfc_main92), normalizeProps90(guardReactiveProps87(props2)), {
        default: withCtx219(() => [
          renderSlot223(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarLabel.js
import { defineComponent as defineComponent232, createBlock as createBlock219, openBlock as openBlock224, unref as unref227, normalizeProps as normalizeProps91, guardReactiveProps as guardReactiveProps88, withCtx as withCtx220, renderSlot as renderSlot224 } from "vue";
var _sfc_main227 = defineComponent232({
  __name: "MenubarLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock224(), createBlock219(unref227(_sfc_main104), normalizeProps91(guardReactiveProps88(props2)), {
        default: withCtx220(() => [
          renderSlot224(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarPortal.js
import { defineComponent as defineComponent233, createBlock as createBlock220, openBlock as openBlock225, unref as unref228, normalizeProps as normalizeProps92, guardReactiveProps as guardReactiveProps89, withCtx as withCtx221, renderSlot as renderSlot225 } from "vue";
var _sfc_main228 = defineComponent233({
  __name: "MenubarPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock225(), createBlock220(unref228(_sfc_main106), normalizeProps92(guardReactiveProps89(props2)), {
        default: withCtx221(() => [
          renderSlot225(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarRadioGroup.js
import { defineComponent as defineComponent234, createBlock as createBlock221, openBlock as openBlock226, unref as unref229, normalizeProps as normalizeProps93, guardReactiveProps as guardReactiveProps90, withCtx as withCtx222, renderSlot as renderSlot226 } from "vue";
var _sfc_main229 = defineComponent234({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock226(), createBlock221(unref229(_sfc_main108), normalizeProps93(guardReactiveProps90({ ...props2, ...unref229(emitsAsProps) })), {
        default: withCtx222(() => [
          renderSlot226(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarRadioItem.js
import { defineComponent as defineComponent235, createBlock as createBlock222, openBlock as openBlock227, unref as unref230, normalizeProps as normalizeProps94, guardReactiveProps as guardReactiveProps91, withCtx as withCtx223, renderSlot as renderSlot227 } from "vue";
var _sfc_main230 = defineComponent235({
  __name: "MenubarRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock227(), createBlock222(unref230(_sfc_main110), normalizeProps94(guardReactiveProps91(unref230(forwarded))), {
        default: withCtx223(() => [
          renderSlot227(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarSeparator.js
import { defineComponent as defineComponent236, createBlock as createBlock223, openBlock as openBlock228, unref as unref231, normalizeProps as normalizeProps95, guardReactiveProps as guardReactiveProps92, withCtx as withCtx224, renderSlot as renderSlot228 } from "vue";
var _sfc_main231 = defineComponent236({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock228(), createBlock223(unref231(_sfc_main112), normalizeProps95(guardReactiveProps92(props2)), {
        default: withCtx224(() => [
          renderSlot228(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarSub.js
import { defineComponent as defineComponent237, createBlock as createBlock224, openBlock as openBlock229, unref as unref232, isRef as isRef10, withCtx as withCtx225, renderSlot as renderSlot229 } from "vue";
var _sfc_main232 = defineComponent237({
  __name: "MenubarSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    useForwardExpose();
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen ?? false,
      passive: props2.open === void 0
    });
    return (_ctx, _cache) => {
      return openBlock229(), createBlock224(unref232(_sfc_main114), {
        open: unref232(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef10(open) ? open.value = $event : null)
      }, {
        default: withCtx225(() => [
          renderSlot229(_ctx.$slots, "default", { open: unref232(open) })
        ]),
        _: 3
      }, 8, ["open"]);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarSubContent.js
import { defineComponent as defineComponent238, createBlock as createBlock225, openBlock as openBlock230, unref as unref233, mergeProps as mergeProps92, withKeys as withKeys14, withCtx as withCtx226, renderSlot as renderSlot230 } from "vue";
var _sfc_main233 = defineComponent238({
  __name: "MenubarSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    const { getItems } = useCollection({ key: "Menubar" });
    const rootContext = injectMenubarRootContext();
    const menuContext = injectMenubarMenuContext();
    function handleArrowNavigation(event) {
      const target = event.target;
      const targetIsSubTrigger = target.hasAttribute(
        "data-reka-menubar-subtrigger"
      );
      if (targetIsSubTrigger)
        return;
      let candidateValues = getItems().filter((i) => i.ref.dataset.disabled !== "").map((i) => i.ref.dataset.value);
      const currentIndex = candidateValues.indexOf(menuContext.value);
      candidateValues = rootContext.loop.value ? wrapArray2(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
      const [nextValue] = candidateValues;
      if (nextValue)
        rootContext.onMenuOpen(nextValue);
    }
    return (_ctx, _cache) => {
      return openBlock230(), createBlock225(unref233(_sfc_main116), mergeProps92(unref233(forwarded), {
        "data-reka-menubar-content": "",
        style: {
          "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
          "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
          "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onKeydown: withKeys14(handleArrowNavigation, ["arrow-right"])
      }), {
        default: withCtx226(() => [
          renderSlot230(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarSubTrigger.js
import { defineComponent as defineComponent239, createBlock as createBlock226, openBlock as openBlock231, unref as unref234, mergeProps as mergeProps93, withCtx as withCtx227, renderSlot as renderSlot231 } from "vue";
var _sfc_main234 = defineComponent239({
  __name: "MenubarSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock231(), createBlock226(unref234(_sfc_main119), mergeProps93(props2, { "data-reka-menubar-subtrigger": "" }), {
        default: withCtx227(() => [
          renderSlot231(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Menubar/MenubarTrigger.js
import { defineComponent as defineComponent240, ref as ref64, computed as computed62, onMounted as onMounted28, createBlock as createBlock227, openBlock as openBlock232, unref as unref235, withCtx as withCtx228, createVNode as createVNode34, withKeys as withKeys15, renderSlot as renderSlot232 } from "vue";
var _sfc_main235 = defineComponent240({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const rootContext = injectMenubarRootContext();
    const menuContext = injectMenubarMenuContext();
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    const { CollectionItem } = useCollection({ key: "Menubar" });
    const isFocused = ref64(false);
    const open = computed62(() => rootContext.modelValue.value === menuContext.value);
    onMounted28(() => {
      menuContext.triggerElement = triggerElement;
    });
    return (_ctx, _cache) => {
      return openBlock232(), createBlock227(unref235(_sfc_main54), {
        "as-child": "",
        focusable: !_ctx.disabled,
        "tab-stop-id": unref235(menuContext).value
      }, {
        default: withCtx228(() => [
          createVNode34(unref235(CollectionItem), null, {
            default: withCtx228(() => [
              createVNode34(unref235(_sfc_main118), { "as-child": "" }, {
                default: withCtx228(() => [
                  createVNode34(unref235(Primitive), {
                    id: unref235(menuContext).triggerId,
                    ref: unref235(forwardRef),
                    as: _ctx.as,
                    type: _ctx.as === "button" ? "button" : void 0,
                    role: "menuitem",
                    "aria-haspopup": "menu",
                    "aria-expanded": open.value,
                    "aria-controls": open.value ? unref235(menuContext).contentId : void 0,
                    "data-highlighted": isFocused.value ? "" : void 0,
                    "data-state": open.value ? "open" : "closed",
                    "data-disabled": _ctx.disabled ? "" : void 0,
                    disabled: _ctx.disabled,
                    "data-value": unref235(menuContext).value,
                    onPointerdown: _cache[0] || (_cache[0] = (event) => {
                      if (!_ctx.disabled && event.button === 0 && event.ctrlKey === false) {
                        unref235(rootContext).onMenuOpen(unref235(menuContext).value);
                        if (!open.value) event.preventDefault();
                      }
                    }),
                    onPointerenter: _cache[1] || (_cache[1] = () => {
                      const menubarOpen = Boolean(unref235(rootContext).modelValue.value);
                      if (menubarOpen && !open.value) {
                        unref235(rootContext).onMenuOpen(unref235(menuContext).value);
                        unref235(triggerElement)?.focus();
                      }
                    }),
                    onKeydown: _cache[2] || (_cache[2] = withKeys15((event) => {
                      if (_ctx.disabled) return;
                      if (["Enter", " "].includes(event.key)) unref235(rootContext).onMenuToggle(unref235(menuContext).value);
                      if (event.key === "ArrowDown") unref235(rootContext).onMenuOpen(unref235(menuContext).value);
                      if (["Enter", " ", "ArrowDown"].includes(event.key)) {
                        unref235(menuContext).wasKeyboardTriggerOpenRef.value = true;
                        event.preventDefault();
                      }
                    }, ["enter", "space", "arrow-down"])),
                    onFocus: _cache[3] || (_cache[3] = ($event) => isFocused.value = true),
                    onBlur: _cache[4] || (_cache[4] = ($event) => isFocused.value = false)
                  }, {
                    default: withCtx228(() => [
                      renderSlot232(_ctx.$slots, "default")
                    ]),
                    _: 3
                  }, 8, ["id", "as", "type", "aria-expanded", "aria-controls", "data-highlighted", "data-state", "data-disabled", "disabled", "data-value"])
                ]),
                _: 3
              })
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["focusable", "tab-stop-id"]);
    };
  }
});

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuContent.js
import { defineComponent as defineComponent244, computed as computed65, createBlock as createBlock231, openBlock as openBlock236, Teleport as Teleport2, unref as unref239, createVNode as createVNode36, withCtx as withCtx232, mergeProps as mergeProps95, renderSlot as renderSlot236 } from "vue";

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuContentImpl.js
import { defineComponent as defineComponent243, ref as ref67, computed as computed64, watchEffect as watchEffect13, createBlock as createBlock230, openBlock as openBlock235, unref as unref238, mergeProps as mergeProps94, withCtx as withCtx231, renderSlot as renderSlot235 } from "vue";

// node_modules/reka-ui/dist/NavigationMenu/utils.js
function getOpenState2(open) {
  return open ? "open" : "closed";
}
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var LINK_SELECT = "navigationMenu.linkSelect";
var EVENT_ROOT_CONTENT_DISMISS = "navigationMenu.rootContentDismiss";
function getTabbableCandidates2(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst4(candidates) {
  const previouslyFocusedElement = getActiveElement();
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement)
      return true;
    candidate.focus();
    return getActiveElement() !== previouslyFocusedElement;
  });
}
function removeFromTabOrder(candidates) {
  candidates.forEach((candidate) => {
    candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
    candidate.setAttribute("tabindex", "-1");
  });
  return () => {
    candidates.forEach((candidate) => {
      const prevTabIndex = candidate.dataset.tabindex;
      candidate.setAttribute("tabindex", prevTabIndex);
    });
  };
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuItem.js
import { defineComponent as defineComponent242, ref as ref66, createBlock as createBlock229, openBlock as openBlock234, unref as unref237, withKeys as withKeys16, withCtx as withCtx230, renderSlot as renderSlot234 } from "vue";

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuRoot.js
import { defineComponent as defineComponent241, ref as ref65, toRefs as toRefs30, computed as computed63, watchEffect as watchEffect12, createBlock as createBlock228, openBlock as openBlock233, unref as unref236, withCtx as withCtx229, createVNode as createVNode35, renderSlot as renderSlot233 } from "vue";
var [injectNavigationMenuContext, provideNavigationMenuContext] = createContext(["NavigationMenuRoot", "NavigationMenuSub"], "NavigationMenuContext");
var _sfc_main236 = defineComponent241({
  __name: "NavigationMenuRoot",
  props: {
    modelValue: { default: void 0 },
    defaultValue: {},
    dir: {},
    orientation: { default: "horizontal" },
    delayDuration: { default: 200 },
    skipDelayDuration: { default: 300 },
    disableClickTrigger: { type: Boolean, default: false },
    disableHoverTrigger: { type: Boolean, default: false },
    disablePointerLeaveClose: { type: Boolean },
    unmountOnHide: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: { default: "nav" }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? "",
      passive: props2.modelValue === void 0
    });
    const previousValue = ref65("");
    const { forwardRef, currentElement: rootNavigationMenu } = useForwardExpose();
    const indicatorTrack = ref65();
    const viewport = ref65();
    const activeTrigger = ref65();
    const { getItems, CollectionSlot } = useCollection({ key: "NavigationMenu", isProvider: true });
    const { delayDuration, skipDelayDuration, dir: propDir, disableClickTrigger, disableHoverTrigger, unmountOnHide } = toRefs30(props2);
    const dir = useDirection(propDir);
    const isDelaySkipped = refAutoReset(false, skipDelayDuration);
    const computedDelay = computed63(() => {
      const isOpen = modelValue.value !== "";
      if (isOpen || isDelaySkipped.value)
        return 150;
      else return delayDuration.value;
    });
    const debouncedFn = useDebounceFn((val) => {
      if (typeof val === "string") {
        previousValue.value = modelValue.value;
        modelValue.value = val;
      }
    }, computedDelay);
    watchEffect12(() => {
      if (!modelValue.value)
        return;
      const items = getItems().map((i) => i.ref);
      activeTrigger.value = items.find(
        (item) => item.id.includes(modelValue.value)
      );
    });
    provideNavigationMenuContext({
      isRootMenu: true,
      modelValue,
      previousValue,
      baseId: useId2(void 0, "reka-navigation-menu"),
      disableClickTrigger,
      disableHoverTrigger,
      dir,
      unmountOnHide,
      orientation: props2.orientation,
      rootNavigationMenu,
      indicatorTrack,
      activeTrigger,
      onIndicatorTrackChange: (val) => {
        indicatorTrack.value = val;
      },
      viewport,
      onViewportChange: (val) => {
        viewport.value = val;
      },
      onTriggerEnter: (val) => {
        debouncedFn(val);
      },
      onTriggerLeave: () => {
        isDelaySkipped.value = true;
        debouncedFn("");
      },
      onContentEnter: () => {
        debouncedFn();
      },
      onContentLeave: () => {
        if (!props2.disablePointerLeaveClose)
          debouncedFn("");
      },
      onItemSelect: (val) => {
        previousValue.value = modelValue.value;
        modelValue.value = val;
      },
      onItemDismiss: () => {
        previousValue.value = modelValue.value;
        modelValue.value = "";
      }
    });
    return (_ctx, _cache) => {
      return openBlock233(), createBlock228(unref236(CollectionSlot), null, {
        default: withCtx229(() => [
          createVNode35(unref236(Primitive), {
            ref: unref236(forwardRef),
            "aria-label": "Main",
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "data-orientation": _ctx.orientation,
            dir: unref236(dir),
            "data-reka-navigation-menu": ""
          }, {
            default: withCtx229(() => [
              renderSlot233(_ctx.$slots, "default", { modelValue: unref236(modelValue) })
            ]),
            _: 3
          }, 8, ["as", "as-child", "data-orientation", "dir"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuItem.js
var [injectNavigationMenuItemContext, provideNavigationMenuItemContext] = createContext("NavigationMenuItem");
var _sfc_main237 = defineComponent242({
  __name: "NavigationMenuItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const { getItems } = useCollection({ key: "NavigationMenu" });
    const context2 = injectNavigationMenuContext();
    const value = useId2(props2.value);
    const triggerRef2 = ref66();
    const focusProxyRef = ref66();
    const contentId = makeContentId(context2.baseId, value);
    let restoreContentTabOrderRef = () => ({});
    const wasEscapeCloseRef = ref66(false);
    async function handleContentEntry(side = "start") {
      const el = document.getElementById(contentId);
      if (el) {
        restoreContentTabOrderRef();
        const candidates = getTabbableCandidates2(el);
        if (candidates.length)
          focusFirst4(side === "start" ? candidates : candidates.reverse());
      }
    }
    function handleContentExit() {
      const el = document.getElementById(contentId);
      if (el) {
        const candidates = getTabbableCandidates2(el);
        if (candidates.length)
          restoreContentTabOrderRef = removeFromTabOrder(candidates);
      }
    }
    provideNavigationMenuItemContext({
      value,
      contentId,
      triggerRef: triggerRef2,
      focusProxyRef,
      wasEscapeCloseRef,
      onEntryKeyDown: handleContentEntry,
      onFocusProxyEnter: handleContentEntry,
      onContentFocusOutside: handleContentExit,
      onRootContentClose: handleContentExit
    });
    function handleClose() {
      context2.onItemDismiss();
      triggerRef2.value?.focus();
    }
    function handleKeydown(ev) {
      const currentFocus = getActiveElement();
      if (ev.keyCode === 32 || ev.key === "Enter") {
        if (context2.modelValue.value === value) {
          handleClose();
          ev.preventDefault();
          return;
        } else {
          ev.target.click();
          ev.preventDefault();
          return;
        }
      }
      const itemsArray = getItems().filter(
        (i) => i.ref.parentElement?.hasAttribute("data-menu-item")
      ).map((i) => i.ref);
      if (!itemsArray.includes(currentFocus))
        return;
      const newSelectedElement = useArrowNavigation(ev, currentFocus, void 0, {
        itemsArray,
        loop: false
      });
      if (newSelectedElement)
        newSelectedElement?.focus();
      ev.preventDefault();
      ev.stopPropagation();
    }
    return (_ctx, _cache) => {
      return openBlock234(), createBlock229(unref237(Primitive), {
        "as-child": _ctx.asChild,
        as: _ctx.as,
        "data-menu-item": "",
        onKeydown: withKeys16(handleKeydown, ["up", "down", "left", "right", "home", "end", "space"])
      }, {
        default: withCtx230(() => [
          renderSlot234(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuContentImpl.js
var _sfc_main238 = defineComponent243({
  __name: "NavigationMenuContentImpl",
  props: {
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { getItems } = useCollection({ key: "NavigationMenu" });
    const { forwardRef, currentElement } = useForwardExpose();
    const menuContext = injectNavigationMenuContext();
    const itemContext = injectNavigationMenuItemContext();
    const triggerId = makeTriggerId(menuContext.baseId, itemContext.value);
    const contentId = makeContentId(menuContext.baseId, itemContext.value);
    const prevMotionAttributeRef = ref67(null);
    const motionAttribute = computed64(() => {
      const values = getItems().map((i) => i.ref.id.split("trigger-")[1]);
      if (menuContext.dir.value === "rtl")
        values.reverse();
      const index = values.indexOf(menuContext.modelValue.value);
      const prevIndex = values.indexOf(menuContext.previousValue.value);
      const isSelected = itemContext.value === menuContext.modelValue.value;
      const wasSelected = prevIndex === values.indexOf(itemContext.value);
      if (!isSelected && !wasSelected)
        return prevMotionAttributeRef.value;
      const attribute = (() => {
        if (index !== prevIndex) {
          if (isSelected && prevIndex !== -1)
            return index > prevIndex ? "from-end" : "from-start";
          if (wasSelected && index !== -1)
            return index > prevIndex ? "to-start" : "to-end";
        }
        return null;
      })();
      prevMotionAttributeRef.value = attribute;
      return attribute;
    });
    function handleFocusOutside(ev) {
      emits("focusOutside", ev);
      emits("interactOutside", ev);
      const target = ev.detail.originalEvent.target;
      if (target.hasAttribute("data-navigation-menu-trigger"))
        ev.preventDefault();
      if (!ev.defaultPrevented) {
        itemContext.onContentFocusOutside();
        const target2 = ev.target;
        if (menuContext.rootNavigationMenu?.value?.contains(target2))
          ev.preventDefault();
      }
    }
    function handlePointerDownOutside(ev) {
      emits("pointerDownOutside", ev);
      if (!ev.defaultPrevented) {
        const target = ev.target;
        const isTrigger = getItems().some(
          (i) => i.ref.contains(target)
        );
        const isRootViewport = menuContext.isRootMenu && menuContext.viewport.value?.contains(target);
        if (isTrigger || isRootViewport || !menuContext.isRootMenu)
          ev.preventDefault();
      }
    }
    watchEffect13((cleanupFn) => {
      const content = currentElement.value;
      if (menuContext.isRootMenu && content) {
        const handleClose = () => {
          menuContext.onItemDismiss();
          itemContext.onRootContentClose();
          if (content.contains(getActiveElement()))
            itemContext.triggerRef.value?.focus();
        };
        content.addEventListener(EVENT_ROOT_CONTENT_DISMISS, handleClose);
        cleanupFn(
          () => content.removeEventListener(EVENT_ROOT_CONTENT_DISMISS, handleClose)
        );
      }
    });
    function handleEscapeKeyDown(ev) {
      emits("escapeKeyDown", ev);
      if (!ev.defaultPrevented) {
        menuContext.onItemDismiss();
        itemContext.triggerRef?.value?.focus();
        itemContext.wasEscapeCloseRef.value = true;
      }
    }
    function handleKeydown(ev) {
      if (ev.target.closest("[data-reka-navigation-menu]") !== menuContext.rootNavigationMenu.value)
        return;
      const isMetaKey = ev.altKey || ev.ctrlKey || ev.metaKey;
      const isTabKey = ev.key === "Tab" && !isMetaKey;
      const candidates = getTabbableCandidates2(ev.currentTarget);
      if (isTabKey) {
        const focusedElement = getActiveElement();
        const index = candidates.findIndex(
          (candidate) => candidate === focusedElement
        );
        const isMovingBackwards = ev.shiftKey;
        const nextCandidates = isMovingBackwards ? candidates.slice(0, index).reverse() : candidates.slice(index + 1, candidates.length);
        if (focusFirst4(nextCandidates)) {
          ev.preventDefault();
        } else {
          itemContext.focusProxyRef.value?.focus();
          return;
        }
      }
      const newSelectedElement = useArrowNavigation(
        ev,
        getActiveElement(),
        void 0,
        { itemsArray: candidates, loop: false, enableIgnoredElement: true }
      );
      newSelectedElement?.focus();
    }
    function handleDismiss() {
      const rootContentDismissEvent = new Event(EVENT_ROOT_CONTENT_DISMISS, {
        bubbles: true,
        cancelable: true
      });
      currentElement.value?.dispatchEvent(rootContentDismissEvent);
    }
    return (_ctx, _cache) => {
      return openBlock235(), createBlock230(unref238(_sfc_main14), mergeProps94({
        id: unref238(contentId),
        ref: unref238(forwardRef),
        "aria-labelledby": unref238(triggerId),
        "data-motion": motionAttribute.value,
        "data-state": unref238(getOpenState2)(unref238(menuContext).modelValue.value === unref238(itemContext).value),
        "data-orientation": unref238(menuContext).orientation
      }, props2, {
        onKeydown: handleKeydown,
        onEscapeKeyDown: handleEscapeKeyDown,
        onPointerDownOutside: handlePointerDownOutside,
        onFocusOutside: handleFocusOutside,
        onDismiss: handleDismiss
      }), {
        default: withCtx231(() => [
          renderSlot235(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby", "data-motion", "data-state", "data-orientation"]);
    };
  }
});

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuContent.js
var _sfc_main239 = defineComponent244({
  ...{
    inheritAttrs: false
  },
  __name: "NavigationMenuContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(reactiveOmit(props2, "forceMount"), emits);
    const { forwardRef } = useForwardExpose();
    const menuContext = injectNavigationMenuContext();
    const itemContext = injectNavigationMenuItemContext();
    const open = computed65(() => itemContext.value === menuContext.modelValue.value);
    const isLastActiveValue = computed65(() => {
      if (menuContext.viewport.value) {
        if (!menuContext.modelValue.value && menuContext.previousValue.value)
          return menuContext.previousValue.value === itemContext.value;
      }
      return false;
    });
    return (_ctx, _cache) => {
      return openBlock236(), createBlock231(Teleport2, {
        to: unref239(isClient) && unref239(menuContext).viewport.value ? unref239(menuContext).viewport.value : "body",
        disabled: unref239(isClient) && unref239(menuContext).viewport.value ? !unref239(menuContext).viewport.value : true
      }, [
        createVNode36(unref239(Presence), {
          present: _ctx.forceMount || open.value || isLastActiveValue.value,
          "force-mount": !unref239(menuContext).unmountOnHide.value
        }, {
          default: withCtx232(({ present }) => [
            createVNode36(_sfc_main238, mergeProps95({
              ref: unref239(forwardRef),
              "data-state": unref239(getOpenState2)(open.value),
              style: {
                pointerEvents: !open.value && unref239(menuContext).isRootMenu ? "none" : void 0
              }
            }, { ..._ctx.$attrs, ...unref239(forwarded) }, {
              hidden: !present,
              onPointerenter: _cache[0] || (_cache[0] = ($event) => unref239(menuContext).onContentEnter(unref239(itemContext).value)),
              onPointerleave: _cache[1] || (_cache[1] = ($event) => unref239(whenMouse)(() => unref239(menuContext).onContentLeave())($event)),
              onPointerDownOutside: _cache[2] || (_cache[2] = ($event) => emits("pointerDownOutside", $event)),
              onFocusOutside: _cache[3] || (_cache[3] = ($event) => emits("focusOutside", $event)),
              onInteractOutside: _cache[4] || (_cache[4] = ($event) => emits("interactOutside", $event))
            }), {
              default: withCtx232(() => [
                renderSlot236(_ctx.$slots, "default")
              ]),
              _: 2
            }, 1040, ["data-state", "style", "hidden"])
          ]),
          _: 3
        }, 8, ["present", "force-mount"])
      ], 8, ["to", "disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuIndicator.js
import { defineComponent as defineComponent245, ref as ref68, computed as computed66, watchEffect as watchEffect14, createBlock as createBlock232, createCommentVNode as createCommentVNode13, unref as unref240, openBlock as openBlock237, Teleport as Teleport3, createVNode as createVNode37, withCtx as withCtx233, mergeProps as mergeProps96, renderSlot as renderSlot237 } from "vue";
var _sfc_main240 = defineComponent245({
  ...{
    inheritAttrs: false
  },
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const menuContext = injectNavigationMenuContext();
    const indicatorStyle = ref68();
    const isHorizontal = computed66(() => menuContext.orientation === "horizontal");
    const isVisible = computed66(() => !!menuContext.modelValue.value);
    const { activeTrigger } = menuContext;
    function handlePositionChange() {
      if (!activeTrigger.value) {
        return;
      }
      indicatorStyle.value = {
        size: isHorizontal.value ? activeTrigger.value.offsetWidth : activeTrigger.value.offsetHeight,
        position: isHorizontal.value ? activeTrigger.value.offsetLeft : activeTrigger.value.offsetTop
      };
    }
    watchEffect14(() => {
      if (!menuContext.modelValue.value) {
        return;
      }
      handlePositionChange();
    });
    useResizeObserver(activeTrigger, handlePositionChange);
    useResizeObserver(menuContext.indicatorTrack, handlePositionChange);
    return (_ctx, _cache) => {
      return unref240(menuContext).indicatorTrack.value ? (openBlock237(), createBlock232(Teleport3, {
        key: 0,
        to: unref240(menuContext).indicatorTrack.value
      }, [
        createVNode37(unref240(Presence), {
          present: _ctx.forceMount || isVisible.value
        }, {
          default: withCtx233(() => [
            createVNode37(unref240(Primitive), mergeProps96({
              ref: unref240(forwardRef),
              "aria-hidden": "true",
              "data-state": isVisible.value ? "visible" : "hidden",
              "data-orientation": unref240(menuContext).orientation,
              "as-child": props2.asChild,
              as: _ctx.as,
              style: {
                ...indicatorStyle.value ? {
                  "--reka-navigation-menu-indicator-size": `${indicatorStyle.value.size}px`,
                  "--reka-navigation-menu-indicator-position": `${indicatorStyle.value.position}px`
                } : {}
              }
            }, _ctx.$attrs), {
              default: withCtx233(() => [
                renderSlot237(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["data-state", "data-orientation", "as-child", "as", "style"])
          ]),
          _: 3
        }, 8, ["present"])
      ], 8, ["to"])) : createCommentVNode13("", true);
    };
  }
});

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuLink.js
import { defineComponent as defineComponent246, createBlock as createBlock233, openBlock as openBlock238, unref as unref241, withCtx as withCtx234, createVNode as createVNode38, renderSlot as renderSlot238 } from "vue";
var _sfc_main241 = defineComponent246({
  __name: "NavigationMenuLink",
  props: {
    active: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { CollectionItem } = useCollection({ key: "NavigationMenu" });
    useForwardExpose();
    async function handleClick(ev) {
      const linkSelectEvent = new CustomEvent(LINK_SELECT, {
        bubbles: true,
        cancelable: true,
        detail: {
          originalEvent: ev
        }
      });
      emits("select", linkSelectEvent);
      if (!linkSelectEvent.defaultPrevented && !ev.metaKey) {
        const rootContentDismissEvent = new CustomEvent(
          EVENT_ROOT_CONTENT_DISMISS,
          {
            bubbles: true,
            cancelable: true
          }
        );
        ev.target?.dispatchEvent(rootContentDismissEvent);
      }
    }
    return (_ctx, _cache) => {
      return openBlock238(), createBlock233(unref241(CollectionItem), null, {
        default: withCtx234(() => [
          createVNode38(unref241(Primitive), {
            as: _ctx.as,
            "data-active": _ctx.active ? "" : void 0,
            "aria-current": _ctx.active ? "page" : void 0,
            "as-child": props2.asChild,
            onClick: handleClick
          }, {
            default: withCtx234(() => [
              renderSlot238(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["as", "data-active", "aria-current", "as-child"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuList.js
import { defineComponent as defineComponent247, onMounted as onMounted29, createBlock as createBlock234, openBlock as openBlock239, unref as unref242, withCtx as withCtx235, createVNode as createVNode39, mergeProps as mergeProps97, renderSlot as renderSlot239 } from "vue";
var _sfc_main242 = defineComponent247({
  ...{
    inheritAttrs: false
  },
  __name: "NavigationMenuList",
  props: {
    asChild: { type: Boolean },
    as: { default: "ul" }
  },
  setup(__props) {
    const props2 = __props;
    const menuContext = injectNavigationMenuContext();
    const { forwardRef, currentElement } = useForwardExpose();
    onMounted29(() => {
      menuContext.onIndicatorTrackChange(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock239(), createBlock234(unref242(Primitive), {
        ref: unref242(forwardRef),
        style: { "position": "relative" }
      }, {
        default: withCtx235(() => [
          createVNode39(unref242(Primitive), mergeProps97(_ctx.$attrs, {
            "as-child": props2.asChild,
            as: _ctx.as,
            "data-orientation": unref242(menuContext).orientation
          }), {
            default: withCtx235(() => [
              renderSlot239(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["as-child", "as", "data-orientation"])
        ]),
        _: 3
      }, 512);
    };
  }
});

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuSub.js
import { defineComponent as defineComponent248, ref as ref69, watchEffect as watchEffect15, createBlock as createBlock235, openBlock as openBlock240, unref as unref243, withCtx as withCtx236, createVNode as createVNode40, renderSlot as renderSlot240 } from "vue";
var _sfc_main243 = defineComponent248({
  __name: "NavigationMenuSub",
  props: {
    modelValue: {},
    defaultValue: {},
    orientation: { default: "horizontal" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? "",
      passive: props2.modelValue === void 0
    });
    const previousValue = ref69("");
    const menuContext = injectNavigationMenuContext();
    const { forwardRef, currentElement } = useForwardExpose();
    const indicatorTrack = ref69();
    const viewport = ref69();
    const activeTrigger = ref69();
    const { getItems, CollectionSlot } = useCollection({ key: "NavigationMenu", isProvider: true });
    watchEffect15(() => {
      if (!modelValue.value)
        return;
      const items = getItems().map((i) => i.ref);
      activeTrigger.value = items.find(
        (item) => item.id.includes(modelValue.value)
      );
    });
    provideNavigationMenuContext({
      ...menuContext,
      isRootMenu: false,
      modelValue,
      previousValue,
      activeTrigger,
      orientation: props2.orientation,
      rootNavigationMenu: currentElement,
      indicatorTrack,
      onIndicatorTrackChange: (val) => {
        indicatorTrack.value = val;
      },
      viewport,
      onViewportChange: (val) => {
        viewport.value = val;
      },
      onTriggerEnter: (val) => {
        modelValue.value = val;
      },
      onTriggerLeave: () => {
      },
      onContentEnter: () => {
      },
      onContentLeave: () => {
      },
      onItemSelect: (val) => {
        modelValue.value = val;
      },
      onItemDismiss: () => {
        modelValue.value = "";
      }
    });
    return (_ctx, _cache) => {
      return openBlock240(), createBlock235(unref243(CollectionSlot), null, {
        default: withCtx236(() => [
          createVNode40(unref243(Primitive), {
            ref: unref243(forwardRef),
            "data-orientation": _ctx.orientation,
            "as-child": props2.asChild,
            as: _ctx.as,
            "data-reka-navigation-menu": ""
          }, {
            default: withCtx236(() => [
              renderSlot240(_ctx.$slots, "default", { modelValue: unref243(modelValue) })
            ]),
            _: 3
          }, 8, ["data-orientation", "as-child", "as"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuTrigger.js
import { defineComponent as defineComponent249, ref as ref70, computed as computed67, onMounted as onMounted30, createElementBlock as createElementBlock9, openBlock as openBlock241, Fragment as Fragment7, createVNode as createVNode41, createCommentVNode as createCommentVNode14, unref as unref244, withCtx as withCtx237, mergeProps as mergeProps98, renderSlot as renderSlot241 } from "vue";
var _hoisted_14 = ["aria-owns"];
var _sfc_main244 = defineComponent249({
  ...{
    inheritAttrs: false
  },
  __name: "NavigationMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const menuContext = injectNavigationMenuContext();
    const itemContext = injectNavigationMenuItemContext();
    const { CollectionItem } = useCollection({ key: "NavigationMenu" });
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    const triggerId = ref70("");
    const contentId = ref70("");
    const hasPointerMoveOpenedRef = refAutoReset(false, 300);
    const wasClickCloseRef = ref70(false);
    const open = computed67(() => itemContext.value === menuContext.modelValue.value);
    onMounted30(() => {
      itemContext.triggerRef = triggerElement;
      triggerId.value = makeTriggerId(menuContext.baseId, itemContext.value);
      contentId.value = makeContentId(menuContext.baseId, itemContext.value);
    });
    function handlePointerEnter() {
      if (menuContext.disableHoverTrigger.value)
        return;
      wasClickCloseRef.value = false;
      itemContext.wasEscapeCloseRef.value = false;
    }
    function handlePointerMove2(ev) {
      if (menuContext.disableHoverTrigger.value)
        return;
      if (ev.pointerType === "mouse") {
        if (props2.disabled || wasClickCloseRef.value || itemContext.wasEscapeCloseRef.value || hasPointerMoveOpenedRef.value) {
          return;
        }
        menuContext.onTriggerEnter(itemContext.value);
        hasPointerMoveOpenedRef.value = true;
      }
    }
    function handlePointerLeave(ev) {
      if (menuContext.disableHoverTrigger.value)
        return;
      if (ev.pointerType === "mouse") {
        if (props2.disabled)
          return;
        menuContext.onTriggerLeave();
        hasPointerMoveOpenedRef.value = false;
      }
    }
    function handleClick(event) {
      if (event.pointerType === "mouse" && menuContext.disableClickTrigger.value)
        return;
      if (hasPointerMoveOpenedRef.value)
        return;
      if (open.value)
        menuContext.onItemSelect("");
      else menuContext.onItemSelect(itemContext.value);
      wasClickCloseRef.value = open.value;
    }
    function handleKeydown(ev) {
      const verticalEntryKey = menuContext.dir.value === "rtl" ? "ArrowLeft" : "ArrowRight";
      const entryKey = { horizontal: "ArrowDown", vertical: verticalEntryKey }[menuContext.orientation];
      if (open.value && ev.key === entryKey) {
        itemContext.onEntryKeyDown();
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
    function setFocusProxyRef(node) {
      itemContext.focusProxyRef.value = unrefElement(node);
      return void 0;
    }
    function handleVisuallyHiddenFocus(ev) {
      const content = document.getElementById(itemContext.contentId);
      const prevFocusedElement = ev.relatedTarget;
      const wasTriggerFocused = prevFocusedElement === triggerElement.value;
      const wasFocusFromContent = content?.contains(prevFocusedElement);
      if (wasTriggerFocused || !wasFocusFromContent)
        itemContext.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
    }
    return (_ctx, _cache) => {
      return openBlock241(), createElementBlock9(Fragment7, null, [
        createVNode41(unref244(CollectionItem), null, {
          default: withCtx237(() => [
            createVNode41(unref244(Primitive), mergeProps98({
              id: triggerId.value,
              ref: unref244(forwardRef),
              disabled: _ctx.disabled,
              "data-disabled": _ctx.disabled ? "" : void 0,
              "data-state": unref244(getOpenState2)(open.value),
              "data-navigation-menu-trigger": "",
              "aria-expanded": open.value,
              "aria-controls": contentId.value,
              "as-child": props2.asChild,
              as: _ctx.as
            }, _ctx.$attrs, {
              onPointerenter: handlePointerEnter,
              onPointermove: handlePointerMove2,
              onPointerleave: handlePointerLeave,
              onClick: handleClick,
              onKeydown: handleKeydown
            }), {
              default: withCtx237(() => [
                renderSlot241(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "disabled", "data-disabled", "data-state", "aria-expanded", "aria-controls", "as-child", "as"])
          ]),
          _: 3
        }),
        open.value ? (openBlock241(), createElementBlock9(Fragment7, { key: 0 }, [
          createVNode41(unref244(_sfc_main), {
            ref: setFocusProxyRef,
            "aria-hidden": "true",
            tabindex: 0,
            onFocus: handleVisuallyHiddenFocus
          }),
          unref244(menuContext).viewport ? (openBlock241(), createElementBlock9("span", {
            key: 0,
            "aria-owns": contentId.value
          }, null, 8, _hoisted_14)) : createCommentVNode14("", true)
        ], 64)) : createCommentVNode14("", true)
      ], 64);
    };
  }
});

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuViewport.js
import { defineComponent as defineComponent250, ref as ref71, computed as computed68, watch as watch29, createBlock as createBlock236, openBlock as openBlock242, unref as unref245, withCtx as withCtx238, createVNode as createVNode42, mergeProps as mergeProps99, renderSlot as renderSlot242 } from "vue";
var _sfc_main245 = defineComponent250({
  ...{
    inheritAttrs: false
  },
  __name: "NavigationMenuViewport",
  props: {
    forceMount: { type: Boolean },
    align: { default: "center" },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    const menuContext = injectNavigationMenuContext();
    const { activeTrigger, rootNavigationMenu, modelValue } = menuContext;
    const size3 = ref71();
    const position = ref71();
    const open = computed68(() => !!menuContext.modelValue.value);
    watch29(currentElement, () => {
      menuContext.onViewportChange(currentElement.value);
    });
    const content = ref71();
    watch29([modelValue, open], () => {
      if (!currentElement.value)
        return;
      requestAnimationFrame(() => {
        const el = currentElement.value?.querySelector("[data-state=open]");
        content.value = el;
      });
    }, { immediate: true, flush: "post" });
    function updatePosition() {
      if (content.value && activeTrigger.value && rootNavigationMenu.value) {
        const bodyWidth = document.documentElement.offsetWidth;
        const bodyHeight = document.documentElement.offsetHeight;
        const rootRect = rootNavigationMenu.value.getBoundingClientRect();
        const rect = activeTrigger.value.getBoundingClientRect();
        const { offsetWidth, offsetHeight } = content.value;
        const startPositionLeft = rect.left - rootRect.left;
        const startPositionTop = rect.top - rootRect.top;
        let posLeft = null;
        let posTop = null;
        switch (props2.align) {
          case "start":
            posLeft = startPositionLeft;
            posTop = startPositionTop;
            break;
          case "end":
            posLeft = startPositionLeft - offsetWidth + rect.width;
            posTop = startPositionTop - offsetHeight + rect.height;
            break;
          default:
            posLeft = startPositionLeft - offsetWidth / 2 + rect.width / 2;
            posTop = startPositionTop - offsetHeight / 2 + rect.height / 2;
        }
        const screenOffset = 10;
        if (posLeft + rootRect.left < screenOffset) {
          posLeft = screenOffset - rootRect.left;
        }
        const rightOffset = posLeft + rootRect.left + offsetWidth;
        if (rightOffset > bodyWidth - screenOffset) {
          posLeft -= rightOffset - bodyWidth + screenOffset;
          if (posLeft < screenOffset - rootRect.left) {
            posLeft = screenOffset - rootRect.left;
          }
        }
        if (posTop + rootRect.top < screenOffset) {
          posTop = screenOffset - rootRect.top;
        }
        const bottomOffset = posTop + rootRect.top + offsetHeight;
        if (bottomOffset > bodyHeight - screenOffset) {
          posTop -= bottomOffset - bodyHeight + screenOffset;
          if (posTop < screenOffset - rootRect.top) {
            posTop = screenOffset - rootRect.top;
          }
        }
        posLeft = Math.round(posLeft);
        posTop = Math.round(posTop);
        position.value = {
          left: posLeft,
          top: posTop
        };
      }
    }
    useResizeObserver(content, () => {
      if (content.value) {
        size3.value = {
          width: content.value.offsetWidth,
          height: content.value.offsetHeight
        };
        updatePosition();
      }
    });
    useResizeObserver([globalThis.document?.body, rootNavigationMenu], () => {
      updatePosition();
    });
    return (_ctx, _cache) => {
      return openBlock242(), createBlock236(unref245(Presence), {
        present: _ctx.forceMount || open.value,
        "force-mount": !unref245(menuContext).unmountOnHide.value,
        onAfterLeave: _cache[2] || (_cache[2] = () => {
          size3.value = void 0;
          position.value = void 0;
        })
      }, {
        default: withCtx238(({ present }) => [
          createVNode42(unref245(Primitive), mergeProps99(_ctx.$attrs, {
            ref: unref245(forwardRef),
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "data-state": unref245(getOpenState2)(open.value),
            "data-orientation": unref245(menuContext).orientation,
            style: {
              // Prevent interaction when animating out
              pointerEvents: !open.value && unref245(menuContext).isRootMenu ? "none" : void 0,
              ["--reka-navigation-menu-viewport-width"]: size3.value ? `${size3.value?.width}px` : void 0,
              ["--reka-navigation-menu-viewport-height"]: size3.value ? `${size3.value?.height}px` : void 0,
              ["--reka-navigation-menu-viewport-left"]: position.value ? `${position.value?.left}px` : void 0,
              ["--reka-navigation-menu-viewport-top"]: position.value ? `${position.value?.top}px` : void 0
            },
            hidden: !present,
            onPointerenter: _cache[0] || (_cache[0] = ($event) => unref245(menuContext).onContentEnter(unref245(menuContext).modelValue.value)),
            onPointerleave: _cache[1] || (_cache[1] = ($event) => unref245(whenMouse)(() => unref245(menuContext).onContentLeave())($event))
          }), {
            default: withCtx238(() => [
              renderSlot242(_ctx.$slots, "default")
            ]),
            _: 2
          }, 1040, ["as", "as-child", "data-state", "data-orientation", "style", "hidden"])
        ]),
        _: 3
      }, 8, ["present", "force-mount"]);
    };
  }
});

// node_modules/reka-ui/dist/NumberField/NumberFieldDecrement.js
import { defineComponent as defineComponent252, computed as computed71, createBlock as createBlock238, openBlock as openBlock244, unref as unref247, mergeProps as mergeProps101, withModifiers as withModifiers12, withCtx as withCtx240, renderSlot as renderSlot244 } from "vue";

// node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)} – ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
      ...options,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
      ...options,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}

// node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
      if (parser.isValidPartialNumber(value)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1) index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR" && this.symbols.group) {
      value = $6c7bd7858deea686$var$replaceAll(value, " ", this.symbols.group);
      value = $6c7bd7858deea686$var$replaceAll(value, /\u00A0/g, this.symbols.group);
    }
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n) => symbolFormatter.formatToParts(n));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p) => p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p) => p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p) => p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group = (_allParts_find1 = allParts.find((p) => p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p) => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p) => $6c7bd7858deea686$var$escapeRegex(p.value));
  let pluralPartsLiterals = pluralParts.flatMap((p) => p.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a, b) => b.length - a.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d, i) => [
    d,
    i
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d) => String(indexes.get(d));
  return {
    minusSign,
    plusSign,
    decimal,
    group,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace) {
  if (str.replaceAll) return str.replaceAll(find, replace);
  return str.split(find).join(replace);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/reka-ui/dist/NumberField/utils.js
import { ref as ref72, computed as computed69 } from "vue";
function usePressedHold(options) {
  const { disabled } = options;
  const timeout = ref72();
  const triggerHook = createEventHook();
  const resetTimeout = () => window.clearTimeout(timeout.value);
  const onIncrementPressStart = (delay) => {
    resetTimeout();
    if (disabled.value)
      return;
    triggerHook.trigger();
    timeout.value = window.setTimeout(() => {
      onIncrementPressStart(60);
    }, delay);
  };
  const handlePressStart = () => {
    onIncrementPressStart(400);
  };
  const handlePressEnd = () => {
    resetTimeout();
  };
  const isPressed = ref72(false);
  const target = computed69(() => unrefElement(options.target));
  const onPressStart = (event) => {
    if (event.button !== 0 || isPressed.value)
      return;
    event.preventDefault();
    isPressed.value = true;
    handlePressStart();
  };
  const onPressRelease = () => {
    isPressed.value = false;
    handlePressEnd();
  };
  if (isClient) {
    useEventListener(target || window, "pointerdown", onPressStart);
    useEventListener(window, "pointerup", onPressRelease);
    useEventListener(window, "pointercancel", onPressRelease);
  }
  return {
    isPressed,
    onTrigger: triggerHook.on
  };
}
function useNumberFormatter(locale, options = ref72({})) {
  return reactiveComputed(() => new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(locale.value, options.value));
}
function useNumberParser(locale, options = ref72({})) {
  return reactiveComputed(() => new $6c7bd7858deea686$export$cd11ab140839f11d(locale.value, options.value));
}
function handleDecimalOperation(operator, value1, value2) {
  let result = operator === "+" ? value1 + value2 : value1 - value2;
  if (value1 % 1 !== 0 || value2 % 1 !== 0) {
    const value1Decimal = value1.toString().split(".");
    const value2Decimal = value2.toString().split(".");
    const value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;
    const value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;
    const multiplier = 10 ** Math.max(value1DecimalLength, value2DecimalLength);
    value1 = Math.round(value1 * multiplier);
    value2 = Math.round(value2 * multiplier);
    result = operator === "+" ? value1 + value2 : value1 - value2;
    result /= multiplier;
  }
  return result;
}

// node_modules/reka-ui/dist/NumberField/NumberFieldRoot.js
import { defineComponent as defineComponent251, toRefs as toRefs31, ref as ref73, computed as computed70, createBlock as createBlock237, openBlock as openBlock243, unref as unref246, mergeProps as mergeProps100, withCtx as withCtx239, renderSlot as renderSlot243, createCommentVNode as createCommentVNode15 } from "vue";

// node_modules/reka-ui/dist/shared/clamp.js
function clamp3(value, min2 = Number.NEGATIVE_INFINITY, max2 = Number.POSITIVE_INFINITY) {
  return Math.min(max2, Math.max(min2, value));
}
function roundToStepPrecision(value, step) {
  let roundedValue = value;
  const stepString = step.toString();
  const pointIndex = stepString.indexOf(".");
  const precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;
  if (precision > 0) {
    const pow = 10 ** precision;
    roundedValue = Math.round(roundedValue * pow) / pow;
  }
  return roundedValue;
}
function snapValueToStep(value, min2, max2, step) {
  min2 = Number(min2);
  max2 = Number(max2);
  const remainder = (value - (Number.isNaN(min2) ? 0 : min2)) % step;
  let snappedValue = roundToStepPrecision(Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder, step);
  if (!Number.isNaN(min2)) {
    if (snappedValue < min2)
      snappedValue = min2;
    else if (!Number.isNaN(max2) && snappedValue > max2)
      snappedValue = min2 + Math.floor(roundToStepPrecision((max2 - min2) / step, step)) * step;
  } else if (!Number.isNaN(max2) && snappedValue > max2) {
    snappedValue = Math.floor(roundToStepPrecision(max2 / step, step)) * step;
  }
  snappedValue = roundToStepPrecision(snappedValue, step);
  return snappedValue;
}

// node_modules/reka-ui/dist/NumberField/NumberFieldRoot.js
var [injectNumberFieldRootContext, provideNumberFieldRootContext] = createContext("NumberFieldRoot");
var _sfc_main246 = defineComponent251({
  ...{
    inheritAttrs: false
  },
  __name: "NumberFieldRoot",
  props: {
    defaultValue: { default: void 0 },
    modelValue: {},
    min: {},
    max: {},
    step: { default: 1 },
    stepSnapping: { type: Boolean, default: true },
    formatOptions: {},
    locale: {},
    disabled: { type: Boolean },
    disableWheelChange: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: { default: "div" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, disableWheelChange, min: min2, max: max2, step, stepSnapping, formatOptions, id, locale: propLocale } = toRefs31(props2);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const locale = useLocale(propLocale);
    const isFormControl = useFormControl(currentElement);
    const inputEl = ref73();
    const isDecreaseDisabled = computed70(
      () => clampInputValue(modelValue.value) === min2.value || (min2.value && !isNaN(modelValue.value) ? handleDecimalOperation("-", modelValue.value, step.value) < min2.value : false)
    );
    const isIncreaseDisabled = computed70(
      () => clampInputValue(modelValue.value) === max2.value || (max2.value && !isNaN(modelValue.value) ? handleDecimalOperation("+", modelValue.value, step.value) > max2.value : false)
    );
    function handleChangingValue(type, multiplier = 1) {
      inputEl.value?.focus();
      const currentInputValue = numberParser.parse(inputEl.value?.value ?? "");
      if (props2.disabled)
        return;
      if (isNaN(currentInputValue)) {
        modelValue.value = min2.value ?? 0;
      } else {
        if (type === "increase")
          modelValue.value = clampInputValue(currentInputValue + (step.value ?? 1) * multiplier);
        else
          modelValue.value = clampInputValue(currentInputValue - (step.value ?? 1) * multiplier);
      }
    }
    function handleIncrease(multiplier = 1) {
      handleChangingValue("increase", multiplier);
    }
    function handleDecrease(multiplier = 1) {
      handleChangingValue("decrease", multiplier);
    }
    function handleMinMaxValue(type) {
      if (type === "min" && min2.value !== void 0)
        modelValue.value = clampInputValue(min2.value);
      else if (type === "max" && max2.value !== void 0)
        modelValue.value = clampInputValue(max2.value);
    }
    const numberFormatter = useNumberFormatter(locale, formatOptions);
    const numberParser = useNumberParser(locale, formatOptions);
    const inputMode = computed70(() => {
      const hasDecimals = numberFormatter.resolvedOptions().maximumFractionDigits > 0;
      return hasDecimals ? "decimal" : "numeric";
    });
    const textValueFormatter = useNumberFormatter(locale, formatOptions);
    const textValue = computed70(() => isNaN(modelValue.value) ? "" : textValueFormatter.format(modelValue.value));
    function validate(val) {
      return numberParser.isValidPartialNumber(val, min2.value, max2.value);
    }
    function setInputValue(val) {
      if (inputEl.value)
        inputEl.value.value = val;
    }
    function clampInputValue(val) {
      let clampedValue;
      if (step.value === void 0 || isNaN(step.value) || !stepSnapping.value)
        clampedValue = clamp3(val, min2.value, max2.value);
      else
        clampedValue = snapValueToStep(val, min2.value, max2.value, step.value);
      clampedValue = numberParser.parse(numberFormatter.format(clampedValue));
      return clampedValue;
    }
    function applyInputValue(val) {
      const parsedValue = numberParser.parse(val);
      modelValue.value = clampInputValue(parsedValue);
      if (!val.length)
        return setInputValue(val);
      if (isNaN(parsedValue))
        return setInputValue(textValue.value);
      return setInputValue(textValue.value);
    }
    provideNumberFieldRootContext({
      modelValue,
      handleDecrease,
      handleIncrease,
      handleMinMaxValue,
      inputMode,
      inputEl,
      onInputElement: (el) => inputEl.value = el,
      textValue,
      validate,
      applyInputValue,
      disabled,
      disableWheelChange,
      max: max2,
      min: min2,
      isDecreaseDisabled,
      isIncreaseDisabled,
      id
    });
    return (_ctx, _cache) => {
      return openBlock243(), createBlock237(unref246(Primitive), mergeProps100(_ctx.$attrs, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        role: "group",
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-disabled": unref246(disabled) ? "" : void 0
      }), {
        default: withCtx239(() => [
          renderSlot243(_ctx.$slots, "default", {
            modelValue: unref246(modelValue),
            textValue: textValue.value
          }),
          unref246(isFormControl) && _ctx.name ? (openBlock243(), createBlock237(unref246(_sfc_main52), {
            key: 0,
            type: "text",
            value: unref246(modelValue),
            name: _ctx.name,
            disabled: unref246(disabled),
            required: _ctx.required
          }, null, 8, ["value", "name", "disabled", "required"])) : createCommentVNode15("", true)
        ]),
        _: 3
      }, 16, ["as", "as-child", "data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/NumberField/NumberFieldDecrement.js
var _sfc_main247 = defineComponent252({
  __name: "NumberFieldDecrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectNumberFieldRootContext();
    const isDisabled = computed71(() => rootContext.disabled?.value || props2.disabled || rootContext.isDecreaseDisabled.value);
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const { isPressed, onTrigger } = usePressedHold({ target: currentElement, disabled: isDisabled });
    onTrigger(() => {
      rootContext.handleDecrease();
    });
    return (_ctx, _cache) => {
      return openBlock244(), createBlock238(unref247(Primitive), mergeProps101(props2, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        tabindex: "-1",
        "aria-label": "Decrease",
        type: _ctx.as === "button" ? "button" : void 0,
        style: {
          userSelect: unref247(isPressed) ? "none" : void 0
        },
        disabled: isDisabled.value ? "" : void 0,
        "data-disabled": isDisabled.value ? "" : void 0,
        "data-pressed": unref247(isPressed) ? "true" : void 0,
        onContextmenu: _cache[0] || (_cache[0] = withModifiers12(() => {
        }, ["prevent"]))
      }), {
        default: withCtx240(() => [
          renderSlot244(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["type", "style", "disabled", "data-disabled", "data-pressed"]);
    };
  }
});

// node_modules/reka-ui/dist/NumberField/NumberFieldIncrement.js
import { defineComponent as defineComponent253, computed as computed72, createBlock as createBlock239, openBlock as openBlock245, unref as unref248, mergeProps as mergeProps102, withModifiers as withModifiers13, withCtx as withCtx241, renderSlot as renderSlot245 } from "vue";
var _sfc_main248 = defineComponent253({
  __name: "NumberFieldIncrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectNumberFieldRootContext();
    const isDisabled = computed72(() => rootContext.disabled?.value || props2.disabled || rootContext.isIncreaseDisabled.value);
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const { isPressed, onTrigger } = usePressedHold({ target: currentElement, disabled: isDisabled });
    onTrigger(() => {
      rootContext.handleIncrease();
    });
    return (_ctx, _cache) => {
      return openBlock245(), createBlock239(unref248(Primitive), mergeProps102(props2, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        tabindex: "-1",
        "aria-label": "Increase",
        type: _ctx.as === "button" ? "button" : void 0,
        style: {
          userSelect: unref248(isPressed) ? "none" : void 0
        },
        disabled: isDisabled.value ? "" : void 0,
        "data-disabled": isDisabled.value ? "" : void 0,
        "data-pressed": unref248(isPressed) ? "true" : void 0,
        onContextmenu: _cache[0] || (_cache[0] = withModifiers13(() => {
        }, ["prevent"]))
      }), {
        default: withCtx241(() => [
          renderSlot245(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["type", "style", "disabled", "data-disabled", "data-pressed"]);
    };
  }
});

// node_modules/reka-ui/dist/NumberField/NumberFieldInput.js
import { defineComponent as defineComponent254, onMounted as onMounted31, ref as ref74, watch as watch30, createBlock as createBlock240, openBlock as openBlock246, unref as unref249, mergeProps as mergeProps103, withKeys as withKeys17, withModifiers as withModifiers14, withCtx as withCtx242, renderSlot as renderSlot246 } from "vue";
var _sfc_main249 = defineComponent254({
  __name: "NumberFieldInput",
  props: {
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(__props) {
    const props2 = __props;
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const rootContext = injectNumberFieldRootContext();
    function handleWheelEvent(event) {
      if (rootContext.disableWheelChange.value)
        return;
      if (event.target !== getActiveElement())
        return;
      if (Math.abs(event.deltaY) <= Math.abs(event.deltaX))
        return;
      event.preventDefault();
      if (event.deltaY > 0)
        rootContext.handleIncrease();
      else if (event.deltaY < 0)
        rootContext.handleDecrease();
    }
    onMounted31(() => {
      rootContext.onInputElement(currentElement.value);
    });
    const inputValue = ref74(rootContext.textValue.value);
    watch30(() => rootContext.textValue.value, () => {
      inputValue.value = rootContext.textValue.value;
    }, { immediate: true, deep: true });
    function handleChange() {
      requestAnimationFrame(() => {
        inputValue.value = rootContext.textValue.value;
      });
    }
    return (_ctx, _cache) => {
      return openBlock246(), createBlock240(unref249(Primitive), mergeProps103(props2, {
        id: unref249(rootContext).id.value,
        ref_key: "primitiveElement",
        ref: primitiveElement,
        value: inputValue.value,
        role: "spinbutton",
        type: "text",
        tabindex: "0",
        inputmode: unref249(rootContext).inputMode.value,
        disabled: unref249(rootContext).disabled.value ? "" : void 0,
        "data-disabled": unref249(rootContext).disabled.value ? "" : void 0,
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: "false",
        "aria-roledescription": "Number field",
        "aria-valuenow": unref249(rootContext).modelValue.value,
        "aria-valuemin": unref249(rootContext).min.value,
        "aria-valuemax": unref249(rootContext).max.value,
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys17(withModifiers14(($event) => unref249(rootContext).handleIncrease(), ["prevent"]), ["up"])),
          _cache[1] || (_cache[1] = withKeys17(withModifiers14(($event) => unref249(rootContext).handleDecrease(), ["prevent"]), ["down"])),
          _cache[2] || (_cache[2] = withKeys17(withModifiers14(($event) => unref249(rootContext).handleIncrease(10), ["prevent"]), ["page-up"])),
          _cache[3] || (_cache[3] = withKeys17(withModifiers14(($event) => unref249(rootContext).handleDecrease(10), ["prevent"]), ["page-down"])),
          _cache[4] || (_cache[4] = withKeys17(withModifiers14(($event) => unref249(rootContext).handleMinMaxValue("min"), ["prevent"]), ["home"])),
          _cache[5] || (_cache[5] = withKeys17(withModifiers14(($event) => unref249(rootContext).handleMinMaxValue("max"), ["prevent"]), ["end"])),
          _cache[8] || (_cache[8] = withKeys17(($event) => unref249(rootContext).applyInputValue($event.target?.value), ["enter"]))
        ],
        onWheel: handleWheelEvent,
        onBeforeinput: _cache[6] || (_cache[6] = (event) => {
          const target = event.target;
          let nextValue = target.value.slice(0, target.selectionStart ?? void 0) + (event.data ?? "") + target.value.slice(target.selectionEnd ?? void 0);
          if (!unref249(rootContext).validate(nextValue))
            event.preventDefault();
        }),
        onInput: _cache[7] || (_cache[7] = (event) => {
          const target = event.target;
          inputValue.value = target.value;
        }),
        onChange: handleChange,
        onBlur: _cache[9] || (_cache[9] = ($event) => unref249(rootContext).applyInputValue($event.target?.value))
      }), {
        default: withCtx242(() => [
          renderSlot246(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "value", "inputmode", "disabled", "data-disabled", "aria-valuenow", "aria-valuemin", "aria-valuemax"]);
    };
  }
});

// node_modules/reka-ui/dist/Pagination/PaginationEllipsis.js
import { defineComponent as defineComponent255, createBlock as createBlock241, openBlock as openBlock247, unref as unref250, mergeProps as mergeProps104, withCtx as withCtx243, renderSlot as renderSlot247, createTextVNode as createTextVNode18 } from "vue";
var _sfc_main250 = defineComponent255({
  __name: "PaginationEllipsis",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock247(), createBlock241(unref250(Primitive), mergeProps104(props2, { "data-type": "ellipsis" }), {
        default: withCtx243(() => [
          renderSlot247(_ctx.$slots, "default", {}, () => [
            _cache[0] || (_cache[0] = createTextVNode18("…"))
          ])
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Pagination/PaginationFirst.js
import { defineComponent as defineComponent257, computed as computed74, createBlock as createBlock243, openBlock as openBlock249, unref as unref252, mergeProps as mergeProps105, withCtx as withCtx245, renderSlot as renderSlot249, createTextVNode as createTextVNode19 } from "vue";

// node_modules/reka-ui/dist/Pagination/PaginationRoot.js
import { defineComponent as defineComponent256, toRefs as toRefs32, computed as computed73, createBlock as createBlock242, openBlock as openBlock248, unref as unref251, withCtx as withCtx244, renderSlot as renderSlot248 } from "vue";
var [injectPaginationRootContext, providePaginationRootContext] = createContext("PaginationRoot");
var _sfc_main251 = defineComponent256({
  __name: "PaginationRoot",
  props: {
    page: {},
    defaultPage: { default: 1 },
    itemsPerPage: {},
    total: { default: 0 },
    siblingCount: { default: 2 },
    disabled: { type: Boolean },
    showEdges: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: { default: "nav" }
  },
  emits: ["update:page"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { siblingCount, disabled, showEdges } = toRefs32(props2);
    useForwardExpose();
    const page = useVModel(props2, "page", emits, {
      defaultValue: props2.defaultPage,
      passive: props2.page === void 0
    });
    const pageCount = computed73(() => Math.max(1, Math.ceil(props2.total / (props2.itemsPerPage || 1))));
    providePaginationRootContext({
      page,
      onPageChange(value) {
        page.value = value;
      },
      pageCount,
      siblingCount,
      disabled,
      showEdges
    });
    return (_ctx, _cache) => {
      return openBlock248(), createBlock242(unref251(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, {
        default: withCtx244(() => [
          renderSlot248(_ctx.$slots, "default", {
            page: unref251(page),
            pageCount: pageCount.value
          })
        ]),
        _: 3
      }, 8, ["as", "as-child"]);
    };
  }
});

// node_modules/reka-ui/dist/Pagination/PaginationFirst.js
var _sfc_main252 = defineComponent257({
  __name: "PaginationFirst",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectPaginationRootContext();
    useForwardExpose();
    const disabled = computed74(() => rootContext.page.value === 1 || rootContext.disabled.value);
    return (_ctx, _cache) => {
      return openBlock249(), createBlock243(unref252(Primitive), mergeProps105(props2, {
        "aria-label": "First Page",
        type: _ctx.as === "button" ? "button" : void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => !disabled.value && unref252(rootContext).onPageChange(1))
      }), {
        default: withCtx245(() => [
          renderSlot249(_ctx.$slots, "default", {}, () => [
            _cache[1] || (_cache[1] = createTextVNode19("First page"))
          ])
        ]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Pagination/PaginationLast.js
import { defineComponent as defineComponent258, computed as computed75, createBlock as createBlock244, openBlock as openBlock250, unref as unref253, mergeProps as mergeProps106, withCtx as withCtx246, renderSlot as renderSlot250, createTextVNode as createTextVNode20 } from "vue";
var _sfc_main253 = defineComponent258({
  __name: "PaginationLast",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectPaginationRootContext();
    useForwardExpose();
    const disabled = computed75(() => rootContext.page.value === rootContext.pageCount.value || rootContext.disabled.value);
    return (_ctx, _cache) => {
      return openBlock250(), createBlock244(unref253(Primitive), mergeProps106(props2, {
        "aria-label": "Last Page",
        type: _ctx.as === "button" ? "button" : void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => !disabled.value && unref253(rootContext).onPageChange(unref253(rootContext).pageCount.value))
      }), {
        default: withCtx246(() => [
          renderSlot250(_ctx.$slots, "default", {}, () => [
            _cache[1] || (_cache[1] = createTextVNode20("Last page"))
          ])
        ]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Pagination/PaginationList.js
import { defineComponent as defineComponent259, computed as computed76, createBlock as createBlock245, openBlock as openBlock251, unref as unref254, normalizeProps as normalizeProps96, guardReactiveProps as guardReactiveProps93, withCtx as withCtx247, renderSlot as renderSlot251 } from "vue";

// node_modules/reka-ui/dist/Pagination/utils.js
function range(start, end) {
  const length = end - start + 1;
  return Array.from({ length }, (_, idx) => idx + start);
}
function transform(items) {
  return items.map((value) => {
    if (typeof value === "number")
      return { type: "page", value };
    return { type: "ellipsis" };
  });
}
var ELLIPSIS = "ellipsis";
function getRange(currentPage, pageCount, siblingCount, showEdges) {
  const firstPageIndex = 1;
  const lastPageIndex = pageCount;
  const leftSiblingIndex = Math.max(currentPage - siblingCount, firstPageIndex);
  const rightSiblingIndex = Math.min(currentPage + siblingCount, lastPageIndex);
  if (showEdges) {
    const totalPageNumbers = Math.min(2 * siblingCount + 5, pageCount);
    const itemCount = totalPageNumbers - 2;
    const showLeftEllipsis = leftSiblingIndex > firstPageIndex + 2 && Math.abs(lastPageIndex - itemCount - firstPageIndex + 1) > 2 && Math.abs(leftSiblingIndex - firstPageIndex) > 2;
    const showRightEllipsis = rightSiblingIndex < lastPageIndex - 2 && Math.abs(lastPageIndex - itemCount) > 2 && Math.abs(lastPageIndex - rightSiblingIndex) > 2;
    if (!showLeftEllipsis && showRightEllipsis) {
      const leftRange = range(1, itemCount);
      return [...leftRange, ELLIPSIS, lastPageIndex];
    }
    if (showLeftEllipsis && !showRightEllipsis) {
      const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);
      return [firstPageIndex, ELLIPSIS, ...rightRange];
    }
    if (showLeftEllipsis && showRightEllipsis) {
      const middleRange = range(leftSiblingIndex, rightSiblingIndex);
      return [firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex];
    }
    const fullRange = range(firstPageIndex, lastPageIndex);
    return fullRange;
  } else {
    const itemCount = siblingCount * 2 + 1;
    if (pageCount < itemCount)
      return range(1, lastPageIndex);
    else if (currentPage <= siblingCount + 1)
      return range(firstPageIndex, itemCount);
    else if (pageCount - currentPage <= siblingCount)
      return range(pageCount - itemCount + 1, lastPageIndex);
    else
      return range(leftSiblingIndex, rightSiblingIndex);
  }
}

// node_modules/reka-ui/dist/Pagination/PaginationList.js
var _sfc_main254 = defineComponent259({
  __name: "PaginationList",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPaginationRootContext();
    const transformedRange = computed76(() => {
      return transform(
        getRange(
          rootContext.page.value,
          rootContext.pageCount.value,
          rootContext.siblingCount.value,
          rootContext.showEdges.value
        )
      );
    });
    return (_ctx, _cache) => {
      return openBlock251(), createBlock245(unref254(Primitive), normalizeProps96(guardReactiveProps93(props2)), {
        default: withCtx247(() => [
          renderSlot251(_ctx.$slots, "default", { items: transformedRange.value })
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Pagination/PaginationListItem.js
import { defineComponent as defineComponent260, computed as computed77, createBlock as createBlock246, openBlock as openBlock252, unref as unref255, mergeProps as mergeProps107, withCtx as withCtx248, renderSlot as renderSlot252, createTextVNode as createTextVNode21, toDisplayString as toDisplayString11 } from "vue";
var _sfc_main255 = defineComponent260({
  __name: "PaginationListItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPaginationRootContext();
    const isSelected = computed77(() => rootContext.page.value === props2.value);
    const disabled = computed77(() => rootContext.disabled.value);
    return (_ctx, _cache) => {
      return openBlock252(), createBlock246(unref255(Primitive), mergeProps107(props2, {
        "data-type": "page",
        "aria-label": `Page ${_ctx.value}`,
        "aria-current": isSelected.value ? "page" : void 0,
        "data-selected": isSelected.value ? "true" : void 0,
        disabled: disabled.value,
        type: _ctx.as === "button" ? "button" : void 0,
        onClick: _cache[0] || (_cache[0] = ($event) => !disabled.value && unref255(rootContext).onPageChange(_ctx.value))
      }), {
        default: withCtx248(() => [
          renderSlot252(_ctx.$slots, "default", {}, () => [
            createTextVNode21(toDisplayString11(_ctx.value), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-label", "aria-current", "data-selected", "disabled", "type"]);
    };
  }
});

// node_modules/reka-ui/dist/Pagination/PaginationNext.js
import { defineComponent as defineComponent261, computed as computed78, createBlock as createBlock247, openBlock as openBlock253, unref as unref256, mergeProps as mergeProps108, withCtx as withCtx249, renderSlot as renderSlot253, createTextVNode as createTextVNode22 } from "vue";
var _sfc_main256 = defineComponent261({
  __name: "PaginationNext",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPaginationRootContext();
    const disabled = computed78(() => rootContext.page.value === rootContext.pageCount.value || rootContext.disabled.value);
    return (_ctx, _cache) => {
      return openBlock253(), createBlock247(unref256(Primitive), mergeProps108(props2, {
        "aria-label": "Next Page",
        type: _ctx.as === "button" ? "button" : void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => !disabled.value && unref256(rootContext).onPageChange(unref256(rootContext).page.value + 1))
      }), {
        default: withCtx249(() => [
          renderSlot253(_ctx.$slots, "default", {}, () => [
            _cache[1] || (_cache[1] = createTextVNode22("Next page"))
          ])
        ]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/Pagination/PaginationPrev.js
import { defineComponent as defineComponent262, computed as computed79, createBlock as createBlock248, openBlock as openBlock254, unref as unref257, mergeProps as mergeProps109, withCtx as withCtx250, renderSlot as renderSlot254, createTextVNode as createTextVNode23 } from "vue";
var _sfc_main257 = defineComponent262({
  __name: "PaginationPrev",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPaginationRootContext();
    const disabled = computed79(() => rootContext.page.value === 1 || rootContext.disabled.value);
    return (_ctx, _cache) => {
      return openBlock254(), createBlock248(unref257(Primitive), mergeProps109(props2, {
        "aria-label": "Previous Page",
        type: _ctx.as === "button" ? "button" : void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => !disabled.value && unref257(rootContext).onPageChange(unref257(rootContext).page.value - 1))
      }), {
        default: withCtx250(() => [
          renderSlot254(_ctx.$slots, "default", {}, () => [
            _cache[1] || (_cache[1] = createTextVNode23("Prev page"))
          ])
        ]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/PinInput/PinInputInput.js
import { defineComponent as defineComponent264, computed as computed81, watch as watch32, onMounted as onMounted32, onUnmounted as onUnmounted14, createBlock as createBlock250, openBlock as openBlock256, unref as unref259, withKeys as withKeys18, withCtx as withCtx252, renderSlot as renderSlot256, nextTick as nextTick25 } from "vue";

// node_modules/reka-ui/dist/PinInput/PinInputRoot.js
import { defineComponent as defineComponent263, toRefs as toRefs33, computed as computed80, ref as ref75, watch as watch31, createBlock as createBlock249, openBlock as openBlock255, unref as unref258, mergeProps as mergeProps110, withCtx as withCtx251, renderSlot as renderSlot255, createVNode as createVNode43 } from "vue";
var [injectPinInputRootContext, providePinInputRootContext] = createContext("PinInputRoot");
var _sfc_main258 = defineComponent263({
  ...{
    inheritAttrs: false
  },
  __name: "PinInputRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    placeholder: { default: "" },
    mask: { type: Boolean },
    otp: { type: Boolean },
    type: { default: "text" },
    dir: {},
    disabled: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "complete"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { mask, otp, placeholder, type, disabled, dir: propDir } = toRefs33(props2);
    const { forwardRef } = useForwardExpose();
    const dir = useDirection(propDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? [],
      passive: props2.modelValue === void 0
    });
    const currentModelValue = computed80(() => Array.isArray(modelValue.value) ? [...modelValue.value] : []);
    const inputElements = ref75(/* @__PURE__ */ new Set());
    function onInputElementChange(el) {
      inputElements.value.add(el);
    }
    const isCompleted = computed80(() => {
      const modelValues = currentModelValue.value.filter((i) => !!i);
      return modelValues.length === inputElements.value.size;
    });
    watch31(modelValue, () => {
      if (isCompleted.value)
        emits("complete", modelValue.value);
    }, { deep: true });
    providePinInputRootContext({
      modelValue,
      currentModelValue,
      mask,
      otp,
      placeholder,
      type,
      dir,
      disabled,
      isCompleted,
      inputElements,
      onInputElementChange
    });
    return (_ctx, _cache) => {
      return openBlock255(), createBlock249(unref258(Primitive), mergeProps110(_ctx.$attrs, {
        ref: unref258(forwardRef),
        dir: unref258(dir),
        "data-complete": isCompleted.value ? "" : void 0,
        "data-disabled": unref258(disabled) ? "" : void 0
      }), {
        default: withCtx251(() => [
          renderSlot255(_ctx.$slots, "default", { modelValue: unref258(modelValue) }),
          createVNode43(_sfc_main52, {
            id: _ctx.id,
            as: "input",
            feature: "focusable",
            tabindex: "-1",
            value: currentModelValue.value.join(""),
            name: _ctx.name ?? "",
            disabled: unref258(disabled),
            required: _ctx.required,
            onFocus: _cache[0] || (_cache[0] = ($event) => Array.from(inputElements.value)?.[0]?.focus())
          }, null, 8, ["id", "value", "name", "disabled", "required"])
        ]),
        _: 3
      }, 16, ["dir", "data-complete", "data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/PinInput/PinInputInput.js
var _sfc_main259 = defineComponent264({
  __name: "PinInputInput",
  props: {
    index: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectPinInputRootContext();
    const inputElements = computed81(() => Array.from(context2.inputElements.value));
    const currentValue = computed81(() => context2.currentModelValue.value[props2.index]);
    const disabled = computed81(() => props2.disabled || context2.disabled.value);
    const isOtpMode = computed81(() => context2.otp.value);
    const isNumericMode = computed81(() => context2.type.value === "number");
    const isPasswordMode = computed81(() => context2.mask.value);
    const { primitiveElement, currentElement } = usePrimitiveElement();
    function handleInput(event) {
      const target = event.target;
      if ((event.data?.length ?? 0) > 1) {
        handleMultipleCharacter(target.value);
        return;
      }
      if (isNumericMode.value && !/^\d*$/.test(target.value)) {
        target.value = target.value.replace(/\D/g, "");
        return;
      }
      target.value = target.value.slice(-1);
      updateModelValueAt(props2.index, target.value);
      const nextEl = inputElements.value[props2.index + 1];
      if (nextEl)
        nextEl.focus();
    }
    function resetPlaceholder() {
      const target = currentElement.value;
      nextTick25(() => {
        if (target && !target.value)
          target.placeholder = context2.placeholder.value;
      });
    }
    function handleKeydown(event) {
      useArrowNavigation(event, getActiveElement(), void 0, {
        itemsArray: inputElements.value,
        focus: true,
        loop: false,
        arrowKeyOptions: "horizontal",
        dir: context2.dir.value
      });
    }
    function handleBackspace(event) {
      event.preventDefault();
      const target = event.target;
      const value = target.value;
      if (value) {
        updateModelValueAt(props2.index, "");
      } else {
        const prevEl = inputElements.value[props2.index - 1];
        if (prevEl) {
          prevEl.focus();
          updateModelValueAt(props2.index - 1, "");
        }
      }
    }
    function handleDelete(event) {
      if (event.key === "Delete") {
        event.preventDefault();
        updateModelValueAt(props2.index, "");
      }
    }
    function handleFocus(event) {
      const target = event.target;
      target.setSelectionRange(1, 1);
      if (!target.value)
        target.placeholder = "";
    }
    function handleBlur(event) {
      resetPlaceholder();
    }
    function handlePaste(event) {
      event.preventDefault();
      const clipboardData = event.clipboardData;
      if (!clipboardData)
        return;
      const values = clipboardData.getData("text");
      handleMultipleCharacter(values);
    }
    function handleMultipleCharacter(values) {
      const tempModelValue = [...context2.currentModelValue.value];
      const initialIndex = values.length >= inputElements.value.length ? 0 : props2.index;
      const lastIndex = Math.min(initialIndex + values.length, inputElements.value.length);
      for (let i = initialIndex; i < lastIndex; i++) {
        const input = inputElements.value[i];
        const value = values[i - initialIndex];
        if (isNumericMode.value && !/^\d*$/.test(value))
          continue;
        tempModelValue[i] = value;
        input.focus();
      }
      context2.modelValue.value = tempModelValue;
      inputElements.value[lastIndex]?.focus();
    }
    function removeTrailingEmptyStrings(input) {
      let i = input.length - 1;
      while (i >= 0 && input[i] === "") {
        input.pop();
        i--;
      }
      return input;
    }
    function updateModelValueAt(index, value) {
      const tempModelValue = [...context2.currentModelValue.value];
      tempModelValue[index] = value;
      context2.modelValue.value = removeTrailingEmptyStrings(tempModelValue);
    }
    watch32(currentValue, () => {
      if (!currentValue.value) {
        resetPlaceholder();
      }
    });
    onMounted32(() => {
      context2.onInputElementChange(currentElement.value);
    });
    onUnmounted14(() => {
      context2.inputElements?.value.delete(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock256(), createBlock250(unref259(Primitive), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        autocapitalize: "none",
        as: _ctx.as,
        "as-child": _ctx.asChild,
        autocomplete: isOtpMode.value ? "one-time-code" : "false",
        type: isPasswordMode.value ? "password" : "text",
        inputmode: isNumericMode.value ? "numeric" : "text",
        pattern: isNumericMode.value ? "[0-9]*" : void 0,
        placeholder: unref259(context2).placeholder.value,
        value: currentValue.value,
        disabled: disabled.value,
        "data-disabled": disabled.value ? "" : void 0,
        "data-complete": unref259(context2).isCompleted.value ? "" : void 0,
        "aria-label": `pin input ${_ctx.index + 1} of ${inputElements.value.length}`,
        onInput: _cache[0] || (_cache[0] = ($event) => handleInput($event)),
        onKeydown: [
          withKeys18(handleKeydown, ["left", "right", "up", "down", "home", "end"]),
          withKeys18(handleBackspace, ["backspace"]),
          withKeys18(handleDelete, ["delete"])
        ],
        onFocus: handleFocus,
        onBlur: handleBlur,
        onPaste: handlePaste
      }, {
        default: withCtx252(() => [
          renderSlot256(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "autocomplete", "type", "inputmode", "pattern", "placeholder", "value", "disabled", "data-disabled", "data-complete", "aria-label"]);
    };
  }
});

// node_modules/reka-ui/dist/Progress/ProgressIndicator.js
import { defineComponent as defineComponent266, createBlock as createBlock252, openBlock as openBlock258, unref as unref261, mergeProps as mergeProps111, withCtx as withCtx254, renderSlot as renderSlot258 } from "vue";

// node_modules/reka-ui/dist/Progress/ProgressRoot.js
import { defineComponent as defineComponent265, watch as watch33, nextTick as nextTick26, computed as computed82, createBlock as createBlock251, openBlock as openBlock257, unref as unref260, withCtx as withCtx253, renderSlot as renderSlot257 } from "vue";
var DEFAULT_MAX = 100;
var [injectProgressRootContext, provideProgressRootContext] = createContext("ProgressRoot");
var isNumber = (v) => typeof v === "number";
function validateValue(value, max2) {
  const isValidValueError = isNullish(value) || isNumber(value) && !Number.isNaN(value) && value <= max2 && value >= 0;
  if (isValidValueError)
    return value;
  console.error(`Invalid prop \`value\` of value \`${value}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\`  or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`);
  return null;
}
function validateMax(max2) {
  const isValidMaxError = isNumber(max2) && !Number.isNaN(max2) && max2 > 0;
  if (isValidMaxError)
    return max2;
  console.error(
    `Invalid prop \`max\` of value \`${max2}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`
  );
  return DEFAULT_MAX;
}
var _sfc_main260 = defineComponent265({
  __name: "ProgressRoot",
  props: {
    modelValue: {},
    max: { default: DEFAULT_MAX },
    getValueLabel: { type: Function, default: (value, max2) => `${Math.round(value / max2 * DEFAULT_MAX)}%` },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:max"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    useForwardExpose();
    const modelValue = useVModel(props2, "modelValue", emit, {
      passive: props2.modelValue === void 0
    });
    const max2 = useVModel(props2, "max", emit, {
      passive: props2.max === void 0
    });
    watch33(
      () => modelValue.value,
      async (value) => {
        const correctedValue = validateValue(value, props2.max);
        if (correctedValue !== value) {
          await nextTick26();
          modelValue.value = correctedValue;
        }
      },
      { immediate: true }
    );
    watch33(
      () => props2.max,
      (newMax) => {
        const correctedMax = validateMax(props2.max);
        if (correctedMax !== newMax)
          max2.value = correctedMax;
      },
      { immediate: true }
    );
    const progressState = computed82(() => {
      if (isNullish(modelValue.value))
        return "indeterminate";
      if (modelValue.value === max2.value)
        return "complete";
      return "loading";
    });
    provideProgressRootContext({
      modelValue,
      max: max2,
      progressState
    });
    return (_ctx, _cache) => {
      return openBlock257(), createBlock251(unref260(Primitive), {
        "as-child": _ctx.asChild,
        as: _ctx.as,
        "aria-valuemax": unref260(max2),
        "aria-valuemin": 0,
        "aria-valuenow": isNumber(unref260(modelValue)) ? unref260(modelValue) : void 0,
        "aria-valuetext": _ctx.getValueLabel(unref260(modelValue), unref260(max2)),
        "aria-label": _ctx.getValueLabel(unref260(modelValue), unref260(max2)),
        role: "progressbar",
        "data-state": progressState.value,
        "data-value": unref260(modelValue) ?? void 0,
        "data-max": unref260(max2)
      }, {
        default: withCtx253(() => [
          renderSlot257(_ctx.$slots, "default", { modelValue: unref260(modelValue) })
        ]),
        _: 3
      }, 8, ["as-child", "as", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-label", "data-state", "data-value", "data-max"]);
    };
  }
});

// node_modules/reka-ui/dist/Progress/ProgressIndicator.js
var _sfc_main261 = defineComponent266({
  __name: "ProgressIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectProgressRootContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock258(), createBlock252(unref261(Primitive), mergeProps111(props2, {
        "data-state": unref261(rootContext).progressState.value,
        "data-value": unref261(rootContext).modelValue?.value ?? void 0,
        "data-max": unref261(rootContext).max.value
      }), {
        default: withCtx254(() => [
          renderSlot258(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["data-state", "data-value", "data-max"]);
    };
  }
});

// node_modules/reka-ui/dist/RadioGroup/RadioGroupIndicator.js
import { defineComponent as defineComponent270, createBlock as createBlock256, openBlock as openBlock262, unref as unref265, withCtx as withCtx258, createVNode as createVNode46, mergeProps as mergeProps114, renderSlot as renderSlot262 } from "vue";

// node_modules/reka-ui/dist/RadioGroup/RadioGroupItem.js
import { defineComponent as defineComponent269, computed as computed84, ref as ref76, createBlock as createBlock255, openBlock as openBlock261, unref as unref264, withCtx as withCtx257, createVNode as createVNode45, mergeProps as mergeProps113, withKeys as withKeys19, withModifiers as withModifiers16, renderSlot as renderSlot261 } from "vue";

// node_modules/reka-ui/dist/RadioGroup/Radio.js
import { defineComponent as defineComponent267, toRefs as toRefs34, computed as computed83, createBlock as createBlock253, openBlock as openBlock259, unref as unref262, mergeProps as mergeProps112, withModifiers as withModifiers15, withCtx as withCtx255, renderSlot as renderSlot259, createCommentVNode as createCommentVNode16 } from "vue";

// node_modules/reka-ui/dist/RadioGroup/utils.js
var RADIO_SELECT = "radio.select";
function handleSelect(event, value, callback) {
  const eventDetail = { originalEvent: event, value };
  handleAndDispatchCustomEvent(RADIO_SELECT, callback, eventDetail);
}

// node_modules/reka-ui/dist/RadioGroup/Radio.js
var _sfc_main262 = defineComponent267({
  __name: "Radio",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: false },
    checked: { type: Boolean, default: void 0 },
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:checked", "select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const checked = useVModel(props2, "checked", emits, {
      passive: props2.checked === void 0
    });
    const { value } = toRefs34(props2);
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    const isFormControl = useFormControl(triggerElement);
    const ariaLabel = computed83(() => props2.id && triggerElement.value ? document.querySelector(`[for="${props2.id}"]`)?.innerText ?? props2.value : void 0);
    function handleClick(event) {
      handleSelect(event, props2.value, (ev) => {
        emits("select", ev);
        if (ev?.defaultPrevented)
          return;
        checked.value = true;
        if (isFormControl.value) {
          ev.stopPropagation();
        }
      });
    }
    return (_ctx, _cache) => {
      return openBlock259(), createBlock253(unref262(Primitive), mergeProps112(_ctx.$attrs, {
        id: _ctx.id,
        ref: unref262(forwardRef),
        role: "radio",
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "aria-checked": unref262(checked),
        "aria-label": ariaLabel.value,
        "as-child": _ctx.asChild,
        disabled: _ctx.disabled ? "" : void 0,
        "data-state": unref262(checked) ? "checked" : "unchecked",
        "data-disabled": _ctx.disabled ? "" : void 0,
        value: unref262(value),
        required: _ctx.required,
        name: _ctx.name,
        onClick: withModifiers15(handleClick, ["stop"])
      }), {
        default: withCtx255(() => [
          renderSlot259(_ctx.$slots, "default", { checked: unref262(checked) }),
          unref262(isFormControl) && _ctx.name ? (openBlock259(), createBlock253(unref262(_sfc_main52), {
            key: 0,
            type: "radio",
            tabindex: "-1",
            value: unref262(value),
            checked: !!unref262(checked),
            name: _ctx.name,
            disabled: _ctx.disabled,
            required: _ctx.required
          }, null, 8, ["value", "checked", "name", "disabled", "required"])) : createCommentVNode16("", true)
        ]),
        _: 3
      }, 16, ["id", "type", "as", "aria-checked", "aria-label", "as-child", "disabled", "data-state", "data-disabled", "value", "required", "name"]);
    };
  }
});

// node_modules/reka-ui/dist/RadioGroup/RadioGroupRoot.js
import { defineComponent as defineComponent268, toRefs as toRefs35, createBlock as createBlock254, openBlock as openBlock260, unref as unref263, withCtx as withCtx256, createVNode as createVNode44, renderSlot as renderSlot260, createCommentVNode as createCommentVNode17 } from "vue";
var [injectRadioGroupRootContext, provideRadioGroupRootContext] = createContext("RadioGroupRoot");
var _sfc_main263 = defineComponent268({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean, default: false },
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const { disabled, loop, orientation, name, required, dir: propDir } = toRefs35(props2);
    const dir = useDirection(propDir);
    const isFormControl = useFormControl(currentElement);
    provideRadioGroupRootContext({
      modelValue,
      changeModelValue: (value) => {
        modelValue.value = value;
      },
      disabled,
      loop,
      orientation,
      name: name?.value,
      required
    });
    return (_ctx, _cache) => {
      return openBlock260(), createBlock254(unref263(_sfc_main50), {
        "as-child": "",
        orientation: unref263(orientation),
        dir: unref263(dir),
        loop: unref263(loop)
      }, {
        default: withCtx256(() => [
          createVNode44(unref263(Primitive), {
            ref: unref263(forwardRef),
            role: "radiogroup",
            "data-disabled": unref263(disabled) ? "" : void 0,
            "as-child": _ctx.asChild,
            as: _ctx.as,
            "aria-orientation": unref263(orientation),
            "aria-required": unref263(required),
            dir: unref263(dir)
          }, {
            default: withCtx256(() => [
              renderSlot260(_ctx.$slots, "default", { modelValue: unref263(modelValue) }),
              unref263(isFormControl) && unref263(name) ? (openBlock260(), createBlock254(unref263(_sfc_main52), {
                key: 0,
                required: unref263(required),
                disabled: unref263(disabled),
                value: unref263(modelValue),
                name: unref263(name)
              }, null, 8, ["required", "disabled", "value", "name"])) : createCommentVNode17("", true)
            ]),
            _: 3
          }, 8, ["data-disabled", "as-child", "as", "aria-orientation", "aria-required", "dir"])
        ]),
        _: 3
      }, 8, ["orientation", "dir", "loop"]);
    };
  }
});

// node_modules/reka-ui/dist/RadioGroup/RadioGroupItem.js
var [injectRadioGroupItemContext, provideRadiogroupItemContext] = createContext("RadioGroupItem");
var _sfc_main264 = defineComponent269({
  ...{
    inheritAttrs: false
  },
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectRadioGroupRootContext();
    const disabled = computed84(() => rootContext.disabled.value || props2.disabled);
    const required = computed84(() => rootContext.required.value || props2.required);
    const checked = computed84(() => isEqual(rootContext.modelValue?.value, props2.value));
    provideRadiogroupItemContext({ disabled, checked });
    const isArrowKeyPressed = ref76(false);
    const ARROW_KEYS2 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
    useEventListener("keydown", (event) => {
      if (ARROW_KEYS2.includes(event.key))
        isArrowKeyPressed.value = true;
    });
    useEventListener("keyup", () => {
      isArrowKeyPressed.value = false;
    });
    function handleFocus() {
      setTimeout(() => {
        if (isArrowKeyPressed.value)
          currentElement.value?.click();
      }, 0);
    }
    return (_ctx, _cache) => {
      return openBlock261(), createBlock255(unref264(_sfc_main54), {
        checked: checked.value,
        disabled: disabled.value,
        "as-child": "",
        focusable: !disabled.value,
        active: checked.value
      }, {
        default: withCtx257(() => [
          createVNode45(_sfc_main262, mergeProps113({ ..._ctx.$attrs, ...props2 }, {
            ref: unref264(forwardRef),
            checked: checked.value,
            required: required.value,
            disabled: disabled.value,
            "onUpdate:checked": _cache[0] || (_cache[0] = ($event) => unref264(rootContext).changeModelValue(_ctx.value)),
            onSelect: _cache[1] || (_cache[1] = ($event) => emits("select", $event)),
            onKeydown: _cache[2] || (_cache[2] = withKeys19(withModifiers16(() => {
            }, ["prevent"]), ["enter"])),
            onFocus: handleFocus
          }), {
            default: withCtx257(() => [
              renderSlot261(_ctx.$slots, "default", {
                checked: checked.value,
                required: required.value,
                disabled: disabled.value
              })
            ]),
            _: 3
          }, 16, ["checked", "required", "disabled"])
        ]),
        _: 3
      }, 8, ["checked", "disabled", "focusable", "active"]);
    };
  }
});

// node_modules/reka-ui/dist/RadioGroup/RadioGroupIndicator.js
var _sfc_main265 = defineComponent270({
  __name: "RadioGroupIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const { forwardRef } = useForwardExpose();
    const itemContext = injectRadioGroupItemContext();
    return (_ctx, _cache) => {
      return openBlock262(), createBlock256(unref265(Presence), {
        present: _ctx.forceMount || unref265(itemContext).checked.value
      }, {
        default: withCtx258(() => [
          createVNode46(unref265(Primitive), mergeProps114({
            ref: unref265(forwardRef),
            "data-state": unref265(itemContext).checked.value ? "checked" : "unchecked",
            "data-disabled": unref265(itemContext).disabled.value ? "" : void 0,
            "as-child": _ctx.asChild,
            as: _ctx.as
          }, _ctx.$attrs), {
            default: withCtx258(() => [
              renderSlot262(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["data-state", "data-disabled", "as-child", "as"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaCorner.js
import { defineComponent as defineComponent273, computed as computed86, createBlock as createBlock259, createCommentVNode as createCommentVNode19, openBlock as openBlock265, mergeProps as mergeProps116, unref as unref268, withCtx as withCtx261, renderSlot as renderSlot265 } from "vue";

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaCornerImpl.js
import { defineComponent as defineComponent272, ref as ref78, computed as computed85, watch as watch34, createBlock as createBlock258, createCommentVNode as createCommentVNode18, openBlock as openBlock264, unref as unref267, mergeProps as mergeProps115, withCtx as withCtx260, renderSlot as renderSlot264 } from "vue";

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaRoot.js
import { defineComponent as defineComponent271, ref as ref77, toRefs as toRefs36, createBlock as createBlock257, openBlock as openBlock263, unref as unref266, normalizeStyle as normalizeStyle6, withCtx as withCtx259, renderSlot as renderSlot263 } from "vue";
var [injectScrollAreaRootContext, provideScrollAreaRootContext] = createContext("ScrollAreaRoot");
var _sfc_main266 = defineComponent271({
  __name: "ScrollAreaRoot",
  props: {
    type: { default: "hover" },
    dir: {},
    scrollHideDelay: { default: 600 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props, { expose: __expose }) {
    const props2 = __props;
    const cornerWidth = ref77(0);
    const cornerHeight = ref77(0);
    const viewport = ref77();
    const content = ref77();
    const scrollbarX = ref77();
    const scrollbarY = ref77();
    const scrollbarXEnabled = ref77(false);
    const scrollbarYEnabled = ref77(false);
    const { type, dir: propDir, scrollHideDelay } = toRefs36(props2);
    const dir = useDirection(propDir);
    function scrollTop() {
      viewport.value?.scrollTo({
        top: 0
      });
    }
    function scrollTopLeft() {
      viewport.value?.scrollTo({
        top: 0,
        left: 0
      });
    }
    __expose({
      /** Viewport element within ScrollArea */
      viewport,
      /** Scroll viewport to top */
      scrollTop,
      /** Scroll viewport to top-left */
      scrollTopLeft
    });
    const { forwardRef, currentElement: scrollArea } = useForwardExpose();
    provideScrollAreaRootContext({
      type,
      dir,
      scrollHideDelay,
      scrollArea,
      viewport,
      onViewportChange: (el) => {
        viewport.value = el || void 0;
      },
      content,
      onContentChange: (el) => {
        content.value = el;
      },
      scrollbarX,
      scrollbarXEnabled,
      scrollbarY,
      scrollbarYEnabled,
      onScrollbarXChange: (scrollbar) => {
        scrollbarX.value = scrollbar || void 0;
      },
      onScrollbarYChange: (scrollbar) => {
        scrollbarY.value = scrollbar || void 0;
      },
      onScrollbarXEnabledChange: (rendered) => {
        scrollbarXEnabled.value = rendered;
      },
      onScrollbarYEnabledChange: (rendered) => {
        scrollbarYEnabled.value = rendered;
      },
      onCornerWidthChange: (width) => {
        cornerWidth.value = width;
      },
      onCornerHeightChange: (height) => {
        cornerHeight.value = height;
      }
    });
    return (_ctx, _cache) => {
      return openBlock263(), createBlock257(unref266(Primitive), {
        ref: unref266(forwardRef),
        "as-child": props2.asChild,
        as: _ctx.as,
        dir: unref266(dir),
        style: normalizeStyle6({
          position: "relative",
          // Pass corner sizes as CSS vars to reduce re-renders of context consumers
          ["--reka-scroll-area-corner-width"]: `${cornerWidth.value}px`,
          ["--reka-scroll-area-corner-height"]: `${cornerHeight.value}px`
        })
      }, {
        default: withCtx259(() => [
          renderSlot263(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as", "dir", "style"]);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaCornerImpl.js
var _sfc_main267 = defineComponent272({
  __name: "ScrollAreaCornerImpl",
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const width = ref78(0);
    const height = ref78(0);
    const hasSize = computed85(() => !!width.value && !!height.value);
    function setCornerHeight() {
      const offsetHeight = rootContext.scrollbarX.value?.offsetHeight || 0;
      rootContext.onCornerHeightChange(offsetHeight);
      height.value = offsetHeight;
    }
    function setCornerWidth() {
      const offsetWidth = rootContext.scrollbarY.value?.offsetWidth || 0;
      rootContext.onCornerWidthChange(offsetWidth);
      width.value = offsetWidth;
    }
    useResizeObserver(rootContext.scrollbarX.value, setCornerHeight);
    useResizeObserver(rootContext.scrollbarY.value, setCornerWidth);
    watch34(() => rootContext.scrollbarX.value, setCornerHeight);
    watch34(() => rootContext.scrollbarY.value, setCornerWidth);
    return (_ctx, _cache) => {
      return hasSize.value ? (openBlock264(), createBlock258(unref267(Primitive), mergeProps115({
        key: 0,
        style: {
          width: `${width.value}px`,
          height: `${height.value}px`,
          position: "absolute",
          right: unref267(rootContext).dir.value === "ltr" ? 0 : void 0,
          left: unref267(rootContext).dir.value === "rtl" ? 0 : void 0,
          bottom: 0
        }
      }, _ctx.$parent?.$props), {
        default: withCtx260(() => [
          renderSlot264(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])) : createCommentVNode18("", true);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaCorner.js
var _sfc_main268 = defineComponent273({
  __name: "ScrollAreaCorner",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const rootContext = injectScrollAreaRootContext();
    const hasBothScrollbarsVisible = computed86(
      () => !!rootContext.scrollbarX.value && !!rootContext.scrollbarY.value
    );
    const hasCorner = computed86(
      () => rootContext.type.value !== "scroll" && hasBothScrollbarsVisible.value
    );
    return (_ctx, _cache) => {
      return hasCorner.value ? (openBlock265(), createBlock259(_sfc_main267, mergeProps116({ key: 0 }, props2, { ref: unref268(forwardRef) }), {
        default: withCtx261(() => [
          renderSlot265(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode19("", true);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbar.js
import { defineComponent as defineComponent281, computed as computed90, watch as watch35, onUnmounted as onUnmounted17, toRefs as toRefs37, createBlock as createBlock267, createCommentVNode as createCommentVNode20, unref as unref276, openBlock as openBlock273, mergeProps as mergeProps121, withCtx as withCtx269, renderSlot as renderSlot273 } from "vue";

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarAuto.js
import { defineComponent as defineComponent278, ref as ref81, onMounted as onMounted36, createBlock as createBlock264, openBlock as openBlock270, unref as unref273, withCtx as withCtx266, createVNode as createVNode47, mergeProps as mergeProps118, renderSlot as renderSlot270 } from "vue";

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarVisible.js
import { defineComponent as defineComponent277, ref as ref80, computed as computed89, createBlock as createBlock263, openBlock as openBlock269, mergeProps as mergeProps117, unref as unref272, withCtx as withCtx265, renderSlot as renderSlot269 } from "vue";

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarX.js
import { defineComponent as defineComponent275, onMounted as onMounted34, computed as computed87, createBlock as createBlock261, openBlock as openBlock267, unref as unref270, normalizeStyle as normalizeStyle7, withCtx as withCtx263, renderSlot as renderSlot267 } from "vue";

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarImpl.js
import { defineComponent as defineComponent274, ref as ref79, onMounted as onMounted33, onUnmounted as onUnmounted15, createBlock as createBlock260, openBlock as openBlock266, unref as unref269, withCtx as withCtx262, renderSlot as renderSlot266 } from "vue";

// node_modules/reka-ui/dist/ScrollArea/utils.js
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function addUnlinkedScrollListener(node, handler = () => {
}) {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position.left;
    const isVerticalScroll = prevPosition.top !== position.top;
    if (isHorizontalScroll || isVerticalScroll)
      handler();
    prevPosition = position;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp3(
    scrollPos,
    scrollClampRange[0],
    scrollClampRange[1]
  );
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function toInt(value) {
  return value ? Number.parseInt(value, 10) : 0;
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset3 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset3;
  const minPointerPos = sizes.scrollbar.paddingStart + offset3;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale(
    [minPointerPos, maxPointerPos],
    scrollRange
  );
  return interpolate(pointerPos);
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarImpl.js
var _sfc_main269 = defineComponent274({
  __name: "ScrollAreaScrollbarImpl",
  props: {
    isHorizontal: { type: Boolean }
  },
  emits: ["onDragScroll", "onWheelScroll", "onThumbPointerDown"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const rootContext = injectScrollAreaRootContext();
    const scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext();
    const scrollbarContext = injectScrollAreaScrollbarContext();
    const { forwardRef, currentElement: scrollbar } = useForwardExpose();
    const prevWebkitUserSelectRef = ref79("");
    const rectRef = ref79();
    function handleDragScroll(event) {
      if (rectRef.value) {
        const x = event.clientX - rectRef.value?.left;
        const y = event.clientY - rectRef.value?.top;
        emit("onDragScroll", { x, y });
      }
    }
    function handlePointerDown2(event) {
      const mainPointer = 0;
      if (event.button === mainPointer) {
        const element = event.target;
        element.setPointerCapture(event.pointerId);
        rectRef.value = scrollbar.value.getBoundingClientRect();
        prevWebkitUserSelectRef.value = document.body.style.webkitUserSelect;
        document.body.style.webkitUserSelect = "none";
        if (rootContext.viewport)
          rootContext.viewport.value.style.scrollBehavior = "auto";
        handleDragScroll(event);
      }
    }
    function handlePointerMove2(event) {
      handleDragScroll(event);
    }
    function handlePointerUp2(event) {
      const element = event.target;
      if (element.hasPointerCapture(event.pointerId))
        element.releasePointerCapture(event.pointerId);
      document.body.style.webkitUserSelect = prevWebkitUserSelectRef.value;
      if (rootContext.viewport)
        rootContext.viewport.value.style.scrollBehavior = "";
      rectRef.value = void 0;
    }
    function handleWheel(event) {
      const element = event.target;
      const isScrollbarWheel = scrollbar.value?.contains(element);
      const maxScrollPos = scrollbarVisibleContext.sizes.value.content - scrollbarVisibleContext.sizes.value.viewport;
      if (isScrollbarWheel)
        scrollbarVisibleContext.handleWheelScroll(event, maxScrollPos);
    }
    onMounted33(() => {
      document.addEventListener("wheel", handleWheel, { passive: false });
    });
    onUnmounted15(() => {
      document.removeEventListener("wheel", handleWheel);
    });
    function handleSizeChange() {
      if (!scrollbar.value)
        return;
      if (props2.isHorizontal) {
        scrollbarVisibleContext.handleSizeChange({
          content: rootContext.viewport.value?.scrollWidth ?? 0,
          viewport: rootContext.viewport.value?.offsetWidth ?? 0,
          scrollbar: {
            size: scrollbar.value.clientWidth ?? 0,
            paddingStart: toInt(getComputedStyle(scrollbar.value).paddingLeft),
            paddingEnd: toInt(getComputedStyle(scrollbar.value).paddingRight)
          }
        });
      } else {
        scrollbarVisibleContext.handleSizeChange({
          content: rootContext.viewport.value?.scrollHeight ?? 0,
          viewport: rootContext.viewport.value?.offsetHeight ?? 0,
          scrollbar: {
            size: scrollbar.value?.clientHeight ?? 0,
            paddingStart: toInt(getComputedStyle(scrollbar.value).paddingLeft),
            paddingEnd: toInt(getComputedStyle(scrollbar.value).paddingRight)
          }
        });
      }
    }
    useResizeObserver(scrollbar, handleSizeChange);
    useResizeObserver(rootContext.content, handleSizeChange);
    return (_ctx, _cache) => {
      return openBlock266(), createBlock260(unref269(Primitive), {
        ref: unref269(forwardRef),
        style: { "position": "absolute" },
        "data-scrollbarimpl": "",
        as: unref269(scrollbarContext).as.value,
        "as-child": unref269(scrollbarContext).asChild.value,
        onPointerdown: handlePointerDown2,
        onPointermove: handlePointerMove2,
        onPointerup: handlePointerUp2
      }, {
        default: withCtx262(() => [
          renderSlot266(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child"]);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarX.js
var _sfc_main270 = defineComponent275({
  __name: "ScrollAreaScrollbarX",
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext();
    const { forwardRef, currentElement: scrollbarElement } = useForwardExpose();
    onMounted34(() => {
      if (scrollbarElement.value)
        rootContext.onScrollbarXChange(scrollbarElement.value);
    });
    const sizes = computed87(() => scrollbarVisibleContext.sizes.value);
    return (_ctx, _cache) => {
      return openBlock267(), createBlock261(_sfc_main269, {
        ref: unref270(forwardRef),
        "is-horizontal": true,
        "data-orientation": "horizontal",
        style: normalizeStyle7({
          bottom: 0,
          left: unref270(rootContext).dir.value === "rtl" ? "var(--reka-scroll-area-corner-width)" : 0,
          right: unref270(rootContext).dir.value === "ltr" ? "var(--reka-scroll-area-corner-width)" : 0,
          ["--reka-scroll-area-thumb-width"]: sizes.value ? `${unref270(getThumbSize)(sizes.value)}px` : void 0
        }),
        onOnDragScroll: _cache[0] || (_cache[0] = ($event) => unref270(scrollbarVisibleContext).onDragScroll($event.x))
      }, {
        default: withCtx263(() => [
          renderSlot267(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["style"]);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarY.js
import { defineComponent as defineComponent276, onMounted as onMounted35, computed as computed88, createBlock as createBlock262, openBlock as openBlock268, unref as unref271, normalizeStyle as normalizeStyle8, withCtx as withCtx264, renderSlot as renderSlot268 } from "vue";
var _sfc_main271 = defineComponent276({
  __name: "ScrollAreaScrollbarY",
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext();
    const { forwardRef, currentElement: scrollbarElement } = useForwardExpose();
    onMounted35(() => {
      if (scrollbarElement.value)
        rootContext.onScrollbarYChange(scrollbarElement.value);
    });
    const sizes = computed88(() => scrollbarVisibleContext.sizes.value);
    return (_ctx, _cache) => {
      return openBlock268(), createBlock262(_sfc_main269, {
        ref: unref271(forwardRef),
        "is-horizontal": false,
        "data-orientation": "vertical",
        style: normalizeStyle8({
          top: 0,
          right: unref271(rootContext).dir.value === "ltr" ? 0 : void 0,
          left: unref271(rootContext).dir.value === "rtl" ? 0 : void 0,
          bottom: "var(--reka-scroll-area-corner-height)",
          ["--reka-scroll-area-thumb-height"]: sizes.value ? `${unref271(getThumbSize)(sizes.value)}px` : void 0
        }),
        onOnDragScroll: _cache[0] || (_cache[0] = ($event) => unref271(scrollbarVisibleContext).onDragScroll($event.y))
      }, {
        default: withCtx264(() => [
          renderSlot268(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["style"]);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarVisible.js
var [injectScrollAreaScrollbarVisibleContext, provideScrollAreaScrollbarVisibleContext] = createContext("ScrollAreaScrollbarVisible");
var _sfc_main272 = defineComponent277({
  __name: "ScrollAreaScrollbarVisible",
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const scrollbarContext = injectScrollAreaScrollbarContext();
    const { forwardRef } = useForwardExpose();
    const sizes = ref80({
      content: 0,
      viewport: 0,
      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
    });
    const hasThumb = computed89(() => {
      const thumbRatio = getThumbRatio(sizes.value.viewport, sizes.value.content);
      return Boolean(thumbRatio > 0 && thumbRatio < 1);
    });
    const thumbRef = ref80();
    const pointerOffset = ref80(0);
    function handleWheelScroll(event, payload) {
      if (isShowingScrollbarX.value) {
        const scrollPos = rootContext.viewport.value.scrollLeft + event.deltaY;
        rootContext.viewport.value.scrollLeft = scrollPos;
        if (isScrollingWithinScrollbarBounds(scrollPos, payload))
          event.preventDefault();
      } else {
        const scrollPos = rootContext.viewport.value.scrollTop + event.deltaY;
        rootContext.viewport.value.scrollTop = scrollPos;
        if (isScrollingWithinScrollbarBounds(scrollPos, payload))
          event.preventDefault();
      }
    }
    function handleThumbDown(event, payload) {
      if (isShowingScrollbarX.value)
        pointerOffset.value = payload.x;
      else pointerOffset.value = payload.y;
    }
    function handleThumbUp(event) {
      pointerOffset.value = 0;
    }
    function handleSizeChange(payload) {
      sizes.value = payload;
    }
    function getScrollPosition(pointerPos, dir) {
      return getScrollPositionFromPointer(
        pointerPos,
        pointerOffset.value,
        sizes.value,
        dir
      );
    }
    const isShowingScrollbarX = computed89(
      () => scrollbarContext.isHorizontal.value
    );
    function onDragScroll(payload) {
      if (isShowingScrollbarX.value) {
        rootContext.viewport.value.scrollLeft = getScrollPosition(
          payload,
          rootContext.dir.value
        );
      } else {
        rootContext.viewport.value.scrollTop = getScrollPosition(payload);
      }
    }
    function onThumbPositionChange() {
      if (isShowingScrollbarX.value) {
        if (rootContext.viewport.value && thumbRef.value) {
          const scrollPos = rootContext.viewport.value.scrollLeft;
          const offset3 = getThumbOffsetFromScroll(
            scrollPos,
            sizes.value,
            rootContext.dir.value
          );
          thumbRef.value.style.transform = `translate3d(${offset3}px, 0, 0)`;
        }
      } else {
        if (rootContext.viewport.value && thumbRef.value) {
          const scrollPos = rootContext.viewport.value.scrollTop;
          const offset3 = getThumbOffsetFromScroll(scrollPos, sizes.value);
          thumbRef.value.style.transform = `translate3d(0, ${offset3}px, 0)`;
        }
      }
    }
    function onThumbChange(element) {
      thumbRef.value = element;
    }
    provideScrollAreaScrollbarVisibleContext({
      sizes,
      hasThumb,
      handleWheelScroll,
      handleThumbDown,
      handleThumbUp,
      handleSizeChange,
      onThumbPositionChange,
      onThumbChange,
      onDragScroll
    });
    return (_ctx, _cache) => {
      return isShowingScrollbarX.value ? (openBlock269(), createBlock263(_sfc_main270, mergeProps117({ key: 0 }, _ctx.$attrs, { ref: unref272(forwardRef) }), {
        default: withCtx265(() => [
          renderSlot269(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : (openBlock269(), createBlock263(_sfc_main271, mergeProps117({ key: 1 }, _ctx.$attrs, { ref: unref272(forwardRef) }), {
        default: withCtx265(() => [
          renderSlot269(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16));
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarAuto.js
var _sfc_main273 = defineComponent278({
  __name: "ScrollAreaScrollbarAuto",
  props: {
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const scrollbarContext = injectScrollAreaScrollbarContext();
    const { forwardRef } = useForwardExpose();
    const visible = ref81(false);
    const handleResize = useDebounceFn(() => {
      if (rootContext.viewport.value) {
        const isOverflowX = rootContext.viewport.value.offsetWidth < rootContext.viewport.value.scrollWidth;
        const isOverflowY = rootContext.viewport.value.offsetHeight < rootContext.viewport.value.scrollHeight;
        visible.value = scrollbarContext.isHorizontal.value ? isOverflowX : isOverflowY;
      }
    }, 10);
    onMounted36(() => handleResize());
    useResizeObserver(rootContext.viewport, handleResize);
    useResizeObserver(rootContext.content, handleResize);
    return (_ctx, _cache) => {
      return openBlock270(), createBlock264(unref273(Presence), {
        present: _ctx.forceMount || visible.value
      }, {
        default: withCtx266(() => [
          createVNode47(_sfc_main272, mergeProps118(_ctx.$attrs, {
            ref: unref273(forwardRef),
            "data-state": visible.value ? "visible" : "hidden"
          }), {
            default: withCtx266(() => [
              renderSlot270(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["data-state"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarHover.js
import { defineComponent as defineComponent279, ref as ref82, onMounted as onMounted37, onUnmounted as onUnmounted16, createBlock as createBlock265, openBlock as openBlock271, unref as unref274, withCtx as withCtx267, createVNode as createVNode48, mergeProps as mergeProps119, renderSlot as renderSlot271 } from "vue";
var _sfc_main274 = defineComponent279({
  ...{
    inheritAttrs: false
  },
  __name: "ScrollAreaScrollbarHover",
  props: {
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const { forwardRef } = useForwardExpose();
    let timeout;
    const visible = ref82(false);
    function handlePointerEnter() {
      window.clearTimeout(timeout);
      visible.value = true;
    }
    function handlePointerLeave() {
      timeout = window.setTimeout(() => {
        visible.value = false;
      }, rootContext.scrollHideDelay.value);
    }
    onMounted37(() => {
      const scrollArea = rootContext.scrollArea.value;
      if (scrollArea) {
        scrollArea.addEventListener("pointerenter", handlePointerEnter);
        scrollArea.addEventListener("pointerleave", handlePointerLeave);
      }
    });
    onUnmounted16(() => {
      const scrollArea = rootContext.scrollArea.value;
      if (scrollArea) {
        window.clearTimeout(timeout);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      }
    });
    return (_ctx, _cache) => {
      return openBlock271(), createBlock265(unref274(Presence), {
        present: _ctx.forceMount || visible.value
      }, {
        default: withCtx267(() => [
          createVNode48(_sfc_main273, mergeProps119(_ctx.$attrs, {
            ref: unref274(forwardRef),
            "data-state": visible.value ? "visible" : "hidden"
          }), {
            default: withCtx267(() => [
              renderSlot271(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["data-state"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarScroll.js
import { defineComponent as defineComponent280, watchEffect as watchEffect16, createBlock as createBlock266, openBlock as openBlock272, unref as unref275, withCtx as withCtx268, createVNode as createVNode49, mergeProps as mergeProps120, renderSlot as renderSlot272 } from "vue";
var _sfc_main275 = defineComponent280({
  __name: "ScrollAreaScrollbarScroll",
  props: {
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const scrollbarContext = injectScrollAreaScrollbarContext();
    const { forwardRef } = useForwardExpose();
    const { state, dispatch } = useStateMachine("hidden", {
      hidden: {
        SCROLL: "scrolling"
      },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    });
    watchEffect16((onCleanup) => {
      if (state.value === "idle") {
        const timeId = window.setTimeout(
          () => dispatch("HIDE"),
          rootContext.scrollHideDelay.value
        );
        onCleanup(() => {
          window.clearTimeout(timeId);
        });
      }
    });
    const debounceScrollEnd = useDebounceFn(() => dispatch("SCROLL_END"), 100);
    watchEffect16((onCleanup) => {
      const viewport = rootContext.viewport.value;
      const scrollDirection = scrollbarContext.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (viewport) {
        let prevScrollPos = viewport[scrollDirection];
        const handleScroll = () => {
          const scrollPos = viewport[scrollDirection];
          const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
          if (hasScrollInDirectionChanged) {
            dispatch("SCROLL");
            debounceScrollEnd();
          }
          prevScrollPos = scrollPos;
        };
        viewport.addEventListener("scroll", handleScroll);
        onCleanup(() => {
          viewport.removeEventListener("scroll", handleScroll);
        });
      }
    });
    return (_ctx, _cache) => {
      return openBlock272(), createBlock266(unref275(Presence), {
        present: _ctx.forceMount || unref275(state) !== "hidden"
      }, {
        default: withCtx268(() => [
          createVNode49(_sfc_main272, mergeProps120(_ctx.$attrs, { ref: unref275(forwardRef) }), {
            default: withCtx268(() => [
              renderSlot272(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbar.js
var [injectScrollAreaScrollbarContext, provideScrollAreaScrollbarContext] = createContext("ScrollAreaScrollbar");
var _sfc_main276 = defineComponent281({
  ...{
    inheritAttrs: false
  },
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const rootContext = injectScrollAreaRootContext();
    const isHorizontal = computed90(() => props2.orientation === "horizontal");
    watch35(
      isHorizontal,
      () => {
        if (isHorizontal.value)
          rootContext.onScrollbarXEnabledChange(true);
        else rootContext.onScrollbarYEnabledChange(true);
      },
      { immediate: true }
    );
    onUnmounted17(() => {
      rootContext.onScrollbarXEnabledChange(false);
      rootContext.onScrollbarYEnabledChange(false);
    });
    const { orientation, forceMount, asChild, as } = toRefs37(props2);
    provideScrollAreaScrollbarContext({
      orientation,
      forceMount,
      isHorizontal,
      as,
      asChild
    });
    return (_ctx, _cache) => {
      return unref276(rootContext).type.value === "hover" ? (openBlock273(), createBlock267(_sfc_main274, mergeProps121({ key: 0 }, _ctx.$attrs, {
        ref: unref276(forwardRef),
        "force-mount": unref276(forceMount)
      }), {
        default: withCtx269(() => [
          renderSlot273(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["force-mount"])) : unref276(rootContext).type.value === "scroll" ? (openBlock273(), createBlock267(_sfc_main275, mergeProps121({ key: 1 }, _ctx.$attrs, {
        ref: unref276(forwardRef),
        "force-mount": unref276(forceMount)
      }), {
        default: withCtx269(() => [
          renderSlot273(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["force-mount"])) : unref276(rootContext).type.value === "auto" ? (openBlock273(), createBlock267(_sfc_main273, mergeProps121({ key: 2 }, _ctx.$attrs, {
        ref: unref276(forwardRef),
        "force-mount": unref276(forceMount)
      }), {
        default: withCtx269(() => [
          renderSlot273(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["force-mount"])) : unref276(rootContext).type.value === "always" ? (openBlock273(), createBlock267(_sfc_main272, mergeProps121({ key: 3 }, _ctx.$attrs, {
        ref: unref276(forwardRef),
        "data-state": "visible"
      }), {
        default: withCtx269(() => [
          renderSlot273(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode20("", true);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaThumb.js
import { defineComponent as defineComponent282, ref as ref83, computed as computed91, onUnmounted as onUnmounted18, createBlock as createBlock268, openBlock as openBlock274, unref as unref277, withCtx as withCtx270, renderSlot as renderSlot274 } from "vue";
var _sfc_main277 = defineComponent282({
  __name: "ScrollAreaThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectScrollAreaRootContext();
    const scrollbarContextVisible = injectScrollAreaScrollbarVisibleContext();
    function handlePointerDown2(event) {
      const thumb = event.target;
      const thumbRect = thumb.getBoundingClientRect();
      const x = event.clientX - thumbRect.left;
      const y = event.clientY - thumbRect.top;
      scrollbarContextVisible.handleThumbDown(event, { x, y });
    }
    function handlePointerUp2(event) {
      scrollbarContextVisible.handleThumbUp(event);
    }
    const { forwardRef, currentElement: thumbElement } = useForwardExpose();
    const removeUnlinkedScrollListenerRef = ref83();
    const viewport = computed91(() => rootContext.viewport.value);
    function handleScroll() {
      if (!removeUnlinkedScrollListenerRef.value) {
        const listener = addUnlinkedScrollListener(
          viewport.value,
          scrollbarContextVisible.onThumbPositionChange
        );
        removeUnlinkedScrollListenerRef.value = listener;
        scrollbarContextVisible.onThumbPositionChange();
      }
    }
    const sizes = computed91(() => scrollbarContextVisible.sizes.value);
    watchOnce(sizes, () => {
      scrollbarContextVisible.onThumbChange(thumbElement.value);
      if (viewport.value) {
        scrollbarContextVisible.onThumbPositionChange();
        viewport.value.addEventListener("scroll", handleScroll);
      }
    });
    onUnmounted18(() => {
      viewport.value.removeEventListener("scroll", handleScroll);
      rootContext.viewport.value?.removeEventListener("scroll", handleScroll);
    });
    return (_ctx, _cache) => {
      return openBlock274(), createBlock268(unref277(Primitive), {
        ref: unref277(forwardRef),
        "data-state": unref277(scrollbarContextVisible).hasThumb ? "visible" : "hidden",
        style: {
          width: "var(--reka-scroll-area-thumb-width)",
          height: "var(--reka-scroll-area-thumb-height)"
        },
        "as-child": props2.asChild,
        as: _ctx.as,
        onPointerdown: handlePointerDown2,
        onPointerup: handlePointerUp2
      }, {
        default: withCtx270(() => [
          renderSlot274(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["data-state", "as-child", "as"]);
    };
  }
});

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaViewport.js
import { defineComponent as defineComponent283, toRefs as toRefs38, ref as ref84, onMounted as onMounted38, createElementBlock as createElementBlock10, openBlock as openBlock275, Fragment as Fragment8, createElementVNode as createElementVNode3, createVNode as createVNode50, mergeProps as mergeProps122, unref as unref278, normalizeStyle as normalizeStyle9, withCtx as withCtx271, renderSlot as renderSlot275, createTextVNode as createTextVNode24 } from "vue";
var _sfc_main278 = defineComponent283({
  ...{
    inheritAttrs: false
  },
  __name: "ScrollAreaViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props, { expose: __expose }) {
    const props2 = __props;
    const { nonce: propNonce } = toRefs38(props2);
    const nonce = useNonce(propNonce);
    const rootContext = injectScrollAreaRootContext();
    const viewportElement = ref84();
    onMounted38(() => {
      rootContext.onViewportChange(viewportElement.value);
      rootContext.onContentChange(contentElement.value);
    });
    __expose({
      viewportElement
    });
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock275(), createElementBlock10(Fragment8, null, [
        createElementVNode3("div", mergeProps122({
          ref_key: "viewportElement",
          ref: viewportElement,
          "data-reka-scroll-area-viewport": "",
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: unref278(rootContext).scrollbarXEnabled.value ? "scroll" : "hidden",
            overflowY: unref278(rootContext).scrollbarYEnabled.value ? "scroll" : "hidden"
          }
        }, _ctx.$attrs, { tabindex: 0 }), [
          createVNode50(unref278(Primitive), {
            ref: unref278(forwardRef),
            style: normalizeStyle9({
              /**
               * When horizontal scrollbar is visible: this element should be at least
               * as wide as its children for size calculations to work correctly.
               *
               * When horizontal scrollbar is NOT visible: this element's width should
               * be constrained by the parent container to enable `text-overflow: ellipsis`
               */
              minWidth: unref278(rootContext).scrollbarXEnabled.value ? "fit-content" : void 0
            }),
            "as-child": props2.asChild,
            as: _ctx.as
          }, {
            default: withCtx271(() => [
              renderSlot275(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["style", "as-child", "as"])
        ], 16),
        createVNode50(unref278(Primitive), {
          as: "style",
          nonce: unref278(nonce)
        }, {
          default: withCtx271(() => _cache[0] || (_cache[0] = [
            createTextVNode24(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-reka-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")
          ])),
          _: 1
        }, 8, ["nonce"])
      ], 64);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectArrow.js
import { defineComponent as defineComponent289, createBlock as createBlock273, createCommentVNode as createCommentVNode22, unref as unref284, openBlock as openBlock281, normalizeProps as normalizeProps97, mergeProps as mergeProps128, withCtx as withCtx277, renderSlot as renderSlot281 } from "vue";

// node_modules/reka-ui/dist/Select/SelectContentImpl.js
import { defineComponent as defineComponent288, ref as ref88, watch as watch37, watchEffect as watchEffect17, computed as computed93, createBlock as createBlock272, openBlock as openBlock280, unref as unref283, withCtx as withCtx276, createVNode as createVNode52, withModifiers as withModifiers17, resolveDynamicComponent as resolveDynamicComponent6, mergeProps as mergeProps127, renderSlot as renderSlot280 } from "vue";

// node_modules/reka-ui/dist/Select/SelectItemAlignedPosition.js
import { defineComponent as defineComponent286, ref as ref87, onMounted as onMounted39, nextTick as nextTick27, createElementBlock as createElementBlock12, openBlock as openBlock278, normalizeStyle as normalizeStyle10, createVNode as createVNode51, unref as unref281, mergeProps as mergeProps125, withCtx as withCtx274, renderSlot as renderSlot278 } from "vue";

// node_modules/reka-ui/dist/Select/utils.js
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS2 = [" ", "Enter"];
var CONTENT_MARGIN = 10;
function valueComparator2(value, currentValue, comparator) {
  if (value === void 0)
    return false;
  else if (Array.isArray(value))
    return value.some((val) => compare2(val, currentValue, comparator));
  else
    return compare2(value, currentValue, comparator);
}
function compare2(value, currentValue, comparator) {
  if (value === void 0 || currentValue === void 0)
    return false;
  if (typeof value === "string")
    return value === currentValue;
  if (typeof comparator === "function")
    return comparator(value, currentValue);
  if (typeof comparator === "string")
    return value?.[comparator] === currentValue?.[comparator];
  return isEqual(value, currentValue);
}
function shouldShowPlaceholder(value) {
  return value === void 0 || value === null || value === "" || Array.isArray(value) && value.length === 0;
}

// node_modules/reka-ui/dist/Select/SelectRoot.js
import { defineComponent as defineComponent285, toRefs as toRefs39, ref as ref86, computed as computed92, createBlock as createBlock270, openBlock as openBlock277, unref as unref280, withCtx as withCtx273, renderSlot as renderSlot277, createCommentVNode as createCommentVNode21, createElementBlock as createElementBlock11, Fragment as Fragment9, renderList as renderList3, mergeProps as mergeProps124 } from "vue";

// node_modules/reka-ui/dist/Select/BubbleSelect.js
import { defineComponent as defineComponent284, ref as ref85, watch as watch36, createBlock as createBlock269, openBlock as openBlock276, unref as unref279, withCtx as withCtx272, createElementVNode as createElementVNode4, mergeProps as mergeProps123, renderSlot as renderSlot276 } from "vue";
var _sfc_main279 = defineComponent284({
  __name: "BubbleSelect",
  props: {
    autocomplete: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    form: {},
    multiple: { type: Boolean },
    name: {},
    required: { type: Boolean },
    size: {},
    value: {}
  },
  setup(__props) {
    const props2 = __props;
    const selectElement = ref85();
    watch36(() => props2.value, (cur, prev) => {
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (cur !== prev && setValue && selectElement.value) {
        const event = new Event("change", { bubbles: true });
        setValue.call(selectElement.value, cur);
        selectElement.value.dispatchEvent(event);
      }
    });
    return (_ctx, _cache) => {
      return openBlock276(), createBlock269(unref279(_sfc_main), { "as-child": "" }, {
        default: withCtx272(() => [
          createElementVNode4("select", mergeProps123({
            ref_key: "selectElement",
            ref: selectElement
          }, props2), [
            renderSlot276(_ctx.$slots, "default")
          ], 16)
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectRoot.js
var _hoisted_15 = {
  key: 0,
  value: ""
};
var [injectSelectRootContext, provideSelectRootContext] = createContext("SelectRoot");
var _sfc_main280 = defineComponent285({
  ...{
    inheritAttrs: false
  },
  __name: "SelectRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    defaultValue: {},
    modelValue: { default: void 0 },
    by: {},
    dir: {},
    multiple: { type: Boolean },
    autocomplete: {},
    disabled: { type: Boolean },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { required, disabled, multiple, dir: propDir } = toRefs39(props2);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? (multiple.value ? [] : void 0),
      passive: props2.modelValue === void 0,
      deep: true
    });
    const open = useVModel(props2, "open", emits, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const triggerElement = ref86();
    const valueElement = ref86();
    const triggerPointerDownPosRef = ref86({
      x: 0,
      y: 0
    });
    const isEmptyModelValue = computed92(() => {
      if (multiple.value && Array.isArray(modelValue.value))
        return modelValue.value?.length === 0;
      else
        return isNullish(modelValue.value);
    });
    useCollection({ isProvider: true });
    const dir = useDirection(propDir);
    const isFormControl = useFormControl(triggerElement);
    const optionsSet = ref86(/* @__PURE__ */ new Set());
    const nativeSelectKey = computed92(() => {
      return Array.from(optionsSet.value).map((option) => option.value).join(";");
    });
    function handleValueChange(value) {
      if (multiple.value) {
        const array = Array.isArray(modelValue.value) ? [...modelValue.value] : [];
        const index = array.findIndex((i) => compare2(i, value, props2.by));
        index === -1 ? array.push(value) : array.splice(index, 1);
        modelValue.value = [...array];
      } else {
        modelValue.value = value;
      }
    }
    provideSelectRootContext({
      triggerElement,
      onTriggerChange: (node) => {
        triggerElement.value = node;
      },
      valueElement,
      onValueElementChange: (node) => {
        valueElement.value = node;
      },
      contentId: "",
      modelValue,
      // @ts-expect-error Missing infer for AcceptableValue
      onValueChange: handleValueChange,
      by: props2.by,
      open,
      multiple,
      required,
      onOpenChange: (value) => {
        open.value = value;
      },
      dir,
      triggerPointerDownPosRef,
      disabled,
      isEmptyModelValue,
      optionsSet,
      onOptionAdd: (option) => optionsSet.value.add(option),
      onOptionRemove: (option) => optionsSet.value.delete(option)
    });
    return (_ctx, _cache) => {
      return openBlock277(), createBlock270(unref280(_sfc_main57), null, {
        default: withCtx273(() => [
          renderSlot277(_ctx.$slots, "default", {
            modelValue: unref280(modelValue),
            open: unref280(open)
          }),
          unref280(isFormControl) ? (openBlock277(), createBlock270(_sfc_main279, {
            key: nativeSelectKey.value,
            "aria-hidden": "true",
            tabindex: "-1",
            multiple: unref280(multiple),
            required: unref280(required),
            name: _ctx.name,
            autocomplete: _ctx.autocomplete,
            disabled: unref280(disabled),
            value: unref280(modelValue)
          }, {
            default: withCtx273(() => [
              unref280(isNullish)(unref280(modelValue)) ? (openBlock277(), createElementBlock11("option", _hoisted_15)) : createCommentVNode21("", true),
              (openBlock277(true), createElementBlock11(Fragment9, null, renderList3(Array.from(optionsSet.value), (option) => {
                return openBlock277(), createElementBlock11("option", mergeProps124({
                  key: option.value ?? "",
                  ref_for: true
                }, option), null, 16);
              }), 128))
            ]),
            _: 1
          }, 8, ["multiple", "required", "name", "autocomplete", "disabled", "value"])) : createCommentVNode21("", true)
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectItemAlignedPosition.js
var [injectSelectItemAlignedPositionContext, provideSelectItemAlignedPositionContext] = createContext("SelectItemAlignedPosition");
var _sfc_main281 = defineComponent286({
  ...{
    inheritAttrs: false
  },
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["placed"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { getItems } = useCollection();
    const rootContext = injectSelectRootContext();
    const contentContext = injectSelectContentContext();
    const shouldExpandOnScrollRef = ref87(false);
    const shouldRepositionRef = ref87(true);
    const contentWrapperElement = ref87();
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
    function position() {
      if (rootContext.triggerElement.value && rootContext.valueElement.value && contentWrapperElement.value && contentElement.value && viewport?.value && selectedItem?.value && selectedItemText?.value) {
        const triggerRect = rootContext.triggerElement.value.getBoundingClientRect();
        const contentRect = contentElement.value.getBoundingClientRect();
        const valueNodeRect = rootContext.valueElement.value.getBoundingClientRect();
        const itemTextRect = selectedItemText.value.getBoundingClientRect();
        if (rootContext.dir.value !== "rtl") {
          const itemTextOffset = itemTextRect.left - contentRect.left;
          const left = valueNodeRect.left - itemTextOffset;
          const leftDelta = triggerRect.left - left;
          const minContentWidth = triggerRect.width + leftDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const rightEdge = window.innerWidth - CONTENT_MARGIN;
          const clampedLeft = clamp3(left, CONTENT_MARGIN, Math.max(CONTENT_MARGIN, rightEdge - contentWidth));
          contentWrapperElement.value.style.minWidth = `${minContentWidth}px`;
          contentWrapperElement.value.style.left = `${clampedLeft}px`;
        } else {
          const itemTextOffset = contentRect.right - itemTextRect.right;
          const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
          const rightDelta = window.innerWidth - triggerRect.right - right;
          const minContentWidth = triggerRect.width + rightDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const leftEdge = window.innerWidth - CONTENT_MARGIN;
          const clampedRight = clamp3(
            right,
            CONTENT_MARGIN,
            Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
          );
          contentWrapperElement.value.style.minWidth = `${minContentWidth}px`;
          contentWrapperElement.value.style.right = `${clampedRight}px`;
        }
        const items = getItems().map((i) => i.ref);
        const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
        const itemsHeight = viewport.value.scrollHeight;
        const contentStyles = window.getComputedStyle(contentElement.value);
        const contentBorderTopWidth = Number.parseInt(
          contentStyles.borderTopWidth,
          10
        );
        const contentPaddingTop = Number.parseInt(contentStyles.paddingTop, 10);
        const contentBorderBottomWidth = Number.parseInt(
          contentStyles.borderBottomWidth,
          10
        );
        const contentPaddingBottom = Number.parseInt(
          contentStyles.paddingBottom,
          10
        );
        const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
        const minContentHeight = Math.min(
          selectedItem.value.offsetHeight * 5,
          fullContentHeight
        );
        const viewportStyles = window.getComputedStyle(viewport.value);
        const viewportPaddingTop = Number.parseInt(viewportStyles.paddingTop, 10);
        const viewportPaddingBottom = Number.parseInt(
          viewportStyles.paddingBottom,
          10
        );
        const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
        const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
        const selectedItemHalfHeight = selectedItem.value.offsetHeight / 2;
        const itemOffsetMiddle = selectedItem.value.offsetTop + selectedItemHalfHeight;
        const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
        const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
        const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
        if (willAlignWithoutTopOverflow) {
          const isLastItem = selectedItem.value === items[items.length - 1];
          contentWrapperElement.value.style.bottom = `${0}px`;
          const viewportOffsetBottom = contentElement.value.clientHeight - viewport.value.offsetTop - viewport.value.offsetHeight;
          const clampedTriggerMiddleToBottomEdge = Math.max(
            triggerMiddleToBottomEdge,
            selectedItemHalfHeight + (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
          );
          const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
          contentWrapperElement.value.style.height = `${height}px`;
        } else {
          const isFirstItem = selectedItem.value === items[0];
          contentWrapperElement.value.style.top = `${0}px`;
          const clampedTopEdgeToTriggerMiddle = Math.max(
            topEdgeToTriggerMiddle,
            contentBorderTopWidth + viewport.value.offsetTop + (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
          );
          const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
          contentWrapperElement.value.style.height = `${height}px`;
          viewport.value.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.value.offsetTop;
        }
        contentWrapperElement.value.style.margin = `${CONTENT_MARGIN}px 0`;
        contentWrapperElement.value.style.minHeight = `${minContentHeight}px`;
        contentWrapperElement.value.style.maxHeight = `${availableHeight}px`;
        emits("placed");
        requestAnimationFrame(() => shouldExpandOnScrollRef.value = true);
      }
    }
    const contentZIndex = ref87("");
    onMounted39(async () => {
      await nextTick27();
      position();
      if (contentElement.value)
        contentZIndex.value = window.getComputedStyle(contentElement.value).zIndex;
    });
    function handleScrollButtonChange(node) {
      if (node && shouldRepositionRef.value === true) {
        position();
        focusSelectedItem?.();
        shouldRepositionRef.value = false;
      }
    }
    useResizeObserver(rootContext.triggerElement, () => {
      position();
    });
    provideSelectItemAlignedPositionContext({
      contentWrapper: contentWrapperElement,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange
    });
    return (_ctx, _cache) => {
      return openBlock278(), createElementBlock12("div", {
        ref_key: "contentWrapperElement",
        ref: contentWrapperElement,
        style: normalizeStyle10({
          display: "flex",
          flexDirection: "column",
          position: "fixed",
          zIndex: contentZIndex.value
        })
      }, [
        createVNode51(unref281(Primitive), mergeProps125({
          ref: unref281(forwardRef),
          style: {
            // When we get the height of the content, it includes borders. If we were to set
            // the height without having `boxSizing: 'border-box'` it would be too big.
            boxSizing: "border-box",
            // We need to ensure the content doesn't get taller than the wrapper
            maxHeight: "100%"
          }
        }, { ..._ctx.$attrs, ...props2 }), {
          default: withCtx274(() => [
            renderSlot278(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16)
      ], 4);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectPopperPosition.js
import { defineComponent as defineComponent287, createBlock as createBlock271, openBlock as openBlock279, unref as unref282, mergeProps as mergeProps126, withCtx as withCtx275, renderSlot as renderSlot279 } from "vue";
var _sfc_main282 = defineComponent287({
  __name: "SelectPopperPosition",
  props: {
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: { default: CONTENT_MARGIN },
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const forwarded = useForwardProps(props2);
    return (_ctx, _cache) => {
      return openBlock279(), createBlock271(unref282(_sfc_main61), mergeProps126(unref282(forwarded), { style: {
        // Ensure border-box for floating-ui calculations
        "boxSizing": "border-box",
        "--reka-select-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-select-content-available-width": "var(--reka-popper-available-width)",
        "--reka-select-content-available-height": "var(--reka-popper-available-height)",
        "--reka-select-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-select-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: withCtx275(() => [
          renderSlot279(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectContentImpl.js
var SelectContentDefaultContextValue = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
};
var [injectSelectContentContext, provideSelectContentContext] = createContext("SelectContent");
var _sfc_main283 = defineComponent288({
  __name: "SelectContentImpl",
  props: {
    position: { default: "item-aligned" },
    bodyLock: { type: Boolean, default: true },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectSelectRootContext();
    useFocusGuards();
    useBodyScrollLock(props2.bodyLock);
    const { CollectionSlot, getItems } = useCollection();
    const content = ref88();
    useHideOthers(content);
    const { search, handleTypeaheadSearch } = useTypeahead();
    const viewport = ref88();
    const selectedItem = ref88();
    const selectedItemText = ref88();
    const isPositioned = ref88(false);
    const firstValidItemFoundRef = ref88(false);
    const firstSelectedItemInArrayFoundRef = ref88(false);
    function focusSelectedItem() {
      if (selectedItem.value && content.value)
        focusFirst([selectedItem.value, content.value]);
    }
    watch37(isPositioned, () => {
      focusSelectedItem();
    });
    const { onOpenChange, triggerPointerDownPosRef } = rootContext;
    watchEffect17((cleanupFn) => {
      if (!content.value)
        return;
      let pointerMoveDelta = { x: 0, y: 0 };
      const handlePointerMove2 = (event) => {
        pointerMoveDelta = {
          x: Math.abs(
            Math.round(event.pageX) - (triggerPointerDownPosRef.value?.x ?? 0)
          ),
          y: Math.abs(
            Math.round(event.pageY) - (triggerPointerDownPosRef.value?.y ?? 0)
          )
        };
      };
      const handlePointerUp2 = (event) => {
        if (event.pointerType === "touch")
          return;
        if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
          event.preventDefault();
        } else {
          if (!content.value?.contains(event.target))
            onOpenChange(false);
        }
        document.removeEventListener("pointermove", handlePointerMove2);
        triggerPointerDownPosRef.value = null;
      };
      if (triggerPointerDownPosRef.value !== null) {
        document.addEventListener("pointermove", handlePointerMove2);
        document.addEventListener("pointerup", handlePointerUp2, {
          capture: true,
          once: true
        });
      }
      cleanupFn(() => {
        document.removeEventListener("pointermove", handlePointerMove2);
        document.removeEventListener("pointerup", handlePointerUp2, {
          capture: true
        });
      });
    });
    function handleKeyDown(event) {
      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
      if (event.key === "Tab")
        event.preventDefault();
      if (!isModifierKey && event.key.length === 1)
        handleTypeaheadSearch(event.key, getItems());
      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
        const collectionItems = getItems().map((i) => i.ref);
        let candidateNodes = [...collectionItems];
        if (["ArrowUp", "End"].includes(event.key))
          candidateNodes = candidateNodes.slice().reverse();
        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
          const currentElement = event.target;
          const currentIndex = candidateNodes.indexOf(currentElement);
          candidateNodes = candidateNodes.slice(currentIndex + 1);
        }
        setTimeout(() => focusFirst(candidateNodes));
        event.preventDefault();
      }
    }
    const pickedProps = computed93(() => {
      if (props2.position === "popper")
        return props2;
      else return {};
    });
    const forwardedProps = useForwardProps(pickedProps.value);
    provideSelectContentContext({
      content,
      viewport,
      onViewportChange: (node) => {
        viewport.value = node;
      },
      itemRefCallback: (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.value && !disabled;
        const isSelectedItem = valueComparator2(rootContext.modelValue.value, value, rootContext.by);
        if (rootContext.multiple.value) {
          if (firstSelectedItemInArrayFoundRef.value) {
            return;
          }
          if (isSelectedItem || isFirstValidItem) {
            selectedItem.value = node;
            if (isSelectedItem) {
              firstSelectedItemInArrayFoundRef.value = true;
            }
          }
        } else {
          if (isSelectedItem || isFirstValidItem) {
            selectedItem.value = node;
          }
        }
        if (isFirstValidItem) {
          firstValidItemFoundRef.value = true;
        }
      },
      selectedItem,
      selectedItemText,
      onItemLeave: () => {
        content.value?.focus();
      },
      itemTextRefCallback: (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.value && !disabled;
        const isSelectedItem = valueComparator2(rootContext.modelValue.value, value, rootContext.by);
        if (isSelectedItem || isFirstValidItem)
          selectedItemText.value = node;
      },
      focusSelectedItem,
      position: props2.position,
      isPositioned,
      searchRef: search
    });
    return (_ctx, _cache) => {
      return openBlock280(), createBlock272(unref283(CollectionSlot), null, {
        default: withCtx276(() => [
          createVNode52(unref283(_sfc_main15), {
            "as-child": "",
            onMountAutoFocus: _cache[6] || (_cache[6] = withModifiers17(() => {
            }, ["prevent"])),
            onUnmountAutoFocus: _cache[7] || (_cache[7] = (event) => {
              emits("closeAutoFocus", event);
              if (event.defaultPrevented) return;
              unref283(rootContext).triggerElement.value?.focus({ preventScroll: true });
              event.preventDefault();
            })
          }, {
            default: withCtx276(() => [
              createVNode52(unref283(_sfc_main14), {
                "as-child": "",
                "disable-outside-pointer-events": "",
                onFocusOutside: _cache[2] || (_cache[2] = withModifiers17(() => {
                }, ["prevent"])),
                onDismiss: _cache[3] || (_cache[3] = ($event) => unref283(rootContext).onOpenChange(false)),
                onEscapeKeyDown: _cache[4] || (_cache[4] = ($event) => emits("escapeKeyDown", $event)),
                onPointerDownOutside: _cache[5] || (_cache[5] = ($event) => emits("pointerDownOutside", $event))
              }, {
                default: withCtx276(() => [
                  (openBlock280(), createBlock272(resolveDynamicComponent6(
                    _ctx.position === "popper" ? _sfc_main282 : _sfc_main281
                  ), mergeProps127({ ..._ctx.$attrs, ...unref283(forwardedProps) }, {
                    id: unref283(rootContext).contentId,
                    ref: (vnode) => {
                      content.value = unref283(unrefElement)(vnode);
                      return void 0;
                    },
                    role: "listbox",
                    "data-state": unref283(rootContext).open.value ? "open" : "closed",
                    dir: unref283(rootContext).dir.value,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none"
                    },
                    onContextmenu: _cache[0] || (_cache[0] = withModifiers17(() => {
                    }, ["prevent"])),
                    onPlaced: _cache[1] || (_cache[1] = ($event) => isPositioned.value = true),
                    onKeydown: handleKeyDown
                  }), {
                    default: withCtx276(() => [
                      renderSlot280(_ctx.$slots, "default")
                    ]),
                    _: 3
                  }, 16, ["id", "data-state", "dir", "onKeydown"]))
                ]),
                _: 3
              })
            ]),
            _: 3
          })
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectArrow.js
var _sfc_main284 = defineComponent289({
  __name: "SelectArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectSelectRootContext();
    const contentContext = injectSelectContentContext(SelectContentDefaultContextValue);
    return (_ctx, _cache) => {
      return unref284(rootContext).open.value && unref284(contentContext).position === "popper" ? (openBlock281(), createBlock273(unref284(_sfc_main62), normalizeProps97(mergeProps128({ key: 0 }, props2)), {
        default: withCtx277(() => [
          renderSlot281(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode22("", true);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectContent.js
import { defineComponent as defineComponent291, ref as ref89, onMounted as onMounted40, computed as computed94, createBlock as createBlock274, createElementBlock as createElementBlock13, createCommentVNode as createCommentVNode23, openBlock as openBlock282, unref as unref285, withCtx as withCtx278, createVNode as createVNode53, normalizeProps as normalizeProps98, guardReactiveProps as guardReactiveProps94, renderSlot as renderSlot283, Teleport as Teleport4 } from "vue";

// node_modules/reka-ui/dist/Select/SelectProvider.js
import { defineComponent as defineComponent290, renderSlot as renderSlot282 } from "vue";
var _sfc_main285 = defineComponent290({
  ...{
    inheritAttrs: false
  },
  __name: "SelectProvider",
  props: {
    context: {}
  },
  setup(__props) {
    const props2 = __props;
    provideSelectRootContext(props2.context);
    provideSelectContentContext(SelectContentDefaultContextValue);
    return (_ctx, _cache) => {
      return renderSlot282(_ctx.$slots, "default");
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectContent.js
var _hoisted_16 = { key: 1 };
var _sfc_main286 = defineComponent291({
  ...{
    inheritAttrs: false
  },
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const rootContext = injectSelectRootContext();
    const fragment = ref89();
    onMounted40(() => {
      fragment.value = new DocumentFragment();
    });
    const presenceRef = ref89();
    const renderPresence = computed94(() => props2.forceMount || rootContext.open.value);
    return (_ctx, _cache) => {
      return renderPresence.value ? (openBlock282(), createBlock274(unref285(Presence), {
        key: 0,
        ref_key: "presenceRef",
        ref: presenceRef,
        present: true
      }, {
        default: withCtx278(() => [
          createVNode53(_sfc_main283, normalizeProps98(guardReactiveProps94({ ...unref285(forwarded), ..._ctx.$attrs })), {
            default: withCtx278(() => [
              renderSlot283(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 512)) : !presenceRef.value?.present && fragment.value ? (openBlock282(), createElementBlock13("div", _hoisted_16, [
        (openBlock282(), createBlock274(Teleport4, { to: fragment.value }, [
          createVNode53(_sfc_main285, { context: unref285(rootContext) }, {
            default: withCtx278(() => [
              renderSlot283(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["context"])
        ], 8, ["to"]))
      ])) : createCommentVNode23("", true);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectGroup.js
import { defineComponent as defineComponent292, createBlock as createBlock275, openBlock as openBlock283, unref as unref286, mergeProps as mergeProps129, withCtx as withCtx279, renderSlot as renderSlot284 } from "vue";
var [injectSelectGroupContext, provideSelectGroupContext] = createContext("SelectGroup");
var _sfc_main287 = defineComponent292({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const id = useId2(void 0, "reka-select-group");
    provideSelectGroupContext({ id });
    return (_ctx, _cache) => {
      return openBlock283(), createBlock275(unref286(Primitive), mergeProps129({ role: "group" }, props2, { "aria-labelledby": unref286(id) }), {
        default: withCtx279(() => [
          renderSlot284(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-labelledby"]);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectIcon.js
import { defineComponent as defineComponent293, createBlock as createBlock276, openBlock as openBlock284, unref as unref287, withCtx as withCtx280, renderSlot as renderSlot285, createTextVNode as createTextVNode25 } from "vue";
var _sfc_main288 = defineComponent293({
  __name: "SelectIcon",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock284(), createBlock276(unref287(Primitive), {
        "aria-hidden": "true",
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, {
        default: withCtx280(() => [
          renderSlot285(_ctx.$slots, "default", {}, () => [
            _cache[0] || (_cache[0] = createTextVNode25("▼"))
          ])
        ]),
        _: 3
      }, 8, ["as", "as-child"]);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectItem.js
import { defineComponent as defineComponent294, toRefs as toRefs40, computed as computed95, ref as ref90, onMounted as onMounted41, createBlock as createBlock277, openBlock as openBlock285, unref as unref288, withCtx as withCtx281, createVNode as createVNode54, withModifiers as withModifiers18, renderSlot as renderSlot286, nextTick as nextTick28 } from "vue";
var [injectSelectItemContext, provideSelectItemContext] = createContext("SelectItem");
var _sfc_main289 = defineComponent294({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled } = toRefs40(props2);
    const rootContext = injectSelectRootContext();
    const contentContext = injectSelectContentContext();
    const { forwardRef, currentElement } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const isSelected = computed95(() => valueComparator2(rootContext.modelValue?.value, props2.value, rootContext.by));
    const isFocused = ref90(false);
    const textValue = ref90(props2.textValue ?? "");
    const textId = useId2(void 0, "reka-select-item-text");
    const SELECT_SELECT = "select.select";
    async function handleSelectCustomEvent(ev) {
      if (ev.defaultPrevented)
        return;
      const eventDetail = { originalEvent: ev, value: props2.value };
      handleAndDispatchCustomEvent(SELECT_SELECT, handleSelect2, eventDetail);
    }
    async function handleSelect2(ev) {
      await nextTick28();
      emits("select", ev);
      if (ev.defaultPrevented)
        return;
      if (!disabled.value) {
        rootContext.onValueChange(props2.value);
        if (!rootContext.multiple.value)
          rootContext.onOpenChange(false);
      }
    }
    async function handlePointerMove2(event) {
      await nextTick28();
      if (event.defaultPrevented)
        return;
      if (disabled.value) {
        contentContext.onItemLeave?.();
      } else {
        event.currentTarget?.focus({ preventScroll: true });
      }
    }
    async function handlePointerLeave(event) {
      await nextTick28();
      if (event.defaultPrevented)
        return;
      if (event.currentTarget === getActiveElement())
        contentContext.onItemLeave?.();
    }
    async function handleKeyDown(event) {
      await nextTick28();
      if (event.defaultPrevented)
        return;
      const isTypingAhead = contentContext.searchRef?.value !== "";
      if (isTypingAhead && event.key === " ")
        return;
      if (SELECTION_KEYS2.includes(event.key))
        handleSelectCustomEvent(event);
      if (event.key === " ")
        event.preventDefault();
    }
    if (props2.value === "") {
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    onMounted41(() => {
      if (!currentElement.value)
        return;
      contentContext.itemRefCallback(
        currentElement.value,
        props2.value,
        props2.disabled
      );
    });
    provideSelectItemContext({
      value: props2.value,
      disabled,
      textId,
      isSelected,
      onItemTextChange: (node) => {
        textValue.value = ((textValue.value || node?.textContent) ?? "").trim();
      }
    });
    return (_ctx, _cache) => {
      return openBlock285(), createBlock277(unref288(CollectionItem), {
        value: { textValue: textValue.value }
      }, {
        default: withCtx281(() => [
          createVNode54(unref288(Primitive), {
            ref: unref288(forwardRef),
            role: "option",
            "aria-labelledby": unref288(textId),
            "data-highlighted": isFocused.value ? "" : void 0,
            "aria-selected": isSelected.value,
            "data-state": isSelected.value ? "checked" : "unchecked",
            "aria-disabled": unref288(disabled) || void 0,
            "data-disabled": unref288(disabled) ? "" : void 0,
            tabindex: unref288(disabled) ? void 0 : -1,
            as: _ctx.as,
            "as-child": _ctx.asChild,
            onFocus: _cache[0] || (_cache[0] = ($event) => isFocused.value = true),
            onBlur: _cache[1] || (_cache[1] = ($event) => isFocused.value = false),
            onPointerup: handleSelectCustomEvent,
            onPointerdown: _cache[2] || (_cache[2] = (event) => {
              event.currentTarget.focus({ preventScroll: true });
            }),
            onTouchend: _cache[3] || (_cache[3] = withModifiers18(() => {
            }, ["prevent", "stop"])),
            onPointermove: handlePointerMove2,
            onPointerleave: handlePointerLeave,
            onKeydown: handleKeyDown
          }, {
            default: withCtx281(() => [
              renderSlot286(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "tabindex", "as", "as-child"])
        ]),
        _: 3
      }, 8, ["value"]);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectItemIndicator.js
import { defineComponent as defineComponent295, createBlock as createBlock278, createCommentVNode as createCommentVNode24, unref as unref289, openBlock as openBlock286, mergeProps as mergeProps130, withCtx as withCtx282, renderSlot as renderSlot287 } from "vue";
var _sfc_main290 = defineComponent295({
  __name: "SelectItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props2 = __props;
    const itemContext = injectSelectItemContext();
    return (_ctx, _cache) => {
      return unref289(itemContext).isSelected.value ? (openBlock286(), createBlock278(unref289(Primitive), mergeProps130({
        key: 0,
        "aria-hidden": "true"
      }, props2), {
        default: withCtx282(() => [
          renderSlot287(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : createCommentVNode24("", true);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectItemText.js
import { defineComponent as defineComponent296, computed as computed96, onMounted as onMounted42, onBeforeUnmount as onBeforeUnmount2, createBlock as createBlock279, openBlock as openBlock287, unref as unref290, mergeProps as mergeProps131, withCtx as withCtx283, renderSlot as renderSlot288 } from "vue";
var _sfc_main291 = defineComponent296({
  ...{
    inheritAttrs: false
  },
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectSelectRootContext();
    const contentContext = injectSelectContentContext();
    const itemContext = injectSelectItemContext();
    const { forwardRef, currentElement: itemTextElement } = useForwardExpose();
    const optionProps = computed96(() => {
      return {
        value: itemContext.value,
        disabled: itemContext.disabled.value,
        textContent: itemTextElement.value?.textContent ?? itemContext.value?.toString() ?? ""
      };
    });
    onMounted42(() => {
      if (!itemTextElement.value)
        return;
      itemContext.onItemTextChange(itemTextElement.value);
      contentContext.itemTextRefCallback(
        itemTextElement.value,
        itemContext.value,
        itemContext.disabled.value
      );
      rootContext.onOptionAdd(optionProps.value);
    });
    onBeforeUnmount2(() => {
      rootContext.onOptionRemove(optionProps.value);
    });
    return (_ctx, _cache) => {
      return openBlock287(), createBlock279(unref290(Primitive), mergeProps131({
        id: unref290(itemContext).textId,
        ref: unref290(forwardRef)
      }, { ...props2, ..._ctx.$attrs }), {
        default: withCtx283(() => [
          renderSlot288(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectLabel.js
import { defineComponent as defineComponent297, createBlock as createBlock280, openBlock as openBlock288, unref as unref291, mergeProps as mergeProps132, withCtx as withCtx284, renderSlot as renderSlot289 } from "vue";
var _sfc_main292 = defineComponent297({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(__props) {
    const props2 = __props;
    const groupContext = injectSelectGroupContext({ id: "" });
    return (_ctx, _cache) => {
      return openBlock288(), createBlock280(unref291(Primitive), mergeProps132(props2, {
        id: unref291(groupContext).id
      }), {
        default: withCtx284(() => [
          renderSlot289(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectPortal.js
import { defineComponent as defineComponent298, createBlock as createBlock281, openBlock as openBlock289, unref as unref292, normalizeProps as normalizeProps99, guardReactiveProps as guardReactiveProps95, withCtx as withCtx285, renderSlot as renderSlot290 } from "vue";
var _sfc_main293 = defineComponent298({
  __name: "SelectPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock289(), createBlock281(unref292(_sfc_main27), normalizeProps99(guardReactiveProps95(props2)), {
        default: withCtx285(() => [
          renderSlot290(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectScrollDownButton.js
import { defineComponent as defineComponent300, ref as ref92, watchEffect as watchEffect19, watch as watch38, createBlock as createBlock283, createCommentVNode as createCommentVNode25, openBlock as openBlock291, unref as unref294, withCtx as withCtx287, renderSlot as renderSlot292 } from "vue";

// node_modules/reka-ui/dist/Select/SelectScrollButtonImpl.js
import { defineComponent as defineComponent299, ref as ref91, watchEffect as watchEffect18, onBeforeUnmount as onBeforeUnmount3, createBlock as createBlock282, openBlock as openBlock290, unref as unref293, mergeProps as mergeProps133, withCtx as withCtx286, renderSlot as renderSlot291 } from "vue";
var _sfc_main294 = defineComponent299({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const { getItems } = useCollection();
    const contentContext = injectSelectContentContext();
    const autoScrollTimerRef = ref91(null);
    function clearAutoScrollTimer() {
      if (autoScrollTimerRef.value !== null) {
        window.clearInterval(autoScrollTimerRef.value);
        autoScrollTimerRef.value = null;
      }
    }
    watchEffect18(() => {
      const activeItem = getItems().map((i) => i.ref).find(
        (item) => item === getActiveElement()
      );
      activeItem?.scrollIntoView({ block: "nearest" });
    });
    function handlePointerDown2() {
      if (autoScrollTimerRef.value === null) {
        autoScrollTimerRef.value = window.setInterval(() => {
          emits("autoScroll");
        }, 50);
      }
    }
    function handlePointerMove2() {
      contentContext.onItemLeave?.();
      if (autoScrollTimerRef.value === null) {
        autoScrollTimerRef.value = window.setInterval(() => {
          emits("autoScroll");
        }, 50);
      }
    }
    onBeforeUnmount3(() => clearAutoScrollTimer());
    return (_ctx, _cache) => {
      return openBlock290(), createBlock282(unref293(Primitive), mergeProps133({
        "aria-hidden": "true",
        style: {
          flexShrink: 0
        }
      }, _ctx.$parent?.$props, {
        onPointerdown: handlePointerDown2,
        onPointermove: handlePointerMove2,
        onPointerleave: _cache[0] || (_cache[0] = () => {
          clearAutoScrollTimer();
        })
      }), {
        default: withCtx286(() => [
          renderSlot291(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectScrollDownButton.js
var _sfc_main295 = defineComponent300({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const contentContext = injectSelectContentContext();
    const alignedPositionContext = contentContext.position === "item-aligned" ? injectSelectItemAlignedPositionContext() : void 0;
    const { forwardRef, currentElement } = useForwardExpose();
    const canScrollDown = ref92(false);
    watchEffect19((cleanupFn) => {
      if (contentContext.viewport?.value && contentContext.isPositioned?.value) {
        let handleScroll = function() {
          const maxScroll = viewport.scrollHeight - viewport.clientHeight;
          canScrollDown.value = Math.ceil(viewport.scrollTop) < maxScroll;
        };
        const viewport = contentContext.viewport.value;
        handleScroll();
        viewport.addEventListener("scroll", handleScroll);
        cleanupFn(() => viewport.removeEventListener("scroll", handleScroll));
      }
    });
    watch38(currentElement, () => {
      if (currentElement.value)
        alignedPositionContext?.onScrollButtonChange(currentElement.value);
    });
    return (_ctx, _cache) => {
      return canScrollDown.value ? (openBlock291(), createBlock283(_sfc_main294, {
        key: 0,
        ref: unref294(forwardRef),
        onAutoScroll: _cache[0] || (_cache[0] = () => {
          const { viewport, selectedItem } = unref294(contentContext);
          if (viewport?.value && selectedItem?.value) {
            viewport.value.scrollTop = viewport.value.scrollTop + selectedItem.value.offsetHeight;
          }
        })
      }, {
        default: withCtx287(() => [
          renderSlot292(_ctx.$slots, "default")
        ]),
        _: 3
      }, 512)) : createCommentVNode25("", true);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectScrollUpButton.js
import { defineComponent as defineComponent301, ref as ref93, watchEffect as watchEffect20, watch as watch39, createBlock as createBlock284, createCommentVNode as createCommentVNode26, openBlock as openBlock292, unref as unref295, withCtx as withCtx288, renderSlot as renderSlot293 } from "vue";
var _sfc_main296 = defineComponent301({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const contentContext = injectSelectContentContext();
    const alignedPositionContext = contentContext.position === "item-aligned" ? injectSelectItemAlignedPositionContext() : void 0;
    const { forwardRef, currentElement } = useForwardExpose();
    const canScrollUp = ref93(false);
    watchEffect20((cleanupFn) => {
      if (contentContext.viewport?.value && contentContext.isPositioned?.value) {
        let handleScroll = function() {
          canScrollUp.value = viewport.scrollTop > 0;
        };
        const viewport = contentContext.viewport.value;
        handleScroll();
        viewport.addEventListener("scroll", handleScroll);
        cleanupFn(() => viewport.removeEventListener("scroll", handleScroll));
      }
    });
    watch39(currentElement, () => {
      if (currentElement.value)
        alignedPositionContext?.onScrollButtonChange(currentElement.value);
    });
    return (_ctx, _cache) => {
      return canScrollUp.value ? (openBlock292(), createBlock284(_sfc_main294, {
        key: 0,
        ref: unref295(forwardRef),
        onAutoScroll: _cache[0] || (_cache[0] = () => {
          const { viewport, selectedItem } = unref295(contentContext);
          if (viewport?.value && selectedItem?.value) {
            viewport.value.scrollTop = viewport.value.scrollTop - selectedItem.value.offsetHeight;
          }
        })
      }, {
        default: withCtx288(() => [
          renderSlot293(_ctx.$slots, "default")
        ]),
        _: 3
      }, 512)) : createCommentVNode26("", true);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectSeparator.js
import { defineComponent as defineComponent302, createBlock as createBlock285, openBlock as openBlock293, unref as unref296, mergeProps as mergeProps134, withCtx as withCtx289, renderSlot as renderSlot294 } from "vue";
var _sfc_main297 = defineComponent302({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock293(), createBlock285(unref296(Primitive), mergeProps134({ "aria-hidden": "true" }, props2), {
        default: withCtx289(() => [
          renderSlot294(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectTrigger.js
import { defineComponent as defineComponent303, computed as computed97, onMounted as onMounted43, createBlock as createBlock286, openBlock as openBlock294, unref as unref297, withCtx as withCtx290, createVNode as createVNode55, withModifiers as withModifiers19, renderSlot as renderSlot295 } from "vue";
var _sfc_main298 = defineComponent303({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectSelectRootContext();
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    const isDisabled = computed97(() => rootContext.disabled?.value || props2.disabled);
    rootContext.contentId ||= useId2(void 0, "reka-select-content");
    onMounted43(() => {
      rootContext.onTriggerChange(triggerElement.value);
    });
    const { getItems } = useCollection();
    const { search, handleTypeaheadSearch, resetTypeahead } = useTypeahead();
    function handleOpen() {
      if (!isDisabled.value) {
        rootContext.onOpenChange(true);
        resetTypeahead();
      }
    }
    function handlePointerOpen(event) {
      handleOpen();
      rootContext.triggerPointerDownPosRef.value = {
        x: Math.round(event.pageX),
        y: Math.round(event.pageY)
      };
    }
    return (_ctx, _cache) => {
      return openBlock294(), createBlock286(unref297(_sfc_main58), {
        "as-child": "",
        reference: _ctx.reference
      }, {
        default: withCtx290(() => [
          createVNode55(unref297(Primitive), {
            ref: unref297(forwardRef),
            role: "combobox",
            type: _ctx.as === "button" ? "button" : void 0,
            "aria-controls": unref297(rootContext).contentId,
            "aria-expanded": unref297(rootContext).open.value || false,
            "aria-required": unref297(rootContext).required?.value,
            "aria-autocomplete": "none",
            disabled: isDisabled.value,
            dir: unref297(rootContext)?.dir.value,
            "data-state": unref297(rootContext)?.open.value ? "open" : "closed",
            "data-disabled": isDisabled.value ? "" : void 0,
            "data-placeholder": unref297(shouldShowPlaceholder)(unref297(rootContext).modelValue?.value) ? "" : void 0,
            "as-child": _ctx.asChild,
            as: _ctx.as,
            onClick: _cache[0] || (_cache[0] = (event) => {
              event?.currentTarget?.focus();
            }),
            onPointerdown: _cache[1] || (_cache[1] = (event) => {
              if (event.pointerType === "touch")
                return event.preventDefault();
              const target = event.target;
              if (target.hasPointerCapture(event.pointerId)) {
                target.releasePointerCapture(event.pointerId);
              }
              if (event.button === 0 && event.ctrlKey === false) {
                handlePointerOpen(event);
                event.preventDefault();
              }
            }),
            onPointerup: _cache[2] || (_cache[2] = withModifiers19(
              (event) => {
                if (event.pointerType === "touch")
                  handlePointerOpen(event);
              },
              ["prevent"]
            )),
            onKeydown: _cache[3] || (_cache[3] = (event) => {
              const isTypingAhead = unref297(search) !== "";
              const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
              if (!isModifierKey && event.key.length === 1) {
                if (isTypingAhead && event.key === " ") return;
              }
              unref297(handleTypeaheadSearch)(event.key, unref297(getItems)());
              if (unref297(OPEN_KEYS).includes(event.key)) {
                handleOpen();
                event.preventDefault();
              }
            })
          }, {
            default: withCtx290(() => [
              renderSlot295(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["type", "aria-controls", "aria-expanded", "aria-required", "disabled", "dir", "data-state", "data-disabled", "data-placeholder", "as-child", "as"])
        ]),
        _: 3
      }, 8, ["reference"]);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectValue.js
import { defineComponent as defineComponent304, onMounted as onMounted44, computed as computed98, createBlock as createBlock287, openBlock as openBlock295, unref as unref298, withCtx as withCtx291, renderSlot as renderSlot296, createTextVNode as createTextVNode26, toDisplayString as toDisplayString12 } from "vue";
var _sfc_main299 = defineComponent304({
  __name: "SelectValue",
  props: {
    placeholder: { default: "" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectSelectRootContext();
    onMounted44(() => {
      rootContext.valueElement = currentElement;
    });
    const selectedLabel = computed98(() => {
      let list = [];
      const options = Array.from(rootContext.optionsSet.value);
      const getOption = (value) => options.find((option) => valueComparator2(value, option.value, rootContext.by));
      if (Array.isArray(rootContext.modelValue.value)) {
        list = rootContext.modelValue.value.map((value) => getOption(value)?.textContent ?? "");
      } else {
        list = [getOption(rootContext.modelValue.value)?.textContent ?? ""];
      }
      return list.filter(Boolean);
    });
    const slotText = computed98(() => {
      return selectedLabel.value.length ? selectedLabel.value.join(", ") : props2.placeholder;
    });
    return (_ctx, _cache) => {
      return openBlock295(), createBlock287(unref298(Primitive), {
        ref: unref298(forwardRef),
        as: _ctx.as,
        "as-child": _ctx.asChild,
        style: { pointerEvents: "none" },
        "data-placeholder": selectedLabel.value.length ? void 0 : props2.placeholder
      }, {
        default: withCtx291(() => [
          renderSlot296(_ctx.$slots, "default", {
            selectedLabel: selectedLabel.value,
            modelValue: unref298(rootContext).modelValue.value
          }, () => [
            createTextVNode26(toDisplayString12(slotText.value), 1)
          ])
        ]),
        _: 3
      }, 8, ["as", "as-child", "data-placeholder"]);
    };
  }
});

// node_modules/reka-ui/dist/Select/SelectViewport.js
import { defineComponent as defineComponent305, toRefs as toRefs41, onMounted as onMounted45, ref as ref94, createElementBlock as createElementBlock14, openBlock as openBlock296, Fragment as Fragment10, createVNode as createVNode56, unref as unref299, mergeProps as mergeProps135, withCtx as withCtx292, renderSlot as renderSlot297, createTextVNode as createTextVNode27 } from "vue";
var _sfc_main300 = defineComponent305({
  __name: "SelectViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { nonce: propNonce } = toRefs41(props2);
    const nonce = useNonce(propNonce);
    const contentContext = injectSelectContentContext();
    const alignedPositionContext = contentContext.position === "item-aligned" ? injectSelectItemAlignedPositionContext() : void 0;
    const { forwardRef, currentElement } = useForwardExpose();
    onMounted45(() => {
      contentContext?.onViewportChange(currentElement.value);
    });
    const prevScrollTopRef = ref94(0);
    function handleScroll(event) {
      const viewport = event.currentTarget;
      const { shouldExpandOnScrollRef, contentWrapper } = alignedPositionContext ?? {};
      if (shouldExpandOnScrollRef?.value && contentWrapper?.value) {
        const scrolledBy = Math.abs(prevScrollTopRef.value - viewport.scrollTop);
        if (scrolledBy > 0) {
          const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
          const cssMinHeight = Number.parseFloat(
            contentWrapper.value.style.minHeight
          );
          const cssHeight = Number.parseFloat(contentWrapper.value.style.height);
          const prevHeight = Math.max(cssMinHeight, cssHeight);
          if (prevHeight < availableHeight) {
            const nextHeight = prevHeight + scrolledBy;
            const clampedNextHeight = Math.min(availableHeight, nextHeight);
            const heightDiff = nextHeight - clampedNextHeight;
            contentWrapper.value.style.height = `${clampedNextHeight}px`;
            if (contentWrapper.value.style.bottom === "0px") {
              viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
              contentWrapper.value.style.justifyContent = "flex-end";
            }
          }
        }
      }
      prevScrollTopRef.value = viewport.scrollTop;
    }
    return (_ctx, _cache) => {
      return openBlock296(), createElementBlock14(Fragment10, null, [
        createVNode56(unref299(Primitive), mergeProps135({
          ref: unref299(forwardRef),
          "data-reka-select-viewport": "",
          role: "presentation"
        }, { ..._ctx.$attrs, ...props2 }, {
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            overflow: "hidden auto"
          },
          onScroll: handleScroll
        }), {
          default: withCtx292(() => [
            renderSlot297(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16),
        createVNode56(unref299(Primitive), {
          as: "style",
          nonce: unref299(nonce)
        }, {
          default: withCtx292(() => _cache[0] || (_cache[0] = [
            createTextVNode27(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-select-viewport]::-webkit-scrollbar { display: none; } ")
          ])),
          _: 1
        }, 8, ["nonce"])
      ], 64);
    };
  }
});

// node_modules/reka-ui/dist/Separator/Separator.js
import { defineComponent as defineComponent307, createBlock as createBlock289, openBlock as openBlock298, normalizeProps as normalizeProps100, guardReactiveProps as guardReactiveProps96, withCtx as withCtx294, renderSlot as renderSlot299 } from "vue";

// node_modules/reka-ui/dist/component/BaseSeparator.js
import { defineComponent as defineComponent306, computed as computed99, createBlock as createBlock288, openBlock as openBlock297, unref as unref300, mergeProps as mergeProps136, withCtx as withCtx293, renderSlot as renderSlot298 } from "vue";
var _sfc_main301 = defineComponent306({
  __name: "BaseSeparator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const ORIENTATIONS = ["horizontal", "vertical"];
    function isValidOrientation(orientation) {
      return ORIENTATIONS.includes(orientation);
    }
    const computedOrientation = computed99(
      () => isValidOrientation(props2.orientation) ? props2.orientation : "horizontal"
    );
    const ariaOrientation = computed99(
      () => computedOrientation.value === "vertical" ? props2.orientation : void 0
    );
    const semanticProps = computed99(
      () => props2.decorative ? { role: "none" } : { "aria-orientation": ariaOrientation.value, "role": "separator" }
    );
    return (_ctx, _cache) => {
      return openBlock297(), createBlock288(unref300(Primitive), mergeProps136({
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-orientation": computedOrientation.value
      }, semanticProps.value), {
        default: withCtx293(() => [
          renderSlot298(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["as", "as-child", "data-orientation"]);
    };
  }
});

// node_modules/reka-ui/dist/Separator/Separator.js
var _sfc_main302 = defineComponent307({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock298(), createBlock289(_sfc_main301, normalizeProps100(guardReactiveProps96(props2)), {
        default: withCtx294(() => [
          renderSlot299(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Slider/SliderRange.js
import { defineComponent as defineComponent312, computed as computed103, createBlock as createBlock294, openBlock as openBlock303, unref as unref305, normalizeStyle as normalizeStyle13, withCtx as withCtx299, renderSlot as renderSlot304 } from "vue";

// node_modules/reka-ui/dist/Slider/utils.js
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function convertValueToPercentage(value, min2, max2) {
  const maxSteps = max2 - min2;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min2);
  return clamp3(percentage, 0, 100);
}
function getLabel(index, totalValues) {
  if (totalValues > 2)
    return `Value ${index + 1} of ${totalValues}`;
  else if (totalValues === 2)
    return ["Minimum", "Maximum"][index];
  else
    return void 0;
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1)
    return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset3 = linearScale2([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset3(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index) => values[index + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale2(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = 10 ** decimalCount;
  return Math.round(value * rounder) / rounder;
}
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var [injectSliderOrientationContext, provideSliderOrientationContext] = createContext(["SliderVertical", "SliderHorizontal"]);

// node_modules/reka-ui/dist/Slider/SliderRoot.js
import { defineComponent as defineComponent311, toRefs as toRefs44, computed as computed102, ref as ref97, createBlock as createBlock293, openBlock as openBlock302, unref as unref304, withCtx as withCtx298, resolveDynamicComponent as resolveDynamicComponent7, mergeProps as mergeProps138, renderSlot as renderSlot303, createCommentVNode as createCommentVNode27, toRaw as toRaw2 } from "vue";

// node_modules/reka-ui/dist/Slider/SliderHorizontal.js
import { defineComponent as defineComponent309, toRefs as toRefs42, ref as ref95, computed as computed100, createBlock as createBlock291, openBlock as openBlock300, normalizeStyle as normalizeStyle11, unref as unref302, withCtx as withCtx296, renderSlot as renderSlot301 } from "vue";

// node_modules/reka-ui/dist/Slider/SliderImpl.js
import { defineComponent as defineComponent308, createBlock as createBlock290, openBlock as openBlock299, unref as unref301, mergeProps as mergeProps137, withCtx as withCtx295, renderSlot as renderSlot300 } from "vue";
var _sfc_main303 = defineComponent308({
  __name: "SliderImpl",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  emits: ["slideStart", "slideMove", "slideEnd", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectSliderRootContext();
    return (_ctx, _cache) => {
      return openBlock299(), createBlock290(unref301(Primitive), mergeProps137({ "data-slider-impl": "" }, props2, {
        onKeydown: _cache[0] || (_cache[0] = (event) => {
          if (event.key === "Home") {
            emits("homeKeyDown", event);
            event.preventDefault();
          } else if (event.key === "End") {
            emits("endKeyDown", event);
            event.preventDefault();
          } else if (unref301(PAGE_KEYS).concat(unref301(ARROW_KEYS)).includes(event.key)) {
            emits("stepKeyDown", event);
            event.preventDefault();
          }
        }),
        onPointerdown: _cache[1] || (_cache[1] = (event) => {
          const target = event.target;
          target.setPointerCapture(event.pointerId);
          event.preventDefault();
          if (unref301(rootContext).thumbElements.value.includes(target)) {
            target.focus();
          } else {
            emits("slideStart", event);
          }
        }),
        onPointermove: _cache[2] || (_cache[2] = (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) emits("slideMove", event);
        }),
        onPointerup: _cache[3] || (_cache[3] = (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            emits("slideEnd", event);
          }
        })
      }), {
        default: withCtx295(() => [
          renderSlot300(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Slider/SliderHorizontal.js
var _sfc_main304 = defineComponent309({
  __name: "SliderHorizontal",
  props: {
    dir: {},
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { max: max2, min: min2, dir, inverted } = toRefs42(props2);
    const { forwardRef, currentElement: sliderElement } = useForwardExpose();
    const rootContext = injectSliderRootContext();
    const offsetPosition = ref95();
    const rectRef = ref95();
    const isSlidingFromLeft = computed100(() => dir?.value === "ltr" && !inverted.value || dir?.value !== "ltr" && inverted.value);
    function getValueFromPointerEvent(event, slideStart) {
      const rect = rectRef.value || sliderElement.value.getBoundingClientRect();
      const thumb = [...rootContext.thumbElements.value][rootContext.valueIndexToChangeRef.value];
      const thumbWidth = rootContext.thumbAlignment.value === "contain" ? thumb.clientWidth : 0;
      if (!offsetPosition.value && !slideStart && rootContext.thumbAlignment.value === "contain") {
        offsetPosition.value = event.clientX - thumb.getBoundingClientRect().left;
      }
      const input = [0, rect.width - thumbWidth];
      const output = isSlidingFromLeft.value ? [min2.value, max2.value] : [max2.value, min2.value];
      const value = linearScale2(input, output);
      rectRef.value = rect;
      const position = slideStart ? event.clientX - rect.left - thumbWidth / 2 : event.clientX - rect.left - (offsetPosition.value ?? 0);
      return value(position);
    }
    provideSliderOrientationContext({
      startEdge: isSlidingFromLeft.value ? "left" : "right",
      endEdge: isSlidingFromLeft.value ? "right" : "left",
      direction: isSlidingFromLeft.value ? 1 : -1,
      size: "width"
    });
    return (_ctx, _cache) => {
      return openBlock300(), createBlock291(_sfc_main303, {
        ref: unref302(forwardRef),
        dir: unref302(dir),
        "data-orientation": "horizontal",
        style: normalizeStyle11({
          ["--reka-slider-thumb-transform"]: !isSlidingFromLeft.value && unref302(rootContext).thumbAlignment.value === "overflow" ? "translateX(50%)" : "translateX(-50%)"
        }),
        onSlideStart: _cache[0] || (_cache[0] = (event) => {
          const value = getValueFromPointerEvent(event, true);
          emits("slideStart", value);
        }),
        onSlideMove: _cache[1] || (_cache[1] = (event) => {
          const value = getValueFromPointerEvent(event);
          emits("slideMove", value);
        }),
        onSlideEnd: _cache[2] || (_cache[2] = () => {
          rectRef.value = void 0;
          offsetPosition.value = void 0;
          emits("slideEnd");
        }),
        onStepKeyDown: _cache[3] || (_cache[3] = (event) => {
          const slideDirection = isSlidingFromLeft.value ? "from-left" : "from-right";
          const isBackKey = unref302(BACK_KEYS)[slideDirection].includes(event.key);
          emits("stepKeyDown", event, isBackKey ? -1 : 1);
        }),
        onEndKeyDown: _cache[4] || (_cache[4] = ($event) => emits("endKeyDown", $event)),
        onHomeKeyDown: _cache[5] || (_cache[5] = ($event) => emits("homeKeyDown", $event))
      }, {
        default: withCtx296(() => [
          renderSlot301(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["dir", "style"]);
    };
  }
});

// node_modules/reka-ui/dist/Slider/SliderVertical.js
import { defineComponent as defineComponent310, toRefs as toRefs43, ref as ref96, computed as computed101, createBlock as createBlock292, openBlock as openBlock301, normalizeStyle as normalizeStyle12, unref as unref303, withCtx as withCtx297, renderSlot as renderSlot302 } from "vue";
var _sfc_main305 = defineComponent310({
  __name: "SliderVertical",
  props: {
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { max: max2, min: min2, inverted } = toRefs43(props2);
    const rootContext = injectSliderRootContext();
    const { forwardRef, currentElement: sliderElement } = useForwardExpose();
    const offsetPosition = ref96();
    const rectRef = ref96();
    const isSlidingFromBottom = computed101(() => !inverted.value);
    function getValueFromPointerEvent(event, slideStart) {
      const rect = rectRef.value || sliderElement.value.getBoundingClientRect();
      const thumb = [...rootContext.thumbElements.value][rootContext.valueIndexToChangeRef.value];
      const thumbHeight = rootContext.thumbAlignment.value === "contain" ? thumb.clientHeight : 0;
      if (!offsetPosition.value && !slideStart && rootContext.thumbAlignment.value === "contain") {
        offsetPosition.value = event.clientY - thumb.getBoundingClientRect().top;
      }
      const input = [0, rect.height - thumbHeight];
      const output = isSlidingFromBottom.value ? [max2.value, min2.value] : [min2.value, max2.value];
      const value = linearScale2(input, output);
      const position = slideStart ? event.clientY - rect.top - thumbHeight / 2 : event.clientY - rect.top - (offsetPosition.value ?? 0);
      rectRef.value = rect;
      return value(position);
    }
    provideSliderOrientationContext({
      startEdge: isSlidingFromBottom.value ? "bottom" : "top",
      endEdge: isSlidingFromBottom.value ? "top" : "bottom",
      size: "height",
      direction: isSlidingFromBottom.value ? 1 : -1
    });
    return (_ctx, _cache) => {
      return openBlock301(), createBlock292(_sfc_main303, {
        ref: unref303(forwardRef),
        "data-orientation": "vertical",
        style: normalizeStyle12({
          ["--reka-slider-thumb-transform"]: !isSlidingFromBottom.value && unref303(rootContext).thumbAlignment.value === "overflow" ? "translateY(-50%)" : "translateY(50%)"
        }),
        onSlideStart: _cache[0] || (_cache[0] = (event) => {
          const value = getValueFromPointerEvent(event, true);
          emits("slideStart", value);
        }),
        onSlideMove: _cache[1] || (_cache[1] = (event) => {
          const value = getValueFromPointerEvent(event);
          emits("slideMove", value);
        }),
        onSlideEnd: _cache[2] || (_cache[2] = () => {
          rectRef.value = void 0;
          offsetPosition.value = void 0;
          emits("slideEnd");
        }),
        onStepKeyDown: _cache[3] || (_cache[3] = (event) => {
          const slideDirection = isSlidingFromBottom.value ? "from-bottom" : "from-top";
          const isBackKey = unref303(BACK_KEYS)[slideDirection].includes(event.key);
          emits("stepKeyDown", event, isBackKey ? -1 : 1);
        }),
        onEndKeyDown: _cache[4] || (_cache[4] = ($event) => emits("endKeyDown", $event)),
        onHomeKeyDown: _cache[5] || (_cache[5] = ($event) => emits("homeKeyDown", $event))
      }, {
        default: withCtx297(() => [
          renderSlot302(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["style"]);
    };
  }
});

// node_modules/reka-ui/dist/Slider/SliderRoot.js
var [injectSliderRootContext, provideSliderRootContext] = createContext("SliderRoot");
var _sfc_main306 = defineComponent311({
  ...{
    inheritAttrs: false
  },
  __name: "SliderRoot",
  props: {
    defaultValue: { default: () => [0] },
    modelValue: {},
    disabled: { type: Boolean, default: false },
    orientation: { default: "horizontal" },
    dir: {},
    inverted: { type: Boolean, default: false },
    min: { default: 0 },
    max: { default: 100 },
    step: { default: 1 },
    minStepsBetweenThumbs: { default: 0 },
    thumbAlignment: { default: "contain" },
    asChild: { type: Boolean },
    as: { default: "span" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { min: min2, max: max2, step, minStepsBetweenThumbs, orientation, disabled, thumbAlignment, dir: propDir } = toRefs44(props2);
    const dir = useDirection(propDir);
    const { forwardRef, currentElement } = useForwardExpose();
    const isFormControl = useFormControl(currentElement);
    const { CollectionSlot } = useCollection({ isProvider: true });
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const currentModelValue = computed102(() => Array.isArray(modelValue.value) ? [...modelValue.value] : []);
    const valueIndexToChangeRef = ref97(0);
    const valuesBeforeSlideStartRef = ref97(currentModelValue.value);
    function handleSlideStart(value) {
      const closestIndex = getClosestValueIndex(currentModelValue.value, value);
      updateValues(value, closestIndex);
    }
    function handleSlideMove(value) {
      updateValues(value, valueIndexToChangeRef.value);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.value[valueIndexToChangeRef.value];
      const nextValue = currentModelValue.value[valueIndexToChangeRef.value];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged)
        emits("valueCommit", toRaw2(currentModelValue.value));
    }
    function updateValues(value, atIndex, { commit } = { commit: false }) {
      const decimalCount = getDecimalCount(step.value);
      const snapToStep = roundValue(Math.round((value - min2.value) / step.value) * step.value + min2.value, decimalCount);
      const nextValue = clamp3(snapToStep, min2.value, max2.value);
      const nextValues = getNextSortedValues(currentModelValue.value, nextValue, atIndex);
      if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs.value * step.value)) {
        valueIndexToChangeRef.value = nextValues.indexOf(nextValue);
        const hasChanged = String(nextValues) !== String(modelValue.value);
        if (hasChanged && commit)
          emits("valueCommit", nextValues);
        if (hasChanged) {
          thumbElements.value[valueIndexToChangeRef.value]?.focus();
          modelValue.value = nextValues;
        }
      }
    }
    const thumbElements = ref97([]);
    provideSliderRootContext({
      modelValue,
      currentModelValue,
      valueIndexToChangeRef,
      thumbElements,
      orientation,
      min: min2,
      max: max2,
      disabled,
      thumbAlignment
    });
    return (_ctx, _cache) => {
      return openBlock302(), createBlock293(unref304(CollectionSlot), null, {
        default: withCtx298(() => [
          (openBlock302(), createBlock293(resolveDynamicComponent7(unref304(orientation) === "horizontal" ? _sfc_main304 : _sfc_main305), mergeProps138(_ctx.$attrs, {
            ref: unref304(forwardRef),
            "as-child": _ctx.asChild,
            as: _ctx.as,
            min: unref304(min2),
            max: unref304(max2),
            dir: unref304(dir),
            inverted: _ctx.inverted,
            "aria-disabled": unref304(disabled),
            "data-disabled": unref304(disabled) ? "" : void 0,
            onPointerdown: _cache[0] || (_cache[0] = () => {
              if (!unref304(disabled)) valuesBeforeSlideStartRef.value = currentModelValue.value;
            }),
            onSlideStart: _cache[1] || (_cache[1] = ($event) => !unref304(disabled) && handleSlideStart($event)),
            onSlideMove: _cache[2] || (_cache[2] = ($event) => !unref304(disabled) && handleSlideMove($event)),
            onSlideEnd: _cache[3] || (_cache[3] = ($event) => !unref304(disabled) && handleSlideEnd()),
            onHomeKeyDown: _cache[4] || (_cache[4] = ($event) => !unref304(disabled) && updateValues(unref304(min2), 0, { commit: true })),
            onEndKeyDown: _cache[5] || (_cache[5] = ($event) => !unref304(disabled) && updateValues(unref304(max2), currentModelValue.value.length - 1, { commit: true })),
            onStepKeyDown: _cache[6] || (_cache[6] = (event, direction) => {
              if (!unref304(disabled)) {
                const isPageKey = unref304(PAGE_KEYS).includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && unref304(ARROW_KEYS).includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex = valueIndexToChangeRef.value;
                const value = currentModelValue.value[atIndex];
                const stepInDirection = unref304(step) * multiplier * direction;
                updateValues(value + stepInDirection, atIndex, { commit: true });
              }
            })
          }), {
            default: withCtx298(() => [
              renderSlot303(_ctx.$slots, "default", { modelValue: unref304(modelValue) }),
              unref304(isFormControl) && _ctx.name ? (openBlock302(), createBlock293(unref304(_sfc_main52), {
                key: 0,
                type: "number",
                value: unref304(modelValue),
                name: _ctx.name,
                required: _ctx.required,
                disabled: unref304(disabled),
                step: unref304(step)
              }, null, 8, ["value", "name", "required", "disabled", "step"])) : createCommentVNode27("", true)
            ]),
            _: 3
          }, 16, ["as-child", "as", "min", "max", "dir", "inverted", "aria-disabled", "data-disabled"]))
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Slider/SliderRange.js
var _sfc_main307 = defineComponent312({
  __name: "SliderRange",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const rootContext = injectSliderRootContext();
    const orientation = injectSliderOrientationContext();
    useForwardExpose();
    const percentages = computed103(() => rootContext.currentModelValue.value.map(
      (value) => convertValueToPercentage(value, rootContext.min.value, rootContext.max.value)
    ));
    const offsetStart = computed103(() => rootContext.currentModelValue.value.length > 1 ? Math.min(...percentages.value) : 0);
    const offsetEnd = computed103(() => 100 - Math.max(...percentages.value, 0));
    return (_ctx, _cache) => {
      return openBlock303(), createBlock294(unref305(Primitive), {
        "data-disabled": unref305(rootContext).disabled.value ? "" : void 0,
        "data-orientation": unref305(rootContext).orientation.value,
        "as-child": _ctx.asChild,
        as: _ctx.as,
        style: normalizeStyle13({
          [unref305(orientation).startEdge]: `${offsetStart.value}%`,
          [unref305(orientation).endEdge]: `${offsetEnd.value}%`
        })
      }, {
        default: withCtx299(() => [
          renderSlot304(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["data-disabled", "data-orientation", "as-child", "as", "style"]);
    };
  }
});

// node_modules/reka-ui/dist/Slider/SliderThumb.js
import { defineComponent as defineComponent314, computed as computed105, createBlock as createBlock296, openBlock as openBlock305, mergeProps as mergeProps140, unref as unref307, withCtx as withCtx301, renderSlot as renderSlot306 } from "vue";

// node_modules/reka-ui/dist/Slider/SliderThumbImpl.js
import { defineComponent as defineComponent313, computed as computed104, onMounted as onMounted46, onUnmounted as onUnmounted19, createBlock as createBlock295, openBlock as openBlock304, unref as unref306, withCtx as withCtx300, createVNode as createVNode57, mergeProps as mergeProps139, renderSlot as renderSlot305 } from "vue";
var _sfc_main308 = defineComponent313({
  ...{
    inheritAttrs: false
  },
  __name: "SliderThumbImpl",
  props: {
    index: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectSliderRootContext();
    const orientation = injectSliderOrientationContext();
    const { forwardRef, currentElement: thumbElement } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const value = computed104(() => rootContext.modelValue?.value?.[props2.index]);
    const percent = computed104(() => value.value === void 0 ? 0 : convertValueToPercentage(value.value, rootContext.min.value ?? 0, rootContext.max.value ?? 100));
    const label = computed104(() => getLabel(props2.index, rootContext.modelValue?.value?.length ?? 0));
    const size3 = useSize(thumbElement);
    const orientationSize = computed104(() => size3[orientation.size].value);
    const thumbInBoundsOffset = computed104(() => {
      if (rootContext.thumbAlignment.value === "overflow" || !orientationSize.value) {
        return 0;
      } else {
        return getThumbInBoundsOffset(orientationSize.value, percent.value, orientation.direction);
      }
    });
    const isMounted = useMounted();
    onMounted46(() => {
      rootContext.thumbElements.value.push(thumbElement.value);
    });
    onUnmounted19(() => {
      const i = rootContext.thumbElements.value.findIndex((i2) => i2 === thumbElement.value) ?? -1;
      rootContext.thumbElements.value.splice(i, 1);
    });
    return (_ctx, _cache) => {
      return openBlock304(), createBlock295(unref306(CollectionItem), null, {
        default: withCtx300(() => [
          createVNode57(unref306(Primitive), mergeProps139(_ctx.$attrs, {
            ref: unref306(forwardRef),
            role: "slider",
            tabindex: unref306(rootContext).disabled.value ? void 0 : 0,
            "aria-label": _ctx.$attrs["aria-label"] || label.value,
            "data-disabled": unref306(rootContext).disabled.value ? "" : void 0,
            "data-orientation": unref306(rootContext).orientation.value,
            "aria-valuenow": value.value,
            "aria-valuemin": unref306(rootContext).min.value,
            "aria-valuemax": unref306(rootContext).max.value,
            "aria-orientation": unref306(rootContext).orientation.value,
            "as-child": _ctx.asChild,
            as: _ctx.as,
            style: {
              transform: "var(--reka-slider-thumb-transform)",
              position: "absolute",
              [unref306(orientation).startEdge]: `calc(${percent.value}% + ${thumbInBoundsOffset.value}px)`,
              /**
               * There will be no value on initial render while we work out the index so we hide thumbs
               * without a value, otherwise SSR will render them in the wrong position before they
               * snap into the correct position during hydration which would be visually jarring for
               * slower connections.
               */
              display: !unref306(isMounted) && value.value === void 0 ? "none" : void 0
            },
            onFocus: _cache[0] || (_cache[0] = () => {
              unref306(rootContext).valueIndexToChangeRef.value = _ctx.index;
            })
          }), {
            default: withCtx300(() => [
              renderSlot305(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["tabindex", "aria-label", "data-disabled", "data-orientation", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-orientation", "as-child", "as", "style"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Slider/SliderThumb.js
var _sfc_main309 = defineComponent314({
  __name: "SliderThumb",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props2 = __props;
    const { getItems } = useCollection();
    const { forwardRef, currentElement: thumbElement } = useForwardExpose();
    const index = computed105(() => thumbElement.value ? getItems(true).findIndex((i) => i.ref === thumbElement.value) : -1);
    return (_ctx, _cache) => {
      return openBlock305(), createBlock296(_sfc_main308, mergeProps140({ ref: unref307(forwardRef) }, props2, { index: index.value }), {
        default: withCtx301(() => [
          renderSlot306(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["index"]);
    };
  }
});

// node_modules/reka-ui/dist/Slider/SliderTrack.js
import { defineComponent as defineComponent315, createBlock as createBlock297, openBlock as openBlock306, unref as unref308, withCtx as withCtx302, renderSlot as renderSlot307 } from "vue";
var _sfc_main310 = defineComponent315({
  __name: "SliderTrack",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const rootContext = injectSliderRootContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock306(), createBlock297(unref308(Primitive), {
        "as-child": _ctx.asChild,
        as: _ctx.as,
        "data-disabled": unref308(rootContext).disabled.value ? "" : void 0,
        "data-orientation": unref308(rootContext).orientation.value
      }, {
        default: withCtx302(() => [
          renderSlot307(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as", "data-disabled", "data-orientation"]);
    };
  }
});

// node_modules/reka-ui/dist/Splitter/SplitterGroup.js
import { defineComponent as defineComponent316, toRefs as toRefs45, ref as ref98, computed as computed106, watchEffect as watchEffect22, watch as watch40, createBlock as createBlock298, openBlock as openBlock307, unref as unref309, normalizeStyle as normalizeStyle14, withCtx as withCtx303, renderSlot as renderSlot308 } from "vue";

// node_modules/reka-ui/dist/utils/assert.js
function assert(expectedCondition, message = "Assertion failed!") {
  if (!expectedCondition) {
    console.error(message);
    throw new Error(message);
  }
}

// node_modules/reka-ui/dist/shared/browser.js
var isBrowser = typeof document !== "undefined";

// node_modules/reka-ui/dist/utils/dom.js
function getPanelGroupElement(id, rootElement = document) {
  if (!isBrowser)
    return null;
  if (rootElement instanceof HTMLElement && rootElement?.dataset?.panelGroupId === id) {
    return rootElement;
  }
  const element = rootElement.querySelector(
    `[data-panel-group][data-panel-group-id="${id}"]`
  );
  if (element)
    return element;
  return null;
}
function getResizeHandleElement(id, scope = document) {
  if (!isBrowser)
    return null;
  const element = scope.querySelector(`[data-panel-resize-handle-id="${id}"]`);
  if (element)
    return element;
  return null;
}
function getResizeHandleElementIndex(groupId, id, scope = document) {
  if (!isBrowser)
    return null;
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index = handles.findIndex(
    (handle) => handle.getAttribute("data-panel-resize-handle-id") === id
  );
  return index ?? null;
}
function getResizeHandleElementsForGroup(groupId, scope = document) {
  if (!isBrowser)
    return [];
  return Array.from(
    scope.querySelectorAll(
      `[data-panel-resize-handle-id][data-panel-group-id="${groupId}"]`
    )
  );
}
function getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {
  const handle = getResizeHandleElement(handleId, scope);
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index = handle ? handles.indexOf(handle) : -1;
  const idBefore = panelsArray[index]?.id ?? null;
  const idAfter = panelsArray[index + 1]?.id ?? null;
  return [idBefore, idAfter];
}

// node_modules/reka-ui/dist/utils/events.js
function isKeyDown(event) {
  return event.type === "keydown";
}
function isMouseEvent2(event) {
  return event.type.startsWith("mouse");
}
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}
function getResizeEventCoordinates(event) {
  if (isMouseEvent2(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  } else if (isTouchEvent(event)) {
    const touch = event.touches[0];
    if (touch && touch.clientX && touch.clientY) {
      return {
        x: touch.clientX,
        y: touch.clientY
      };
    }
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function getResizeEventCursorPosition(direction, event) {
  const isHorizontal = direction === "horizontal";
  const { x, y } = getResizeEventCoordinates(event);
  return isHorizontal ? x : y;
}

// node_modules/reka-ui/dist/utils/calculate.js
function calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {
  const isHorizontal = direction === "horizontal";
  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);
  assert(handleElement);
  const groupId = handleElement.getAttribute("data-panel-group-id");
  assert(groupId);
  const { initialCursorPosition } = initialDragState;
  const cursorPosition = getResizeEventCursorPosition(direction, event);
  const groupElement = getPanelGroupElement(groupId, panelGroupElement);
  assert(groupElement);
  const groupRect = groupElement.getBoundingClientRect();
  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;
  const offsetPixels = cursorPosition - initialCursorPosition;
  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;
  return offsetPercentage;
}
function calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {
  if (isKeyDown(event)) {
    const isHorizontal = direction === "horizontal";
    let delta = 0;
    if (event.shiftKey)
      delta = 100;
    else
      delta = keyboardResizeBy ?? 10;
    let movement = 0;
    switch (event.key) {
      case "ArrowDown":
        movement = isHorizontal ? 0 : delta;
        break;
      case "ArrowLeft":
        movement = isHorizontal ? -delta : 0;
        break;
      case "ArrowRight":
        movement = isHorizontal ? delta : 0;
        break;
      case "ArrowUp":
        movement = isHorizontal ? 0 : -delta;
        break;
      case "End":
        movement = 100;
        break;
      case "Home":
        movement = -100;
        break;
    }
    return movement;
  } else {
    if (initialDragState == null)
      return 0;
    return calculateDragOffsetPercentage(
      event,
      dragHandleId,
      direction,
      initialDragState,
      panelGroupElement
    );
  }
}
function calculateAriaValues({
  layout,
  panelsArray,
  pivotIndices
}) {
  let currentMinSize = 0;
  let currentMaxSize = 100;
  let totalMinSize = 0;
  let totalMaxSize = 0;
  const firstIndex = pivotIndices[0];
  assert(firstIndex != null);
  panelsArray.forEach((panelData, index) => {
    const { constraints } = panelData;
    const { maxSize = 100, minSize = 0 } = constraints;
    if (index === firstIndex) {
      currentMinSize = minSize;
      currentMaxSize = maxSize;
    } else {
      totalMinSize += minSize;
      totalMaxSize += maxSize;
    }
  });
  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);
  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);
  const valueNow = layout[firstIndex];
  return {
    valueMax,
    valueMin,
    valueNow
  };
}
function calculateUnsafeDefaultLayout({
  panelDataArray
}) {
  const layout = Array.from({ length: panelDataArray.length });
  const panelConstraintsArray = panelDataArray.map(
    (panelData) => panelData.constraints
  );
  let numPanelsWithSizes = 0;
  let remainingSize = 100;
  for (let index = 0; index < panelDataArray.length; index++) {
    const panelConstraints = panelConstraintsArray[index];
    assert(panelConstraints);
    const { defaultSize } = panelConstraints;
    if (defaultSize != null) {
      numPanelsWithSizes++;
      layout[index] = defaultSize;
      remainingSize -= defaultSize;
    }
  }
  for (let index = 0; index < panelDataArray.length; index++) {
    const panelConstraints = panelConstraintsArray[index];
    assert(panelConstraints);
    const { defaultSize } = panelConstraints;
    if (defaultSize != null)
      continue;
    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;
    const size3 = remainingSize / numRemainingPanels;
    numPanelsWithSizes++;
    layout[index] = size3;
    remainingSize -= size3;
  }
  return layout;
}

// node_modules/reka-ui/dist/utils/callPanelCallbacks.js
function callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {
  layout.forEach((size3, index) => {
    const panelData = panelsArray[index];
    assert(panelData);
    const { callbacks, constraints, id: panelId } = panelData;
    const { collapsedSize = 0, collapsible } = constraints;
    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];
    if (lastNotifiedSize == null || size3 !== lastNotifiedSize) {
      panelIdToLastNotifiedSizeMap[panelId] = size3;
      const { onCollapse, onExpand, onResize } = callbacks;
      if (onResize)
        onResize(size3, lastNotifiedSize);
      if (collapsible && (onCollapse || onExpand)) {
        if (onExpand && (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size3 !== collapsedSize) {
          onExpand();
        }
        if (onCollapse && (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) && size3 === collapsedSize) {
          onCollapse();
        }
      }
    }
  });
}

// node_modules/reka-ui/dist/utils/debounce.js
function debounce2(callback, durationMs = 10) {
  let timeoutId = null;
  const callable = (...args) => {
    if (timeoutId !== null)
      clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      callback(...args);
    }, durationMs);
  };
  return callable;
}

// node_modules/reka-ui/dist/utils/constants.js
var PRECISION = 10;

// node_modules/reka-ui/dist/utils/compare.js
function fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {
  actual = Number.parseFloat(actual.toFixed(fractionDigits));
  expected = Number.parseFloat(expected.toFixed(fractionDigits));
  const delta = actual - expected;
  if (delta === 0)
    return 0;
  else
    return delta > 0 ? 1 : -1;
}
function fuzzyNumbersEqual(actual, expected, fractionDigits) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}

// node_modules/reka-ui/dist/utils/resizePanel.js
function resizePanel({
  panelConstraints: panelConstraintsArray,
  panelIndex,
  size: size3
}) {
  const panelConstraints = panelConstraintsArray[panelIndex];
  assert(panelConstraints != null);
  const { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panelConstraints;
  if (fuzzyCompareNumbers(size3, minSize) < 0) {
    if (collapsible) {
      const halfwayPoint = (collapsedSize + minSize) / 2;
      if (fuzzyCompareNumbers(size3, halfwayPoint) < 0)
        size3 = collapsedSize;
      else
        size3 = minSize;
    } else {
      size3 = minSize;
    }
  }
  size3 = Math.min(maxSize, size3);
  size3 = Number.parseFloat(size3.toFixed(PRECISION));
  return size3;
}

// node_modules/reka-ui/dist/utils/layout.js
function compareLayouts(a, b) {
  if (a.length !== b.length) {
    return false;
  } else {
    for (let index = 0; index < a.length; index++) {
      if (a[index] !== b[index])
        return false;
    }
  }
  return true;
}
function adjustLayoutByDelta({
  delta,
  layout: prevLayout,
  panelConstraints: panelConstraintsArray,
  pivotIndices,
  trigger
}) {
  if (fuzzyNumbersEqual(delta, 0))
    return prevLayout;
  const nextLayout = [...prevLayout];
  const [firstPivotIndex, secondPivotIndex] = pivotIndices;
  assert(firstPivotIndex != null);
  assert(secondPivotIndex != null);
  let deltaApplied = 0;
  {
    if (trigger === "keyboard") {
      {
        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;
        const panelConstraints = panelConstraintsArray[index];
        assert(panelConstraints);
        if (panelConstraints.collapsible) {
          const prevSize = prevLayout[index];
          assert(prevSize != null);
          const panelConstraints2 = panelConstraintsArray[index];
          assert(panelConstraints2);
          const { collapsedSize = 0, minSize = 0 } = panelConstraints2;
          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {
            const localDelta = minSize - prevSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0)
              delta = delta < 0 ? 0 - localDelta : localDelta;
          }
        }
      }
      {
        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;
        const panelConstraints = panelConstraintsArray[index];
        assert(panelConstraints);
        const { collapsible } = panelConstraints;
        if (collapsible) {
          const prevSize = prevLayout[index];
          assert(prevSize != null);
          const panelConstraints2 = panelConstraintsArray[index];
          assert(panelConstraints2);
          const { collapsedSize = 0, minSize = 0 } = panelConstraints2;
          if (fuzzyNumbersEqual(prevSize, minSize)) {
            const localDelta = prevSize - collapsedSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0)
              delta = delta < 0 ? 0 - localDelta : localDelta;
          }
        }
      }
    }
  }
  {
    const increment = delta < 0 ? 1 : -1;
    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;
    let maxAvailableDelta = 0;
    while (true) {
      const prevSize = prevLayout[index];
      assert(prevSize != null);
      const maxSafeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index,
        size: 100
      });
      const delta2 = maxSafeSize - prevSize;
      maxAvailableDelta += delta2;
      index += increment;
      if (index < 0 || index >= panelConstraintsArray.length)
        break;
    }
    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
  }
  {
    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;
    let index = pivotIndex;
    while (index >= 0 && index < panelConstraintsArray.length) {
      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);
      const prevSize = prevLayout[index];
      assert(prevSize != null);
      const unsafeSize = prevSize - deltaRemaining;
      const safeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index,
        size: unsafeSize
      });
      if (!fuzzyNumbersEqual(prevSize, safeSize)) {
        deltaApplied += prevSize - safeSize;
        nextLayout[index] = safeSize;
        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {
          numeric: true
        }) >= 0) {
          break;
        }
      }
      if (delta < 0)
        index--;
      else
        index++;
    }
  }
  if (fuzzyNumbersEqual(deltaApplied, 0)) {
    return prevLayout;
  }
  {
    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;
    const prevSize = prevLayout[pivotIndex];
    assert(prevSize != null);
    const unsafeSize = prevSize + deltaApplied;
    const safeSize = resizePanel({
      panelConstraints: panelConstraintsArray,
      panelIndex: pivotIndex,
      size: unsafeSize
    });
    nextLayout[pivotIndex] = safeSize;
    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {
      let deltaRemaining = unsafeSize - safeSize;
      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
      let index = pivotIndex2;
      while (index >= 0 && index < panelConstraintsArray.length) {
        const prevSize2 = nextLayout[index];
        assert(prevSize2 != null);
        const unsafeSize2 = prevSize2 + deltaRemaining;
        const safeSize2 = resizePanel({
          panelConstraints: panelConstraintsArray,
          panelIndex: index,
          size: unsafeSize2
        });
        if (!fuzzyNumbersEqual(prevSize2, safeSize2)) {
          deltaRemaining -= safeSize2 - prevSize2;
          nextLayout[index] = safeSize2;
        }
        if (fuzzyNumbersEqual(deltaRemaining, 0))
          break;
        if (delta > 0)
          index--;
        else
          index++;
      }
    }
  }
  const totalSize = nextLayout.reduce((total, size3) => size3 + total, 0);
  if (!fuzzyNumbersEqual(totalSize, 100))
    return prevLayout;
  return nextLayout;
}

// node_modules/reka-ui/dist/utils/pivot.js
function determinePivotIndices(groupId, dragHandleId, panelGroupElement) {
  const index = getResizeHandleElementIndex(
    groupId,
    dragHandleId,
    panelGroupElement
  );
  return index != null ? [index, index + 1] : [-1, -1];
}

// node_modules/reka-ui/dist/utils/rects.js
function intersects(rectOne, rectTwo, strict) {
  {
    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;
  }
}

// node_modules/reka-ui/dist/utils/stackingOrder.js
function compare3(a, b) {
  if (a === b)
    throw new Error("Cannot compare node with itself");
  const ancestors = {
    a: getAncestors(a),
    b: getAncestors(b)
  };
  let common_ancestor;
  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {
    a = ancestors.a.pop();
    b = ancestors.b.pop();
    common_ancestor = a;
  }
  assert(common_ancestor);
  const z_indexes = {
    a: getZIndex(findStackingContext(ancestors.a)),
    b: getZIndex(findStackingContext(ancestors.b))
  };
  if (z_indexes.a === z_indexes.b) {
    const children = common_ancestor.childNodes;
    const furthest_ancestors = {
      a: ancestors.a.at(-1),
      b: ancestors.b.at(-1)
    };
    let i = children.length;
    while (i--) {
      const child = children[i];
      if (child === furthest_ancestors.a)
        return 1;
      if (child === furthest_ancestors.b)
        return -1;
    }
  }
  return Math.sign(z_indexes.a - z_indexes.b);
}
var props = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function isFlexItem(node) {
  const display = getComputedStyle(getParent(node)).display;
  return display === "flex" || display === "inline-flex";
}
function createsStackingContext(node) {
  const style = getComputedStyle(node);
  if (style.position === "fixed")
    return true;
  if (style.zIndex !== "auto" && (style.position !== "static" || isFlexItem(node))) {
    return true;
  }
  if (+style.opacity < 1)
    return true;
  if ("transform" in style && style.transform !== "none")
    return true;
  if ("webkitTransform" in style && style.webkitTransform !== "none")
    return true;
  if ("mixBlendMode" in style && style.mixBlendMode !== "normal")
    return true;
  if ("filter" in style && style.filter !== "none")
    return true;
  if ("webkitFilter" in style && style.webkitFilter !== "none")
    return true;
  if ("isolation" in style && style.isolation === "isolate")
    return true;
  if (props.test(style.willChange))
    return true;
  if (style.webkitOverflowScrolling === "touch")
    return true;
  return false;
}
function findStackingContext(nodes) {
  let i = nodes.length;
  while (i--) {
    const node = nodes[i];
    assert(node);
    if (createsStackingContext(node))
      return node;
  }
  return null;
}
function getZIndex(node) {
  return node && Number(getComputedStyle(node).zIndex) || 0;
}
function getAncestors(node) {
  const ancestors = [];
  while (node) {
    ancestors.push(node);
    node = getParent(node);
  }
  return ancestors;
}
function getParent(node) {
  return node.parentNode instanceof DocumentFragment && node.parentNode?.host || node.parentNode;
}

// node_modules/reka-ui/dist/utils/style.js
var currentCursorStyle = null;
var styleElement = null;
function getCursorStyle(state, constraintFlags) {
  if (constraintFlags) {
    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;
    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;
    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;
    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;
    if (horizontalMin) {
      if (verticalMin)
        return "se-resize";
      else if (verticalMax)
        return "ne-resize";
      else
        return "e-resize";
    } else if (horizontalMax) {
      if (verticalMin)
        return "sw-resize";
      else if (verticalMax)
        return "nw-resize";
      else
        return "w-resize";
    } else if (verticalMin) {
      return "s-resize";
    } else if (verticalMax) {
      return "n-resize";
    }
  }
  switch (state) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function resetGlobalCursorStyle() {
  if (styleElement !== null) {
    document.head.removeChild(styleElement);
    currentCursorStyle = null;
    styleElement = null;
  }
}
function setGlobalCursorStyle(state, constraintFlags) {
  const style = getCursorStyle(state, constraintFlags);
  if (currentCursorStyle === style)
    return;
  currentCursorStyle = style;
  if (styleElement === null) {
    styleElement = document.createElement("style");
    document.head.appendChild(styleElement);
  }
  styleElement.innerHTML = `*{cursor: ${style}!important;}`;
}
function computePanelFlexBoxStyle({
  defaultSize,
  dragState,
  layout,
  panelData,
  panelIndex,
  precision = 3
}) {
  const size3 = layout[panelIndex];
  let flexGrow;
  if (size3 == null) {
    flexGrow = defaultSize !== void 0 ? defaultSize.toPrecision(precision) : "1";
  } else if (panelData.length === 1) {
    flexGrow = "1";
  } else {
    flexGrow = size3.toPrecision(precision);
  }
  return {
    flexBasis: 0,
    flexGrow,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: dragState !== null ? "none" : void 0
  };
}

// node_modules/reka-ui/dist/utils/registry.js
var EXCEEDED_HORIZONTAL_MIN = 1;
var EXCEEDED_HORIZONTAL_MAX = 2;
var EXCEEDED_VERTICAL_MIN = 4;
var EXCEEDED_VERTICAL_MAX = 8;
function getInputType() {
  if (typeof matchMedia === "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
var isCoarsePointer = getInputType() === "coarse";
var intersectingHandles = [];
var isPointerDown = false;
var ownerDocumentCounts = /* @__PURE__ */ new Map();
var panelConstraintFlags = /* @__PURE__ */ new Map();
var registeredResizeHandlers = /* @__PURE__ */ new Set();
function registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {
  const { ownerDocument } = element;
  const data = {
    direction,
    element,
    hitAreaMargins,
    setResizeHandlerState
  };
  const count3 = ownerDocumentCounts.get(ownerDocument) ?? 0;
  ownerDocumentCounts.set(ownerDocument, count3 + 1);
  registeredResizeHandlers.add(data);
  updateListeners();
  return function unregisterResizeHandle() {
    panelConstraintFlags.delete(resizeHandleId);
    registeredResizeHandlers.delete(data);
    const count22 = ownerDocumentCounts.get(ownerDocument) ?? 1;
    ownerDocumentCounts.set(ownerDocument, count22 - 1);
    updateListeners();
    resetGlobalCursorStyle();
    if (count22 === 1)
      ownerDocumentCounts.delete(ownerDocument);
  };
}
function handlePointerDown(event) {
  const { target } = event;
  const { x, y } = getResizeEventCoordinates(event);
  isPointerDown = true;
  recalculateIntersectingHandles({ target, x, y });
  updateListeners();
  if (intersectingHandles.length > 0) {
    updateResizeHandlerStates("down", event);
    event.preventDefault();
  }
}
function handlePointerMove(event) {
  const { x, y } = getResizeEventCoordinates(event);
  if (!isPointerDown) {
    const { target } = event;
    recalculateIntersectingHandles({ target, x, y });
  }
  updateResizeHandlerStates("move", event);
  updateCursor();
  if (intersectingHandles.length > 0)
    event.preventDefault();
}
function handlePointerUp(event) {
  const { target } = event;
  const { x, y } = getResizeEventCoordinates(event);
  panelConstraintFlags.clear();
  isPointerDown = false;
  if (intersectingHandles.length > 0)
    event.preventDefault();
  updateResizeHandlerStates("up", event);
  recalculateIntersectingHandles({ target, x, y });
  updateCursor();
  updateListeners();
}
function recalculateIntersectingHandles({
  target,
  x,
  y
}) {
  intersectingHandles.splice(0);
  let targetElement = null;
  if (target instanceof HTMLElement)
    targetElement = target;
  registeredResizeHandlers.forEach((data) => {
    const { element: dragHandleElement, hitAreaMargins } = data;
    const dragHandleRect = dragHandleElement.getBoundingClientRect();
    const { bottom, left, right, top } = dragHandleRect;
    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;
    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;
    if (eventIntersects) {
      if (targetElement !== null && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) && compare3(targetElement, dragHandleElement) > 0) {
        let currentElement = targetElement;
        let didIntersect = false;
        while (currentElement) {
          if (currentElement.contains(dragHandleElement)) {
            break;
          } else if (intersects(
            currentElement.getBoundingClientRect(),
            dragHandleRect
          )) {
            didIntersect = true;
            break;
          }
          currentElement = currentElement.parentElement;
        }
        if (didIntersect)
          return;
      }
      intersectingHandles.push(data);
    }
  });
}
function reportConstraintsViolation(resizeHandleId, flag) {
  panelConstraintFlags.set(resizeHandleId, flag);
}
function updateCursor() {
  let intersectsHorizontal = false;
  let intersectsVertical = false;
  intersectingHandles.forEach((data) => {
    const { direction } = data;
    if (direction.value === "horizontal")
      intersectsHorizontal = true;
    else
      intersectsVertical = true;
  });
  let constraintFlags = 0;
  panelConstraintFlags.forEach((flag) => {
    constraintFlags |= flag;
  });
  if (intersectsHorizontal && intersectsVertical)
    setGlobalCursorStyle("intersection", constraintFlags);
  else if (intersectsHorizontal)
    setGlobalCursorStyle("horizontal", constraintFlags);
  else if (intersectsVertical)
    setGlobalCursorStyle("vertical", constraintFlags);
  else
    resetGlobalCursorStyle();
}
function updateListeners() {
  ownerDocumentCounts.forEach((_, ownerDocument) => {
    const { body } = ownerDocument;
    body.removeEventListener("contextmenu", handlePointerUp);
    body.removeEventListener("mousedown", handlePointerDown);
    body.removeEventListener("mouseleave", handlePointerMove);
    body.removeEventListener("mousemove", handlePointerMove);
    body.removeEventListener("touchmove", handlePointerMove);
    body.removeEventListener("touchstart", handlePointerDown);
  });
  window.removeEventListener("mouseup", handlePointerUp);
  window.removeEventListener("touchcancel", handlePointerUp);
  window.removeEventListener("touchend", handlePointerUp);
  if (registeredResizeHandlers.size > 0) {
    if (isPointerDown) {
      if (intersectingHandles.length > 0) {
        ownerDocumentCounts.forEach((count3, ownerDocument) => {
          const { body } = ownerDocument;
          if (count3 > 0) {
            body.addEventListener("contextmenu", handlePointerUp);
            body.addEventListener("mouseleave", handlePointerMove);
            body.addEventListener("mousemove", handlePointerMove);
            body.addEventListener("touchmove", handlePointerMove, {
              passive: false
            });
          }
        });
      }
      window.addEventListener("mouseup", handlePointerUp);
      window.addEventListener("touchcancel", handlePointerUp);
      window.addEventListener("touchend", handlePointerUp);
    } else {
      ownerDocumentCounts.forEach((count3, ownerDocument) => {
        const { body } = ownerDocument;
        if (count3 > 0) {
          body.addEventListener("mousedown", handlePointerDown);
          body.addEventListener("mousemove", handlePointerMove);
          body.addEventListener("touchmove", handlePointerMove, {
            passive: false
          });
          body.addEventListener("touchstart", handlePointerDown);
        }
      });
    }
  }
}
function updateResizeHandlerStates(action, event) {
  registeredResizeHandlers.forEach((data) => {
    const { setResizeHandlerState } = data;
    const isActive = intersectingHandles.includes(data);
    setResizeHandlerState(action, isActive, event);
  });
}

// node_modules/reka-ui/dist/utils/validation.js
function validatePanelGroupLayout({
  layout: prevLayout,
  panelConstraints
}) {
  const nextLayout = [...prevLayout];
  const nextLayoutTotalSize = nextLayout.reduce(
    (accumulated, current) => accumulated + current,
    0
  );
  if (nextLayout.length !== panelConstraints.length) {
    throw new Error(
      `Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size3) => `${size3}%`).join(", ")}`
    );
  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100)) {
    {
      console.warn(
        `WARNING: Invalid layout total size: ${nextLayout.map((size3) => `${size3}%`).join(", ")}. Layout normalization will be applied.`
      );
    }
    for (let index = 0; index < panelConstraints.length; index++) {
      const unsafeSize = nextLayout[index];
      assert(unsafeSize != null);
      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;
      nextLayout[index] = safeSize;
    }
  }
  let remainingSize = 0;
  for (let index = 0; index < panelConstraints.length; index++) {
    const unsafeSize = nextLayout[index];
    assert(unsafeSize != null);
    const safeSize = resizePanel({
      panelConstraints,
      panelIndex: index,
      size: unsafeSize
    });
    if (unsafeSize !== safeSize) {
      remainingSize += unsafeSize - safeSize;
      nextLayout[index] = safeSize;
    }
  }
  if (!fuzzyNumbersEqual(remainingSize, 0)) {
    for (let index = 0; index < panelConstraints.length; index++) {
      const prevSize = nextLayout[index];
      assert(prevSize != null);
      const unsafeSize = prevSize + remainingSize;
      const safeSize = resizePanel({
        panelConstraints,
        panelIndex: index,
        size: unsafeSize
      });
      if (prevSize !== safeSize) {
        remainingSize -= safeSize - prevSize;
        nextLayout[index] = safeSize;
        if (fuzzyNumbersEqual(remainingSize, 0))
          break;
      }
    }
  }
  return nextLayout;
}

// node_modules/reka-ui/dist/composables/useWindowSplitterPanelGroupBehavior.js
import { watchEffect as watchEffect21 } from "vue";
function useWindowSplitterPanelGroupBehavior({
  eagerValuesRef,
  groupId,
  layout,
  panelDataArray,
  panelGroupElement,
  setLayout
}) {
  watchEffect21((onCleanup) => {
    const _panelGroupElement = panelGroupElement.value;
    if (!_panelGroupElement)
      return;
    const resizeHandleElements = getResizeHandleElementsForGroup(
      groupId,
      _panelGroupElement
    );
    for (let index = 0; index < panelDataArray.length - 1; index++) {
      const { valueMax, valueMin, valueNow } = calculateAriaValues({
        layout: layout.value,
        panelsArray: panelDataArray,
        pivotIndices: [index, index + 1]
      });
      const resizeHandleElement = resizeHandleElements[index];
      if (resizeHandleElement == null) ;
      else {
        const panelData = panelDataArray[index];
        assert(panelData);
        resizeHandleElement.setAttribute("aria-controls", panelData.id);
        resizeHandleElement.setAttribute(
          "aria-valuemax",
          `${Math.round(valueMax)}`
        );
        resizeHandleElement.setAttribute(
          "aria-valuemin",
          `${Math.round(valueMin)}`
        );
        resizeHandleElement.setAttribute(
          "aria-valuenow",
          valueNow != null ? `${Math.round(valueNow)}` : ""
        );
      }
    }
    onCleanup(() => {
      resizeHandleElements.forEach((resizeHandleElement) => {
        resizeHandleElement.removeAttribute("aria-controls");
        resizeHandleElement.removeAttribute("aria-valuemax");
        resizeHandleElement.removeAttribute("aria-valuemin");
        resizeHandleElement.removeAttribute("aria-valuenow");
      });
    });
  });
  watchEffect21((onCleanup) => {
    const _panelGroupElement = panelGroupElement.value;
    if (!_panelGroupElement)
      return;
    const eagerValues = eagerValuesRef.value;
    assert(eagerValues);
    const { panelDataArray: panelDataArray2 } = eagerValues;
    const groupElement = getPanelGroupElement(groupId, _panelGroupElement);
    assert(groupElement != null, `No group found for id "${groupId}"`);
    const handles = getResizeHandleElementsForGroup(groupId, _panelGroupElement);
    assert(handles);
    const cleanupFunctions = handles.map((handle) => {
      const handleId = handle.getAttribute("data-panel-resize-handle-id");
      assert(handleId);
      const [idBefore, idAfter] = getResizeHandlePanelIds(
        groupId,
        handleId,
        panelDataArray2,
        _panelGroupElement
      );
      if (idBefore == null || idAfter == null)
        return () => {
        };
      const onKeyDown = (event) => {
        if (event.defaultPrevented)
          return;
        switch (event.key) {
          case "Enter": {
            event.preventDefault();
            const index = panelDataArray2.findIndex(
              (panelData) => panelData.id === idBefore
            );
            if (index >= 0) {
              const panelData = panelDataArray2[index];
              assert(panelData);
              const size3 = layout.value[index];
              const {
                collapsedSize = 0,
                collapsible,
                minSize = 0
              } = panelData.constraints;
              if (size3 != null && collapsible) {
                const nextLayout = adjustLayoutByDelta({
                  delta: fuzzyNumbersEqual(size3, collapsedSize) ? minSize - collapsedSize : collapsedSize - size3,
                  layout: layout.value,
                  panelConstraints: panelDataArray2.map(
                    (panelData2) => panelData2.constraints
                  ),
                  pivotIndices: determinePivotIndices(
                    groupId,
                    handleId,
                    _panelGroupElement
                  ),
                  trigger: "keyboard"
                });
                if (layout.value !== nextLayout)
                  setLayout(nextLayout);
              }
            }
            break;
          }
        }
      };
      handle.addEventListener("keydown", onKeyDown);
      return () => {
        handle.removeEventListener("keydown", onKeyDown);
      };
    });
    onCleanup(() => {
      cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());
    });
  });
}

// node_modules/reka-ui/dist/utils/storage.js
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage !== "undefined") {
      storageObject.getItem = (name) => {
        return localStorage.getItem(name);
      };
      storageObject.setItem = (name, value) => {
        localStorage.setItem(name, value);
      };
    } else {
      throw new TypeError("localStorage not supported in this environment");
    }
  } catch (error) {
    console.error(error);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
function getPanelGroupKey(autoSaveId) {
  return `reka:${autoSaveId}`;
}
function getPanelKey(panels) {
  return panels.map((panel) => {
    const { constraints, id, idIsFromProps, order } = panel;
    if (idIsFromProps) {
      return id;
    } else {
      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);
    }
  }).sort((a, b) => a.localeCompare(b)).join(",");
}
function loadSerializedPanelGroupState(autoSaveId, storage) {
  try {
    const panelGroupKey = getPanelGroupKey(autoSaveId);
    const serialized = storage.getItem(panelGroupKey);
    if (serialized) {
      const parsed = JSON.parse(serialized);
      if (typeof parsed === "object" && parsed != null)
        return parsed;
    }
  } catch (error) {
  }
  return null;
}
function loadPanelGroupState(autoSaveId, panels, storage) {
  const state = loadSerializedPanelGroupState(autoSaveId, storage) ?? {};
  const panelKey = getPanelKey(panels);
  return state[panelKey] ?? null;
}
function savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {
  const panelGroupKey = getPanelGroupKey(autoSaveId);
  const panelKey = getPanelKey(panels);
  const state = loadSerializedPanelGroupState(autoSaveId, storage) ?? {};
  state[panelKey] = {
    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),
    layout: sizes
  };
  try {
    storage.setItem(panelGroupKey, JSON.stringify(state));
  } catch (error) {
    console.error(error);
  }
}

// node_modules/reka-ui/dist/Splitter/SplitterGroup.js
var LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;
var defaultStorage = {
  getItem: (name) => {
    initializeDefaultStorage(defaultStorage);
    return defaultStorage.getItem(name);
  },
  setItem: (name, value) => {
    initializeDefaultStorage(defaultStorage);
    defaultStorage.setItem(name, value);
  }
};
var [injectPanelGroupContext, providePanelGroupContext] = createContext("PanelGroup");
var _sfc_main311 = defineComponent316({
  __name: "SplitterGroup",
  props: {
    id: {},
    autoSaveId: { default: null },
    direction: {},
    keyboardResizeBy: { default: 10 },
    storage: { default: () => defaultStorage },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["layout"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const debounceMap = {};
    const { direction } = toRefs45(props2);
    const groupId = useId2(props2.id, "reka-splitter-group");
    const dir = useDirection();
    const { forwardRef, currentElement: panelGroupElementRef } = useForwardExpose();
    const dragState = ref98(null);
    const layout = ref98([]);
    const panelIdToLastNotifiedSizeMapRef = ref98({});
    const panelSizeBeforeCollapseRef = ref98(/* @__PURE__ */ new Map());
    const prevDeltaRef = ref98(0);
    const committedValuesRef = computed106(() => ({
      autoSaveId: props2.autoSaveId,
      direction: props2.direction,
      dragState: dragState.value,
      id: groupId,
      keyboardResizeBy: props2.keyboardResizeBy,
      storage: props2.storage
    }));
    const eagerValuesRef = ref98({
      layout: layout.value,
      panelDataArray: [],
      panelDataArrayChanged: false
    });
    const setLayout = (val) => layout.value = val;
    useWindowSplitterPanelGroupBehavior({
      eagerValuesRef,
      groupId,
      layout,
      panelDataArray: eagerValuesRef.value.panelDataArray,
      setLayout,
      panelGroupElement: panelGroupElementRef
    });
    watchEffect22(() => {
      const { panelDataArray } = eagerValuesRef.value;
      const { autoSaveId } = props2;
      if (autoSaveId) {
        if (layout.value.length === 0 || layout.value.length !== panelDataArray.length)
          return;
        let debouncedSave = debounceMap[autoSaveId];
        if (!debouncedSave) {
          debouncedSave = debounce2(
            savePanelGroupState,
            LOCAL_STORAGE_DEBOUNCE_INTERVAL
          );
          debounceMap[autoSaveId] = debouncedSave;
        }
        const clonedPanelDataArray = [...panelDataArray];
        const clonedPanelSizesBeforeCollapse = new Map(
          panelSizeBeforeCollapseRef.value
        );
        debouncedSave(
          autoSaveId,
          clonedPanelDataArray,
          clonedPanelSizesBeforeCollapse,
          layout.value,
          props2.storage
        );
      }
    });
    function getPanelStyle(panelData, defaultSize) {
      const { panelDataArray } = eagerValuesRef.value;
      const panelIndex = findPanelDataIndex(panelDataArray, panelData);
      return computePanelFlexBoxStyle({
        defaultSize,
        dragState: dragState.value,
        layout: layout.value,
        panelData: panelDataArray,
        panelIndex
      });
    }
    function registerPanel(panelData) {
      const { panelDataArray } = eagerValuesRef.value;
      panelDataArray.push(panelData);
      panelDataArray.sort((panelA, panelB) => {
        const orderA = panelA.order;
        const orderB = panelB.order;
        if (orderA == null && orderB == null)
          return 0;
        else if (orderA == null)
          return -1;
        else if (orderB == null)
          return 1;
        else
          return orderA - orderB;
      });
      eagerValuesRef.value.panelDataArrayChanged = true;
    }
    watch40(() => eagerValuesRef.value.panelDataArrayChanged, () => {
      if (eagerValuesRef.value.panelDataArrayChanged) {
        eagerValuesRef.value.panelDataArrayChanged = false;
        const { autoSaveId, storage } = committedValuesRef.value;
        const { layout: prevLayout, panelDataArray } = eagerValuesRef.value;
        let unsafeLayout = null;
        if (autoSaveId) {
          const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);
          if (state) {
            panelSizeBeforeCollapseRef.value = new Map(
              Object.entries(state.expandToSizes)
            );
            unsafeLayout = state.layout;
          }
        }
        if (unsafeLayout === null) {
          unsafeLayout = calculateUnsafeDefaultLayout({
            panelDataArray
          });
        }
        const nextLayout = validatePanelGroupLayout({
          layout: unsafeLayout,
          panelConstraints: panelDataArray.map(
            (panelData) => panelData.constraints
          )
        });
        if (!areEqual(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.value.layout = nextLayout;
          emits("layout", nextLayout);
          callPanelCallbacks(
            panelDataArray,
            nextLayout,
            panelIdToLastNotifiedSizeMapRef.value
          );
        }
      }
    });
    function registerResizeHandle2(dragHandleId) {
      return function resizeHandler(event) {
        event.preventDefault();
        const panelGroupElement = panelGroupElementRef.value;
        if (!panelGroupElement)
          return () => null;
        const { direction: direction2, dragState: dragState2, id: groupId2, keyboardResizeBy } = committedValuesRef.value;
        const { layout: prevLayout, panelDataArray } = eagerValuesRef.value;
        const { initialLayout } = dragState2 ?? {};
        const pivotIndices = determinePivotIndices(
          groupId2,
          dragHandleId,
          panelGroupElement
        );
        let delta = calculateDeltaPercentage(
          event,
          dragHandleId,
          direction2,
          dragState2,
          keyboardResizeBy,
          panelGroupElement
        );
        if (delta === 0)
          return;
        const isHorizontal = direction2 === "horizontal";
        if (dir.value === "rtl" && isHorizontal)
          delta = -delta;
        const panelConstraints = panelDataArray.map((panelData) => panelData.constraints);
        const nextLayout = adjustLayoutByDelta({
          delta,
          layout: initialLayout ?? prevLayout,
          panelConstraints,
          pivotIndices,
          trigger: isKeyDown(event) ? "keyboard" : "mouse-or-touch"
        });
        const layoutChanged = !compareLayouts(prevLayout, nextLayout);
        if (isMouseEvent2(event) || isTouchEvent(event)) {
          if (prevDeltaRef.value !== delta) {
            prevDeltaRef.value = delta;
            if (!layoutChanged) {
              if (isHorizontal) {
                reportConstraintsViolation(
                  dragHandleId,
                  delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX
                );
              } else {
                reportConstraintsViolation(
                  dragHandleId,
                  delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX
                );
              }
            } else {
              reportConstraintsViolation(dragHandleId, 0);
            }
          }
        }
        if (layoutChanged) {
          setLayout(nextLayout);
          eagerValuesRef.value.layout = nextLayout;
          emits("layout", nextLayout);
          callPanelCallbacks(
            panelDataArray,
            nextLayout,
            panelIdToLastNotifiedSizeMapRef.value
          );
        }
      };
    }
    function resizePanel2(panelData, unsafePanelSize) {
      const { layout: prevLayout, panelDataArray } = eagerValuesRef.value;
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
      const { panelSize, pivotIndices } = panelDataHelper(
        panelDataArray,
        panelData,
        prevLayout
      );
      assert(panelSize != null);
      const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
      const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;
      const nextLayout = adjustLayoutByDelta({
        delta,
        layout: prevLayout,
        panelConstraints: panelConstraintsArray,
        pivotIndices,
        trigger: "imperative-api"
      });
      if (!compareLayouts(prevLayout, nextLayout)) {
        setLayout(nextLayout);
        eagerValuesRef.value.layout = nextLayout;
        emits("layout", nextLayout);
        callPanelCallbacks(
          panelDataArray,
          nextLayout,
          panelIdToLastNotifiedSizeMapRef.value
        );
      }
    }
    function reevaluatePanelConstraints(panelData, prevConstraints) {
      const { layout: layout2, panelDataArray } = eagerValuesRef.value;
      const index = findPanelDataIndex(panelDataArray, panelData);
      panelDataArray[index] = panelData;
      eagerValuesRef.value.panelDataArrayChanged = true;
      const {
        collapsedSize: prevCollapsedSize = 0,
        collapsible: prevCollapsible
      } = prevConstraints;
      const {
        collapsedSize: nextCollapsedSize = 0,
        collapsible: nextCollapsible,
        maxSize: nextMaxSize = 100,
        minSize: nextMinSize = 0
      } = panelData.constraints;
      const { panelSize: prevPanelSize } = panelDataHelper(
        panelDataArray,
        panelData,
        layout2
      );
      if (prevPanelSize === null) {
        return;
      }
      if (prevCollapsible && nextCollapsible && prevPanelSize === prevCollapsedSize) {
        if (prevCollapsedSize !== nextCollapsedSize) {
          resizePanel2(panelData, nextCollapsedSize);
        }
      } else if (prevPanelSize < nextMinSize) {
        resizePanel2(panelData, nextMinSize);
      } else if (prevPanelSize > nextMaxSize) {
        resizePanel2(panelData, nextMaxSize);
      }
    }
    function startDragging(dragHandleId, event) {
      const { direction: direction2 } = committedValuesRef.value;
      const { layout: layout2 } = eagerValuesRef.value;
      if (!panelGroupElementRef.value)
        return;
      const handleElement = getResizeHandleElement(
        dragHandleId,
        panelGroupElementRef.value
      );
      assert(handleElement);
      const initialCursorPosition = getResizeEventCursorPosition(
        direction2,
        event
      );
      dragState.value = {
        dragHandleId,
        dragHandleRect: handleElement.getBoundingClientRect(),
        initialCursorPosition,
        initialLayout: layout2
      };
    }
    function stopDragging() {
      dragState.value = null;
    }
    function unregisterPanel(panelData) {
      const { panelDataArray } = eagerValuesRef.value;
      const index = findPanelDataIndex(panelDataArray, panelData);
      if (index >= 0) {
        panelDataArray.splice(index, 1);
        delete panelIdToLastNotifiedSizeMapRef.value[panelData.id];
        eagerValuesRef.value.panelDataArrayChanged = true;
      }
    }
    function collapsePanel(panelData) {
      const { layout: prevLayout, panelDataArray } = eagerValuesRef.value;
      if (panelData.constraints.collapsible) {
        const panelConstraintsArray = panelDataArray.map(
          (panelData2) => panelData2.constraints
        );
        const {
          collapsedSize = 0,
          panelSize,
          pivotIndices
        } = panelDataHelper(panelDataArray, panelData, prevLayout);
        assert(
          panelSize != null,
          `Panel size not found for panel "${panelData.id}"`
        );
        if (panelSize !== collapsedSize) {
          panelSizeBeforeCollapseRef.value.set(panelData.id, panelSize);
          const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
          const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;
          const nextLayout = adjustLayoutByDelta({
            delta,
            layout: prevLayout,
            panelConstraints: panelConstraintsArray,
            pivotIndices,
            trigger: "imperative-api"
          });
          if (!compareLayouts(prevLayout, nextLayout)) {
            setLayout(nextLayout);
            eagerValuesRef.value.layout = nextLayout;
            emits("layout", nextLayout);
            callPanelCallbacks(
              panelDataArray,
              nextLayout,
              panelIdToLastNotifiedSizeMapRef.value
            );
          }
        }
      }
    }
    function expandPanel(panelData) {
      const { layout: prevLayout, panelDataArray } = eagerValuesRef.value;
      if (panelData.constraints.collapsible) {
        const panelConstraintsArray = panelDataArray.map(
          (panelData2) => panelData2.constraints
        );
        const {
          collapsedSize = 0,
          panelSize,
          minSize = 0,
          pivotIndices
        } = panelDataHelper(panelDataArray, panelData, prevLayout);
        if (panelSize === collapsedSize) {
          const prevPanelSize = panelSizeBeforeCollapseRef.value.get(
            panelData.id
          );
          const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;
          const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
          const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;
          const nextLayout = adjustLayoutByDelta({
            delta,
            layout: prevLayout,
            panelConstraints: panelConstraintsArray,
            pivotIndices,
            trigger: "imperative-api"
          });
          if (!compareLayouts(prevLayout, nextLayout)) {
            setLayout(nextLayout);
            eagerValuesRef.value.layout = nextLayout;
            emits("layout", nextLayout);
            callPanelCallbacks(
              panelDataArray,
              nextLayout,
              panelIdToLastNotifiedSizeMapRef.value
            );
          }
        }
      }
    }
    function getPanelSize(panelData) {
      const { layout: layout2, panelDataArray } = eagerValuesRef.value;
      const { panelSize } = panelDataHelper(panelDataArray, panelData, layout2);
      assert(
        panelSize != null,
        `Panel size not found for panel "${panelData.id}"`
      );
      return panelSize;
    }
    function isPanelCollapsed(panelData) {
      const { layout: layout2, panelDataArray } = eagerValuesRef.value;
      const {
        collapsedSize = 0,
        collapsible,
        panelSize
      } = panelDataHelper(panelDataArray, panelData, layout2);
      if (!collapsible)
        return false;
      if (panelSize === void 0) {
        return panelData.constraints.defaultSize === panelData.constraints.collapsedSize;
      } else {
        return panelSize === collapsedSize;
      }
    }
    function isPanelExpanded(panelData) {
      const { layout: layout2, panelDataArray } = eagerValuesRef.value;
      const {
        collapsedSize = 0,
        collapsible,
        panelSize
      } = panelDataHelper(panelDataArray, panelData, layout2);
      assert(
        panelSize != null,
        `Panel size not found for panel "${panelData.id}"`
      );
      return !collapsible || panelSize > collapsedSize;
    }
    providePanelGroupContext({
      direction,
      dragState: dragState.value,
      groupId,
      reevaluatePanelConstraints,
      registerPanel,
      registerResizeHandle: registerResizeHandle2,
      resizePanel: resizePanel2,
      startDragging,
      stopDragging,
      unregisterPanel,
      panelGroupElement: panelGroupElementRef,
      collapsePanel,
      expandPanel,
      isPanelCollapsed,
      isPanelExpanded,
      getPanelSize,
      getPanelStyle
    });
    function findPanelDataIndex(panelDataArray, panelData) {
      return panelDataArray.findIndex(
        (prevPanelData) => prevPanelData === panelData || prevPanelData.id === panelData.id
      );
    }
    function panelDataHelper(panelDataArray, panelData, layout2) {
      const panelIndex = findPanelDataIndex(panelDataArray, panelData);
      const isLastPanel = panelIndex === panelDataArray.length - 1;
      const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];
      const panelSize = layout2[panelIndex];
      return {
        ...panelData.constraints,
        panelSize,
        pivotIndices
      };
    }
    return (_ctx, _cache) => {
      return openBlock307(), createBlock298(unref309(Primitive), {
        ref: unref309(forwardRef),
        as: _ctx.as,
        "as-child": _ctx.asChild,
        style: normalizeStyle14({
          display: "flex",
          flexDirection: unref309(direction) === "horizontal" ? "row" : "column",
          height: "100%",
          overflow: "hidden",
          width: "100%"
        }),
        "data-panel-group": "",
        "data-orientation": unref309(direction),
        "data-panel-group-id": unref309(groupId)
      }, {
        default: withCtx303(() => [
          renderSlot308(_ctx.$slots, "default", { layout: layout.value })
        ]),
        _: 3
      }, 8, ["as", "as-child", "style", "data-orientation", "data-panel-group-id"]);
    };
  }
});

// node_modules/reka-ui/dist/Splitter/SplitterPanel.js
import { defineComponent as defineComponent317, computed as computed107, watch as watch41, onMounted as onMounted47, onUnmounted as onUnmounted20, createBlock as createBlock299, openBlock as openBlock308, unref as unref310, normalizeStyle as normalizeStyle15, withCtx as withCtx304, renderSlot as renderSlot309 } from "vue";
var _sfc_main312 = defineComponent317({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {},
    collapsible: { type: Boolean },
    defaultSize: {},
    id: {},
    maxSize: {},
    minSize: {},
    order: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["collapse", "expand", "resize"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const panelGroupContext = injectPanelGroupContext();
    if (panelGroupContext === null) {
      throw new Error(
        "SplitterPanel components must be rendered within a SplitterGroup container"
      );
    }
    const { collapsePanel, expandPanel, getPanelSize, getPanelStyle, isPanelCollapsed, resizePanel: resizePanel2, groupId, reevaluatePanelConstraints, registerPanel, unregisterPanel } = panelGroupContext;
    const panelId = useId2(props2.id, "reka-splitter-panel");
    const panelDataRef = computed107(() => ({
      callbacks: {
        onCollapse: () => emits("collapse"),
        onExpand: () => emits("expand"),
        onResize: (...args) => emits("resize", ...args)
      },
      constraints: {
        collapsedSize: props2.collapsedSize && Number.parseFloat(props2.collapsedSize.toFixed(PRECISION)),
        collapsible: props2.collapsible,
        defaultSize: props2.defaultSize,
        /** Panel id (unique within group); falls back to useId when not provided */
        /** Panel id (unique within group); falls back to useId when not provided */
        maxSize: props2.maxSize,
        minSize: props2.minSize
      },
      id: panelId,
      idIsFromProps: props2.id !== void 0,
      order: props2.order
    }));
    watch41(() => panelDataRef.value.constraints, (constraints, prevConstraints) => {
      if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {
        reevaluatePanelConstraints(panelDataRef.value, prevConstraints);
      }
    }, { deep: true });
    onMounted47(() => {
      const panelData = panelDataRef.value;
      registerPanel(panelData);
      onUnmounted20(() => {
        unregisterPanel(panelData);
      });
    });
    const style = computed107(() => getPanelStyle(panelDataRef.value, props2.defaultSize));
    const isCollapsed = computed107(() => isPanelCollapsed(panelDataRef.value));
    const isExpanded = computed107(() => !isCollapsed.value);
    __expose({
      /** If panel is `collapsible`, collapse it fully. */
      collapse: () => {
        collapsePanel(panelDataRef.value);
      },
      /** If panel is currently collapsed, expand it to its most recent size. */
      expand: () => {
        expandPanel(panelDataRef.value);
      },
      /** Gets the current size of the panel as a percentage (1 - 100). */
      getSize() {
        return getPanelSize(panelDataRef.value);
      },
      /** Resize panel to the specified percentage (1 - 100). */
      resize: (size3) => {
        resizePanel2(panelDataRef.value, size3);
      },
      /** Returns `true` if the panel is currently collapsed */
      isCollapsed,
      /** Returns `true` if the panel is currently not collapsed */
      isExpanded
    });
    return (_ctx, _cache) => {
      return openBlock308(), createBlock299(unref310(Primitive), {
        id: unref310(panelId),
        style: normalizeStyle15(style.value),
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-panel": "",
        "data-panel-collapsible": _ctx.collapsible || void 0,
        "data-panel-group-id": unref310(groupId),
        "data-panel-id": unref310(panelId),
        "data-panel-size": Number.parseFloat(`${style.value.flexGrow}`).toFixed(1),
        "data-state": _ctx.collapsible ? isCollapsed.value ? "collapsed" : "expanded" : void 0
      }, {
        default: withCtx304(() => [
          renderSlot309(_ctx.$slots, "default", {
            isCollapsed: isCollapsed.value,
            isExpanded: isExpanded.value
          })
        ]),
        _: 3
      }, 8, ["id", "style", "as", "as-child", "data-panel-collapsible", "data-panel-group-id", "data-panel-id", "data-panel-size", "data-state"]);
    };
  }
});

// node_modules/reka-ui/dist/Splitter/SplitterResizeHandle.js
import { defineComponent as defineComponent318, toRefs as toRefs46, ref as ref99, watch as watch42, watchEffect as watchEffect24, createBlock as createBlock300, openBlock as openBlock309, unref as unref311, withCtx as withCtx305, renderSlot as renderSlot310 } from "vue";

// node_modules/reka-ui/dist/composables/useWindowSplitterBehavior.js
import { watchEffect as watchEffect23 } from "vue";
function useWindowSplitterResizeHandlerBehavior({
  disabled,
  handleId,
  resizeHandler,
  panelGroupElement
}) {
  watchEffect23((onCleanup) => {
    const _panelGroupElement = panelGroupElement.value;
    if (disabled.value || resizeHandler.value === null || _panelGroupElement === null)
      return;
    const handleElement = getResizeHandleElement(handleId, _panelGroupElement);
    if (handleElement == null)
      return;
    const onKeyDown = (event) => {
      if (event.defaultPrevented)
        return;
      switch (event.key) {
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "End":
        case "Home": {
          event.preventDefault();
          resizeHandler.value?.(event);
          break;
        }
        case "F6": {
          event.preventDefault();
          const groupId = handleElement.getAttribute("data-panel-group-id");
          assert(groupId);
          const handles = getResizeHandleElementsForGroup(
            groupId,
            _panelGroupElement
          );
          const index = getResizeHandleElementIndex(
            groupId,
            handleId,
            _panelGroupElement
          );
          assert(index !== null);
          const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;
          const nextHandle = handles[nextIndex];
          nextHandle.focus();
          break;
        }
      }
    };
    handleElement.addEventListener("keydown", onKeyDown);
    onCleanup(() => {
      handleElement.removeEventListener("keydown", onKeyDown);
    });
  });
}

// node_modules/reka-ui/dist/Splitter/SplitterResizeHandle.js
var _sfc_main313 = defineComponent318({
  __name: "SplitterResizeHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: { default: 0 },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["dragging"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const { disabled } = toRefs46(props2);
    const panelGroupContext = injectPanelGroupContext();
    if (panelGroupContext === null) {
      throw new Error(
        "PanelResizeHandle components must be rendered within a PanelGroup container"
      );
    }
    const {
      direction,
      groupId,
      registerResizeHandle: registerResizeHandleWithParentGroup,
      startDragging,
      stopDragging,
      panelGroupElement
    } = panelGroupContext;
    const resizeHandleId = useId2(props2.id, "reka-splitter-resize-handle");
    const state = ref99("inactive");
    const isFocused = ref99(false);
    const resizeHandler = ref99(null);
    watch42(disabled, () => {
      if (!isBrowser)
        return;
      if (disabled.value)
        resizeHandler.value = null;
      else
        resizeHandler.value = registerResizeHandleWithParentGroup(resizeHandleId);
    }, { immediate: true });
    watchEffect24((onCleanup) => {
      if (disabled.value || resizeHandler.value === null)
        return;
      const element = currentElement.value;
      if (!element)
        return;
      assert(element);
      const setResizeHandlerState = (action, isActive, event) => {
        if (isActive) {
          switch (action) {
            case "down": {
              state.value = "drag";
              startDragging(resizeHandleId, event);
              emits("dragging", true);
              break;
            }
            case "move": {
              if (state.value !== "drag")
                state.value = "hover";
              resizeHandler.value?.(event);
              break;
            }
            case "up": {
              state.value = "hover";
              stopDragging();
              emits("dragging", false);
              break;
            }
          }
        } else {
          state.value = "inactive";
        }
      };
      onCleanup(registerResizeHandle(
        resizeHandleId,
        element,
        direction,
        {
          // Coarse inputs (e.g. finger/touch)
          coarse: props2.hitAreaMargins?.coarse ?? 15,
          // Fine inputs (e.g. mouse)
          fine: props2.hitAreaMargins?.fine ?? 5
        },
        setResizeHandlerState
      ));
    });
    useWindowSplitterResizeHandlerBehavior({
      disabled,
      resizeHandler,
      handleId: resizeHandleId,
      panelGroupElement
    });
    return (_ctx, _cache) => {
      return openBlock309(), createBlock300(unref311(Primitive), {
        id: unref311(resizeHandleId),
        ref: unref311(forwardRef),
        style: {
          touchAction: "none",
          userSelect: "none"
        },
        as: _ctx.as,
        "as-child": _ctx.asChild,
        role: "separator",
        "data-resize-handle": "",
        tabindex: _ctx.tabindex,
        "data-state": state.value,
        "data-disabled": unref311(disabled) ? "" : void 0,
        "data-orientation": unref311(direction),
        "data-panel-group-id": unref311(groupId),
        "data-resize-handle-active": state.value === "drag" ? "pointer" : isFocused.value ? "keyboard" : void 0,
        "data-resize-handle-state": state.value,
        "data-panel-resize-handle-enabled": !unref311(disabled),
        "data-panel-resize-handle-id": unref311(resizeHandleId),
        onBlur: _cache[0] || (_cache[0] = ($event) => isFocused.value = false),
        onFocus: _cache[1] || (_cache[1] = ($event) => isFocused.value = false)
      }, {
        default: withCtx305(() => [
          renderSlot310(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "as", "as-child", "tabindex", "data-state", "data-disabled", "data-orientation", "data-panel-group-id", "data-resize-handle-active", "data-resize-handle-state", "data-panel-resize-handle-enabled", "data-panel-resize-handle-id"]);
    };
  }
});

// node_modules/reka-ui/dist/Stepper/StepperDescription.js
import { defineComponent as defineComponent321, createBlock as createBlock303, openBlock as openBlock312, unref as unref314, mergeProps as mergeProps141, withCtx as withCtx308, renderSlot as renderSlot313 } from "vue";

// node_modules/reka-ui/dist/Stepper/StepperItem.js
import { defineComponent as defineComponent320, toRefs as toRefs48, computed as computed109, createBlock as createBlock302, openBlock as openBlock311, unref as unref313, withCtx as withCtx307, renderSlot as renderSlot312 } from "vue";

// node_modules/reka-ui/dist/Stepper/StepperRoot.js
import { defineComponent as defineComponent319, toRefs as toRefs47, ref as ref100, computed as computed108, watch as watch43, nextTick as nextTick29, createBlock as createBlock301, openBlock as openBlock310, unref as unref312, withCtx as withCtx306, renderSlot as renderSlot311, createElementVNode as createElementVNode5, toDisplayString as toDisplayString13 } from "vue";
var _hoisted_17 = {
  "aria-live": "polite",
  "aria-atomic": "true",
  role: "status",
  style: {
    transform: "translateX(-100%)",
    position: "absolute",
    pointerEvents: "none",
    opacity: 0,
    margin: 0
  }
};
var [injectStepperRootContext, provideStepperRootContext] = createContext("StepperRoot");
var _sfc_main314 = defineComponent319({
  __name: "StepperRoot",
  props: {
    defaultValue: { default: 1 },
    orientation: { default: "horizontal" },
    dir: {},
    modelValue: {},
    linear: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { dir: propDir, orientation: propOrientation, linear } = toRefs47(props2);
    const dir = useDirection(propDir);
    useForwardExpose();
    const totalStepperItems = ref100(/* @__PURE__ */ new Set());
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const totalStepperItemsArray = computed108(() => Array.from(totalStepperItems.value));
    const isFirstStep = computed108(() => modelValue.value === 1);
    const isLastStep = computed108(() => modelValue.value === totalStepperItemsArray.value.length);
    const totalSteps = computed108(() => totalStepperItems.value.size);
    function goToStep(step) {
      if (step > totalSteps.value)
        return;
      if (step < 1)
        return;
      if (totalStepperItems.value.size && !!totalStepperItemsArray.value[step] && !!totalStepperItemsArray.value[step].getAttribute("disabled"))
        return;
      if (linear.value) {
        if (step > (modelValue.value ?? 1) + 1)
          return;
      }
      modelValue.value = step;
    }
    const nextStepperItem = ref100(null);
    const prevStepperItem = ref100(null);
    const isNextDisabled = computed108(() => nextStepperItem.value ? nextStepperItem.value.getAttribute("disabled") === "" : true);
    const isPrevDisabled = computed108(() => prevStepperItem.value ? prevStepperItem.value.getAttribute("disabled") === "" : true);
    watch43(modelValue, async () => {
      await nextTick29(() => {
        nextStepperItem.value = totalStepperItemsArray.value.length && modelValue.value < totalStepperItemsArray.value.length ? totalStepperItemsArray.value[modelValue.value] : null;
        prevStepperItem.value = totalStepperItemsArray.value.length && modelValue.value > 1 ? totalStepperItemsArray.value[modelValue.value - 2] : null;
      });
    });
    watch43(totalStepperItemsArray, async () => {
      await nextTick29(() => {
        nextStepperItem.value = totalStepperItemsArray.value.length && modelValue.value < totalStepperItemsArray.value.length ? totalStepperItemsArray.value[modelValue.value] : null;
        prevStepperItem.value = totalStepperItemsArray.value.length && modelValue.value > 1 ? totalStepperItemsArray.value[modelValue.value - 2] : null;
      });
    });
    provideStepperRootContext({
      modelValue,
      changeModelValue: (value) => {
        modelValue.value = value;
      },
      orientation: propOrientation,
      dir,
      linear,
      totalStepperItems
    });
    return (_ctx, _cache) => {
      return openBlock310(), createBlock301(unref312(Primitive), {
        role: "group",
        "aria-label": "progress",
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-linear": unref312(linear) ? "" : void 0,
        "data-orientation": _ctx.orientation
      }, {
        default: withCtx306(() => [
          renderSlot311(_ctx.$slots, "default", {
            modelValue: unref312(modelValue),
            totalSteps: totalStepperItems.value.size,
            isNextDisabled: isNextDisabled.value,
            isPrevDisabled: isPrevDisabled.value,
            isFirstStep: isFirstStep.value,
            isLastStep: isLastStep.value,
            goToStep,
            nextStep: () => goToStep((unref312(modelValue) ?? 1) + 1),
            prevStep: () => goToStep((unref312(modelValue) ?? 1) - 1)
          }),
          createElementVNode5("div", _hoisted_17, " Step " + toDisplayString13(unref312(modelValue)) + " of " + toDisplayString13(totalStepperItems.value.size), 1)
        ]),
        _: 3
      }, 8, ["as", "as-child", "data-linear", "data-orientation"]);
    };
  }
});

// node_modules/reka-ui/dist/Stepper/StepperItem.js
var [injectStepperItemContext, provideStepperItemContext] = createContext("StepperItem");
var _sfc_main315 = defineComponent320({
  __name: "StepperItem",
  props: {
    step: {},
    disabled: { type: Boolean, default: false },
    completed: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { disabled, step, completed } = toRefs48(props2);
    const { forwardRef } = useForwardExpose();
    const rootContext = injectStepperRootContext();
    const titleId = useId2(void 0, "reka-stepper-item-title");
    const descriptionId = useId2(void 0, "reka-stepper-item-description");
    const itemState = computed109(() => {
      if (completed.value)
        return "completed";
      if (rootContext.modelValue.value === step.value)
        return "active";
      if (rootContext.modelValue.value > step.value)
        return "completed";
      return "inactive";
    });
    const isFocusable = computed109(() => {
      if (disabled.value)
        return false;
      if (rootContext.linear.value)
        return step.value <= rootContext.modelValue.value || step.value === rootContext.modelValue.value + 1;
      return true;
    });
    provideStepperItemContext({
      titleId,
      descriptionId,
      state: itemState,
      disabled,
      step,
      isFocusable
    });
    return (_ctx, _cache) => {
      return openBlock311(), createBlock302(unref313(Primitive), {
        ref: unref313(forwardRef),
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "aria-current": itemState.value === "active" ? "true" : void 0,
        "data-state": itemState.value,
        disabled: unref313(disabled) || !isFocusable.value ? "" : void 0,
        "data-disabled": unref313(disabled) || !isFocusable.value ? "" : void 0,
        "data-orientation": unref313(rootContext).orientation.value
      }, {
        default: withCtx307(() => [
          renderSlot312(_ctx.$slots, "default", { state: itemState.value })
        ]),
        _: 3
      }, 8, ["as", "as-child", "aria-current", "data-state", "disabled", "data-disabled", "data-orientation"]);
    };
  }
});

// node_modules/reka-ui/dist/Stepper/StepperDescription.js
var _sfc_main316 = defineComponent321({
  __name: "StepperDescription",
  props: {
    asChild: { type: Boolean },
    as: { default: "p" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const itemContext = injectStepperItemContext();
    return (_ctx, _cache) => {
      return openBlock312(), createBlock303(unref314(Primitive), mergeProps141(props2, {
        id: unref314(itemContext).descriptionId
      }), {
        default: withCtx308(() => [
          renderSlot313(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]);
    };
  }
});

// node_modules/reka-ui/dist/Stepper/StepperIndicator.js
import { defineComponent as defineComponent322, createBlock as createBlock304, openBlock as openBlock313, unref as unref315, normalizeProps as normalizeProps101, guardReactiveProps as guardReactiveProps97, withCtx as withCtx309, renderSlot as renderSlot314, createTextVNode as createTextVNode28, toDisplayString as toDisplayString14 } from "vue";
var _sfc_main317 = defineComponent322({
  __name: "StepperIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const itemContext = injectStepperItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock313(), createBlock304(unref315(Primitive), normalizeProps101(guardReactiveProps97(props2)), {
        default: withCtx309(() => [
          renderSlot314(_ctx.$slots, "default", {
            step: unref315(itemContext).step.value
          }, () => [
            createTextVNode28(" Step " + toDisplayString14(unref315(itemContext).step.value), 1)
          ])
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Stepper/StepperSeparator.js
import { defineComponent as defineComponent323, createBlock as createBlock305, openBlock as openBlock314, unref as unref316, mergeProps as mergeProps142, withCtx as withCtx310, renderSlot as renderSlot315 } from "vue";
var _sfc_main318 = defineComponent323({
  __name: "StepperSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectStepperRootContext();
    const itemContext = injectStepperItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock314(), createBlock305(unref316(_sfc_main302), mergeProps142(props2, {
        decorative: "",
        orientation: unref316(rootContext).orientation.value,
        "data-state": unref316(itemContext).state.value
      }), {
        default: withCtx310(() => [
          renderSlot315(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["orientation", "data-state"]);
    };
  }
});

// node_modules/reka-ui/dist/Stepper/StepperTitle.js
import { defineComponent as defineComponent324, createBlock as createBlock306, openBlock as openBlock315, unref as unref317, mergeProps as mergeProps143, withCtx as withCtx311, renderSlot as renderSlot316 } from "vue";
var _sfc_main319 = defineComponent324({
  __name: "StepperTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h4" }
  },
  setup(__props) {
    const props2 = __props;
    const itemContext = injectStepperItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock315(), createBlock306(unref317(Primitive), mergeProps143(props2, {
        id: unref317(itemContext).titleId
      }), {
        default: withCtx311(() => [
          renderSlot316(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]);
    };
  }
});

// node_modules/reka-ui/dist/Stepper/StepperTrigger.js
import { defineComponent as defineComponent325, computed as computed110, onMounted as onMounted48, onUnmounted as onUnmounted21, createBlock as createBlock307, openBlock as openBlock316, unref as unref318, withKeys as withKeys20, withModifiers as withModifiers20, withCtx as withCtx312, renderSlot as renderSlot317 } from "vue";
var _sfc_main320 = defineComponent325({
  __name: "StepperTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const rootContext = injectStepperRootContext();
    const itemContext = injectStepperItemContext();
    const kbd = useKbd();
    const stepperItems = computed110(() => Array.from(rootContext.totalStepperItems.value));
    function handleMouseDown(event) {
      if (itemContext.disabled.value)
        return;
      if (rootContext.linear.value) {
        if (itemContext.step.value <= rootContext.modelValue.value || itemContext.step.value === rootContext.modelValue.value + 1) {
          if (event.ctrlKey === false) {
            rootContext.changeModelValue(itemContext.step.value);
            return;
          }
        }
      } else {
        if (event.ctrlKey === false) {
          rootContext.changeModelValue(itemContext.step.value);
          return;
        }
      }
      event.preventDefault();
    }
    function handleKeyDown(event) {
      event.preventDefault();
      if (itemContext.disabled.value)
        return;
      if ((event.key === kbd.ENTER || event.key === kbd.SPACE) && !event.ctrlKey && !event.shiftKey)
        rootContext.changeModelValue(itemContext.step.value);
      if ([kbd.ARROW_LEFT, kbd.ARROW_RIGHT, kbd.ARROW_UP, kbd.ARROW_DOWN].includes(event.key)) {
        useArrowNavigation(event, getActiveElement(), void 0, {
          itemsArray: stepperItems.value,
          focus: true,
          loop: false,
          arrowKeyOptions: rootContext.orientation.value,
          dir: rootContext.dir.value
        });
      }
    }
    const { forwardRef, currentElement } = useForwardExpose();
    onMounted48(() => {
      rootContext.totalStepperItems.value.add(currentElement.value);
    });
    onUnmounted21(() => {
      rootContext.totalStepperItems.value.delete(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock316(), createBlock307(unref318(Primitive), {
        ref: unref318(forwardRef),
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-state": unref318(itemContext).state.value,
        disabled: unref318(itemContext).disabled.value || !unref318(itemContext).isFocusable.value ? "" : void 0,
        "data-disabled": unref318(itemContext).disabled.value || !unref318(itemContext).isFocusable.value ? "" : void 0,
        "data-orientation": unref318(rootContext).orientation.value,
        tabindex: unref318(itemContext).isFocusable.value ? 0 : -1,
        "aria-describedby": unref318(itemContext).descriptionId,
        "aria-labelledby": unref318(itemContext).titleId,
        onMousedown: withModifiers20(handleMouseDown, ["left"]),
        onKeydown: withKeys20(handleKeyDown, ["enter", "space", "left", "right", "up", "down"])
      }, {
        default: withCtx312(() => [
          renderSlot317(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child", "data-state", "disabled", "data-disabled", "data-orientation", "tabindex", "aria-describedby", "aria-labelledby"]);
    };
  }
});

// node_modules/reka-ui/dist/Switch/SwitchRoot.js
import { defineComponent as defineComponent326, toRefs as toRefs49, computed as computed111, createBlock as createBlock308, openBlock as openBlock317, unref as unref319, mergeProps as mergeProps144, withKeys as withKeys21, withModifiers as withModifiers21, withCtx as withCtx313, renderSlot as renderSlot318, createCommentVNode as createCommentVNode28 } from "vue";
var [injectSwitchRootContext, provideSwitchRootContext] = createContext("SwitchRoot");
var _sfc_main321 = defineComponent326({
  __name: "SwitchRoot",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null], default: void 0 },
    disabled: { type: Boolean },
    id: {},
    value: { default: "on" },
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const { disabled } = toRefs49(props2);
    const modelValue = useVModel(props2, "modelValue", emit, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    function toggleCheck() {
      if (disabled.value)
        return;
      modelValue.value = !modelValue.value;
    }
    const { forwardRef, currentElement } = useForwardExpose();
    const isFormControl = useFormControl(currentElement);
    const ariaLabel = computed111(() => props2.id && currentElement.value ? document.querySelector(`[for="${props2.id}"]`)?.innerText : void 0);
    provideSwitchRootContext({
      modelValue,
      toggleCheck,
      disabled
    });
    return (_ctx, _cache) => {
      return openBlock317(), createBlock308(unref319(Primitive), mergeProps144(_ctx.$attrs, {
        id: _ctx.id,
        ref: unref319(forwardRef),
        role: "switch",
        type: _ctx.as === "button" ? "button" : void 0,
        value: _ctx.value,
        "aria-label": _ctx.$attrs["aria-label"] || ariaLabel.value,
        "aria-checked": unref319(modelValue),
        "aria-required": _ctx.required,
        "data-state": unref319(modelValue) ? "checked" : "unchecked",
        "data-disabled": unref319(disabled) ? "" : void 0,
        "as-child": _ctx.asChild,
        as: _ctx.as,
        disabled: unref319(disabled),
        onClick: toggleCheck,
        onKeydown: withKeys21(withModifiers21(toggleCheck, ["prevent"]), ["enter"])
      }), {
        default: withCtx313(() => [
          renderSlot318(_ctx.$slots, "default", { modelValue: unref319(modelValue) }),
          unref319(isFormControl) && _ctx.name ? (openBlock317(), createBlock308(unref319(_sfc_main52), {
            key: 0,
            type: "checkbox",
            name: _ctx.name,
            disabled: unref319(disabled),
            required: _ctx.required,
            value: _ctx.value,
            checked: !!unref319(modelValue)
          }, null, 8, ["name", "disabled", "required", "value", "checked"])) : createCommentVNode28("", true)
        ]),
        _: 3
      }, 16, ["id", "type", "value", "aria-label", "aria-checked", "aria-required", "data-state", "data-disabled", "as-child", "as", "disabled", "onKeydown"]);
    };
  }
});

// node_modules/reka-ui/dist/Switch/SwitchThumb.js
import { defineComponent as defineComponent327, createBlock as createBlock309, openBlock as openBlock318, unref as unref320, withCtx as withCtx314, renderSlot as renderSlot319 } from "vue";
var _sfc_main322 = defineComponent327({
  __name: "SwitchThumb",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const rootContext = injectSwitchRootContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock318(), createBlock309(unref320(Primitive), {
        "data-state": unref320(rootContext).modelValue?.value ? "checked" : "unchecked",
        "data-disabled": unref320(rootContext).disabled.value ? "" : void 0,
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx314(() => [
          renderSlot319(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["data-state", "data-disabled", "as-child", "as"]);
    };
  }
});

// node_modules/reka-ui/dist/Tabs/TabsContent.js
import { defineComponent as defineComponent329, computed as computed112, ref as ref102, onMounted as onMounted49, createBlock as createBlock311, openBlock as openBlock320, unref as unref322, withCtx as withCtx316, createVNode as createVNode58, normalizeStyle as normalizeStyle16, renderSlot as renderSlot321, createCommentVNode as createCommentVNode29 } from "vue";

// node_modules/reka-ui/dist/Tabs/utils.js
function makeTriggerId2(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId2(baseId, value) {
  return `${baseId}-content-${value}`;
}

// node_modules/reka-ui/dist/Tabs/TabsRoot.js
import { defineComponent as defineComponent328, toRefs as toRefs50, ref as ref101, createBlock as createBlock310, openBlock as openBlock319, unref as unref321, withCtx as withCtx315, renderSlot as renderSlot320 } from "vue";
var [injectTabsRootContext, provideTabsRootContext] = createContext("TabsRoot");
var _sfc_main323 = defineComponent328({
  __name: "TabsRoot",
  props: {
    defaultValue: {},
    orientation: { default: "horizontal" },
    dir: {},
    activationMode: { default: "automatic" },
    modelValue: {},
    unmountOnHide: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { orientation, unmountOnHide, dir: propDir } = toRefs50(props2);
    const dir = useDirection(propDir);
    useForwardExpose();
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const tabsList = ref101();
    provideTabsRootContext({
      modelValue,
      changeModelValue: (value) => {
        modelValue.value = value;
      },
      orientation,
      dir,
      unmountOnHide,
      activationMode: props2.activationMode,
      baseId: useId2(void 0, "reka-tabs"),
      tabsList
    });
    return (_ctx, _cache) => {
      return openBlock319(), createBlock310(unref321(Primitive), {
        dir: unref321(dir),
        "data-orientation": unref321(orientation),
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx315(() => [
          renderSlot320(_ctx.$slots, "default", { modelValue: unref321(modelValue) })
        ]),
        _: 3
      }, 8, ["dir", "data-orientation", "as-child", "as"]);
    };
  }
});

// node_modules/reka-ui/dist/Tabs/TabsContent.js
var _sfc_main324 = defineComponent329({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const rootContext = injectTabsRootContext();
    const triggerId = computed112(() => makeTriggerId2(rootContext.baseId, props2.value));
    const contentId = computed112(() => makeContentId2(rootContext.baseId, props2.value));
    const isSelected = computed112(() => props2.value === rootContext.modelValue.value);
    const isMountAnimationPreventedRef = ref102(isSelected.value);
    onMounted49(() => {
      requestAnimationFrame(() => {
        isMountAnimationPreventedRef.value = false;
      });
    });
    return (_ctx, _cache) => {
      return openBlock320(), createBlock311(unref322(Presence), {
        present: _ctx.forceMount || isSelected.value,
        "force-mount": ""
      }, {
        default: withCtx316(({ present }) => [
          createVNode58(unref322(Primitive), {
            id: contentId.value,
            ref: unref322(forwardRef),
            "as-child": _ctx.asChild,
            as: _ctx.as,
            role: "tabpanel",
            "data-state": isSelected.value ? "active" : "inactive",
            "data-orientation": unref322(rootContext).orientation.value,
            "aria-labelledby": triggerId.value,
            hidden: !present,
            tabindex: "0",
            style: normalizeStyle16({
              animationDuration: isMountAnimationPreventedRef.value ? "0s" : void 0
            })
          }, {
            default: withCtx316(() => [
              (unref322(rootContext).unmountOnHide.value ? present : true) ? renderSlot321(_ctx.$slots, "default", { key: 0 }) : createCommentVNode29("", true)
            ]),
            _: 2
          }, 1032, ["id", "as-child", "as", "data-state", "data-orientation", "aria-labelledby", "hidden", "style"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/Tabs/TabsIndicator.js
import { defineComponent as defineComponent330, ref as ref103, watch as watch44, nextTick as nextTick30, createBlock as createBlock312, createCommentVNode as createCommentVNode30, openBlock as openBlock321, unref as unref323, mergeProps as mergeProps145, withCtx as withCtx317, renderSlot as renderSlot322 } from "vue";
var _sfc_main325 = defineComponent330({
  __name: "TabsIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectTabsRootContext();
    useForwardExpose();
    const activeTab = ref103();
    const indicatorStyle = ref103({
      size: null,
      position: null
    });
    watch44(() => [context2.modelValue.value, context2?.dir.value], async () => {
      await nextTick30();
      updateIndicatorStyle();
    }, { immediate: true });
    useResizeObserver([context2.tabsList, activeTab], updateIndicatorStyle);
    function updateIndicatorStyle() {
      activeTab.value = context2.tabsList.value?.querySelector('[role="tab"][data-state="active"]');
      if (!activeTab.value)
        return;
      if (context2.orientation.value === "horizontal") {
        indicatorStyle.value = {
          size: activeTab.value.offsetWidth,
          position: activeTab.value.offsetLeft
        };
      } else {
        indicatorStyle.value = {
          size: activeTab.value.offsetHeight,
          position: activeTab.value.offsetTop
        };
      }
    }
    return (_ctx, _cache) => {
      return typeof indicatorStyle.value.size === "number" ? (openBlock321(), createBlock312(unref323(Primitive), mergeProps145({ key: 0 }, props2, {
        style: {
          "--reka-tabs-indicator-size": `${indicatorStyle.value.size}px`,
          "--reka-tabs-indicator-position": `${indicatorStyle.value.position}px`
        }
      }), {
        default: withCtx317(() => [
          renderSlot322(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])) : createCommentVNode30("", true);
    };
  }
});

// node_modules/reka-ui/dist/Tabs/TabsList.js
import { defineComponent as defineComponent331, toRefs as toRefs51, createBlock as createBlock313, openBlock as openBlock322, unref as unref324, withCtx as withCtx318, createVNode as createVNode59, renderSlot as renderSlot323 } from "vue";
var _sfc_main326 = defineComponent331({
  __name: "TabsList",
  props: {
    loop: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { loop } = toRefs51(props2);
    const { forwardRef, currentElement } = useForwardExpose();
    const context2 = injectTabsRootContext();
    context2.tabsList = currentElement;
    return (_ctx, _cache) => {
      return openBlock322(), createBlock313(unref324(_sfc_main50), {
        "as-child": "",
        orientation: unref324(context2).orientation.value,
        dir: unref324(context2).dir.value,
        loop: unref324(loop)
      }, {
        default: withCtx318(() => [
          createVNode59(unref324(Primitive), {
            ref: unref324(forwardRef),
            role: "tablist",
            "as-child": _ctx.asChild,
            as: _ctx.as,
            "aria-orientation": unref324(context2).orientation.value
          }, {
            default: withCtx318(() => [
              renderSlot323(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["as-child", "as", "aria-orientation"])
        ]),
        _: 3
      }, 8, ["orientation", "dir", "loop"]);
    };
  }
});

// node_modules/reka-ui/dist/Tabs/TabsTrigger.js
import { defineComponent as defineComponent332, computed as computed113, createBlock as createBlock314, openBlock as openBlock323, unref as unref325, withCtx as withCtx319, createVNode as createVNode60, withKeys as withKeys22, withModifiers as withModifiers22, renderSlot as renderSlot324 } from "vue";
var _sfc_main327 = defineComponent332({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const rootContext = injectTabsRootContext();
    const triggerId = computed113(() => makeTriggerId2(rootContext.baseId, props2.value));
    const contentId = computed113(() => makeContentId2(rootContext.baseId, props2.value));
    const isSelected = computed113(() => props2.value === rootContext.modelValue.value);
    return (_ctx, _cache) => {
      return openBlock323(), createBlock314(unref325(_sfc_main54), {
        "as-child": "",
        focusable: !_ctx.disabled,
        active: isSelected.value
      }, {
        default: withCtx319(() => [
          createVNode60(unref325(Primitive), {
            id: triggerId.value,
            ref: unref325(forwardRef),
            role: "tab",
            type: _ctx.as === "button" ? "button" : void 0,
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "aria-selected": isSelected.value ? "true" : "false",
            "aria-controls": contentId.value,
            "data-state": isSelected.value ? "active" : "inactive",
            disabled: _ctx.disabled,
            "data-disabled": _ctx.disabled ? "" : void 0,
            "data-orientation": unref325(rootContext).orientation.value,
            onMousedown: _cache[0] || (_cache[0] = withModifiers22((event) => {
              if (!_ctx.disabled && event.ctrlKey === false) {
                unref325(rootContext).changeModelValue(_ctx.value);
              } else {
                event.preventDefault();
              }
            }, ["left"])),
            onKeydown: _cache[1] || (_cache[1] = withKeys22(($event) => unref325(rootContext).changeModelValue(_ctx.value), ["enter", "space"])),
            onFocus: _cache[2] || (_cache[2] = () => {
              const isAutomaticActivation = unref325(rootContext).activationMode !== "manual";
              if (!isSelected.value && !_ctx.disabled && isAutomaticActivation) {
                unref325(rootContext).changeModelValue(_ctx.value);
              }
            })
          }, {
            default: withCtx319(() => [
              renderSlot324(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "type", "as", "as-child", "aria-selected", "aria-controls", "data-state", "disabled", "data-disabled", "data-orientation"])
        ]),
        _: 3
      }, 8, ["focusable", "active"]);
    };
  }
});

// node_modules/reka-ui/dist/TagsInput/TagsInputClear.js
import { defineComponent as defineComponent334, createBlock as createBlock316, openBlock as openBlock325, unref as unref327, mergeProps as mergeProps146, withCtx as withCtx321, renderSlot as renderSlot326 } from "vue";

// node_modules/reka-ui/dist/TagsInput/TagsInputRoot.js
import { defineComponent as defineComponent333, toRefs as toRefs52, ref as ref104, computed as computed114, createBlock as createBlock315, openBlock as openBlock324, unref as unref326, withCtx as withCtx320, createVNode as createVNode61, renderSlot as renderSlot325, createCommentVNode as createCommentVNode31 } from "vue";
var [injectTagsInputRootContext, provideTagsInputRootContext] = createContext("TagsInputRoot");
var _sfc_main328 = defineComponent333({
  __name: "TagsInputRoot",
  props: {
    modelValue: {},
    defaultValue: { default: () => [] },
    addOnPaste: { type: Boolean },
    addOnTab: { type: Boolean },
    addOnBlur: { type: Boolean },
    duplicate: { type: Boolean },
    disabled: { type: Boolean },
    delimiter: { default: "," },
    dir: {},
    max: { default: 0 },
    id: {},
    convertValue: {},
    displayValue: { type: Function, default: (value) => value.toString() },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "invalid", "addTag", "removeTag"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { addOnPaste, disabled, delimiter, max: max2, id, dir: propDir, addOnBlur, addOnTab } = toRefs52(props2);
    const dir = useDirection(propDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: true,
      deep: true
    });
    const { forwardRef, currentElement } = useForwardExpose();
    const { focused } = useFocusWithin(currentElement);
    const isFormControl = useFormControl(currentElement);
    const { getItems, CollectionSlot } = useCollection({ isProvider: true });
    const selectedElement = ref104();
    const isInvalidInput = ref104(false);
    const currentModelValue = computed114(() => Array.isArray(modelValue.value) ? [...modelValue.value] : []);
    function handleRemoveTag(index) {
      if (index !== -1) {
        const collection = getItems().filter((i) => i.ref.dataset.disabled !== "");
        modelValue.value = modelValue.value.filter((_, i) => i !== index);
        emits("removeTag", collection[index].value);
      }
    }
    provideTagsInputRootContext({
      modelValue,
      onAddValue: (_payload) => {
        const array = [...currentModelValue.value];
        const modelValueIsObject = array.length > 0 && typeof array[0] === "object";
        const defaultValueIsObject = array.length > 0 && typeof props2.defaultValue[0] === "object";
        if ((modelValueIsObject || defaultValueIsObject) && typeof props2.convertValue !== "function")
          throw new Error("You must provide a `convertValue` function when using objects as values.");
        const payload = props2.convertValue ? props2.convertValue(_payload) : _payload;
        if (array.length >= max2.value && !!max2.value) {
          emits("invalid", payload);
          return false;
        }
        if (props2.duplicate) {
          modelValue.value = [...array, payload];
          emits("addTag", payload);
          return true;
        } else {
          const exist = array.includes(payload);
          if (!exist) {
            modelValue.value = [...array, payload];
            emits("addTag", payload);
            return true;
          } else {
            isInvalidInput.value = true;
          }
        }
        emits("invalid", payload);
        return false;
      },
      onRemoveValue: handleRemoveTag,
      onInputKeydown: (event) => {
        const target = event.target;
        const collection = getItems().map((i) => i.ref).filter((i) => i.dataset.disabled !== "");
        if (!collection.length)
          return;
        const lastTag = collection.at(-1);
        switch (event.key) {
          case "Delete":
          case "Backspace": {
            if (target.selectionStart !== 0 || target.selectionEnd !== 0)
              break;
            if (selectedElement.value) {
              const index = collection.findIndex((i) => i === selectedElement.value);
              handleRemoveTag(index);
              selectedElement.value = selectedElement.value === lastTag ? collection.at(index - 1) : collection.at(index + 1);
              event.preventDefault();
            } else if (event.key === "Backspace") {
              selectedElement.value = lastTag;
              event.preventDefault();
            }
            break;
          }
          case "Home":
          case "End":
          case "ArrowRight":
          case "ArrowLeft": {
            const isArrowRight = event.key === "ArrowRight" && dir.value === "ltr" || event.key === "ArrowLeft" && dir.value === "rtl";
            const isArrowLeft = !isArrowRight;
            if (target.selectionStart !== 0 || target.selectionEnd !== 0)
              break;
            if (isArrowLeft && !selectedElement.value) {
              selectedElement.value = lastTag;
              event.preventDefault();
            } else if (isArrowRight && lastTag && selectedElement.value === lastTag) {
              selectedElement.value = void 0;
              event.preventDefault();
            } else if (selectedElement.value) {
              const el = useArrowNavigation(event, selectedElement.value, void 0, {
                itemsArray: collection,
                loop: false,
                dir: dir.value
              });
              if (el)
                selectedElement.value = el;
              event.preventDefault();
            }
            break;
          }
          case "ArrowUp":
          case "ArrowDown": {
            if (selectedElement.value)
              event.preventDefault();
            break;
          }
          default: {
            selectedElement.value = void 0;
          }
        }
      },
      selectedElement,
      isInvalidInput,
      addOnPaste,
      addOnBlur,
      addOnTab,
      dir,
      disabled,
      delimiter,
      max: max2,
      id,
      displayValue: props2.displayValue
    });
    return (_ctx, _cache) => {
      return openBlock324(), createBlock315(unref326(CollectionSlot), null, {
        default: withCtx320(() => [
          createVNode61(unref326(Primitive), {
            ref: unref326(forwardRef),
            dir: unref326(dir),
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "data-invalid": isInvalidInput.value ? "" : void 0,
            "data-disabled": unref326(disabled) ? "" : void 0,
            "data-focused": unref326(focused) ? "" : void 0
          }, {
            default: withCtx320(() => [
              renderSlot325(_ctx.$slots, "default", { modelValue: unref326(modelValue) }),
              unref326(isFormControl) && _ctx.name ? (openBlock324(), createBlock315(unref326(_sfc_main52), {
                key: 0,
                name: _ctx.name,
                value: unref326(modelValue),
                required: _ctx.required,
                disabled: unref326(disabled)
              }, null, 8, ["name", "value", "required", "disabled"])) : createCommentVNode31("", true)
            ]),
            _: 3
          }, 8, ["dir", "as", "as-child", "data-invalid", "data-disabled", "data-focused"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/TagsInput/TagsInputClear.js
var _sfc_main329 = defineComponent334({
  __name: "TagsInputClear",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const context2 = injectTagsInputRootContext();
    function handleCancel() {
      if (context2.disabled.value)
        return;
      context2.modelValue.value = [];
    }
    return (_ctx, _cache) => {
      return openBlock325(), createBlock316(unref327(Primitive), mergeProps146(props2, {
        type: _ctx.as === "button" ? "button" : void 0,
        "data-disabled": unref327(context2).disabled.value ? "" : void 0,
        onClick: handleCancel
      }), {
        default: withCtx321(() => [
          renderSlot326(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["type", "data-disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/TagsInput/TagsInputInput.js
import { defineComponent as defineComponent335, ref as ref105, onMounted as onMounted50, createBlock as createBlock317, openBlock as openBlock326, unref as unref328, withKeys as withKeys23, withCtx as withCtx322, renderSlot as renderSlot327, nextTick as nextTick31 } from "vue";
var _sfc_main330 = defineComponent335({
  __name: "TagsInputInput",
  props: {
    placeholder: {},
    autoFocus: { type: Boolean },
    maxLength: {},
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectTagsInputRootContext();
    const { forwardRef, currentElement } = useForwardExpose();
    function handleBlur(event) {
      if (!context2.addOnBlur.value)
        return;
      const target = event.target;
      if (!target.value)
        return;
      const isAdded = context2.onAddValue(target.value);
      if (isAdded)
        target.value = "";
    }
    function handleTab(event) {
      if (!context2.addOnTab.value)
        return;
      handleCustomKeydown(event);
    }
    const isComposing = ref105(false);
    function onCompositionStart() {
      isComposing.value = true;
    }
    function onCompositionEnd() {
      requestAnimationFrame(() => {
        isComposing.value = false;
      });
    }
    async function handleCustomKeydown(event) {
      if (isComposing.value)
        return;
      await nextTick31();
      if (event.defaultPrevented)
        return;
      const target = event.target;
      if (!target.value)
        return;
      const isAdded = context2.onAddValue(target.value);
      if (isAdded)
        target.value = "";
      event.preventDefault();
    }
    function handleInput(event) {
      context2.isInvalidInput.value = false;
      if (event.data === null)
        return;
      const delimiter = context2.delimiter.value;
      const matchesDelimiter = delimiter === event.data || delimiter instanceof RegExp && delimiter.test(event.data);
      if (matchesDelimiter) {
        const target = event.target;
        target.value = target.value.replace(delimiter, "");
        const isAdded = context2.onAddValue(target.value);
        if (isAdded)
          target.value = "";
      }
    }
    function handlePaste(event) {
      if (context2.addOnPaste.value) {
        event.preventDefault();
        const clipboardData = event.clipboardData;
        if (!clipboardData)
          return;
        const value = clipboardData.getData("text");
        if (context2.delimiter.value) {
          const splitValue = value.split(context2.delimiter.value);
          splitValue.forEach((v) => {
            context2.onAddValue(v);
          });
        } else {
          context2.onAddValue(value);
        }
      }
    }
    onMounted50(() => {
      const inputEl = currentElement.value.nodeName === "INPUT" ? currentElement.value : currentElement.value.querySelector("input");
      if (!inputEl)
        return;
      setTimeout(() => {
        if (props2.autoFocus)
          inputEl?.focus();
      }, 1);
    });
    return (_ctx, _cache) => {
      return openBlock326(), createBlock317(unref328(Primitive), {
        id: unref328(context2).id?.value,
        ref: unref328(forwardRef),
        type: "text",
        autocomplete: "off",
        autocorrect: "off",
        autocapitalize: "off",
        as: _ctx.as,
        "as-child": _ctx.asChild,
        maxlength: _ctx.maxLength,
        placeholder: _ctx.placeholder,
        disabled: unref328(context2).disabled.value,
        "data-invalid": unref328(context2).isInvalidInput.value ? "" : void 0,
        onInput: handleInput,
        onKeydown: [
          withKeys23(handleCustomKeydown, ["enter"]),
          withKeys23(handleTab, ["tab"]),
          unref328(context2).onInputKeydown
        ],
        onBlur: handleBlur,
        onCompositionstart: onCompositionStart,
        onCompositionend: onCompositionEnd,
        onPaste: handlePaste
      }, {
        default: withCtx322(() => [
          renderSlot327(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "as", "as-child", "maxlength", "placeholder", "disabled", "data-invalid", "onKeydown"]);
    };
  }
});

// node_modules/reka-ui/dist/TagsInput/TagsInputItem.js
import { defineComponent as defineComponent336, toRefs as toRefs53, computed as computed115, createBlock as createBlock318, openBlock as openBlock327, unref as unref329, withCtx as withCtx323, createVNode as createVNode62, renderSlot as renderSlot328 } from "vue";
var [injectTagsInputItemContext, provideTagsInputItemContext] = createContext("TagsInputItem");
var _sfc_main331 = defineComponent336({
  __name: "TagsInputItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { value } = toRefs53(props2);
    const context2 = injectTagsInputRootContext();
    const { forwardRef, currentElement } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const isSelected = computed115(() => context2.selectedElement.value === currentElement.value);
    const disabled = computed115(() => props2.disabled || context2.disabled.value);
    const itemContext = provideTagsInputItemContext({
      value,
      isSelected,
      disabled,
      textId: "",
      displayValue: computed115(() => context2.displayValue(value.value))
    });
    return (_ctx, _cache) => {
      return openBlock327(), createBlock318(unref329(CollectionItem), { value: unref329(value) }, {
        default: withCtx323(() => [
          createVNode62(unref329(Primitive), {
            ref: unref329(forwardRef),
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "aria-labelledby": unref329(itemContext).textId,
            "aria-current": isSelected.value,
            "data-disabled": disabled.value ? "" : void 0,
            "data-state": isSelected.value ? "active" : "inactive"
          }, {
            default: withCtx323(() => [
              renderSlot328(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["as", "as-child", "aria-labelledby", "aria-current", "data-disabled", "data-state"])
        ]),
        _: 3
      }, 8, ["value"]);
    };
  }
});

// node_modules/reka-ui/dist/TagsInput/TagsInputItemDelete.js
import { defineComponent as defineComponent337, computed as computed116, createBlock as createBlock319, openBlock as openBlock328, unref as unref330, mergeProps as mergeProps147, withCtx as withCtx324, renderSlot as renderSlot329 } from "vue";
var _sfc_main332 = defineComponent337({
  __name: "TagsInputItemDelete",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const context2 = injectTagsInputRootContext();
    const itemContext = injectTagsInputItemContext();
    const disabled = computed116(() => itemContext.disabled?.value || context2.disabled.value);
    function handleDelete() {
      if (disabled.value)
        return;
      const index = context2.modelValue.value.findIndex((i) => isEqual(i, itemContext.value.value));
      context2.onRemoveValue(index);
    }
    return (_ctx, _cache) => {
      return openBlock328(), createBlock319(unref330(Primitive), mergeProps147({ tabindex: "-1" }, props2, {
        "aria-labelledby": unref330(itemContext).textId,
        "aria-current": unref330(itemContext).isSelected.value,
        "data-state": unref330(itemContext).isSelected.value ? "active" : "inactive",
        "data-disabled": disabled.value ? "" : void 0,
        type: _ctx.as === "button" ? "button" : void 0,
        onClick: handleDelete
      }), {
        default: withCtx324(() => [
          renderSlot329(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-labelledby", "aria-current", "data-state", "data-disabled", "type"]);
    };
  }
});

// node_modules/reka-ui/dist/TagsInput/TagsInputItemText.js
import { defineComponent as defineComponent338, createBlock as createBlock320, openBlock as openBlock329, unref as unref331, mergeProps as mergeProps148, withCtx as withCtx325, renderSlot as renderSlot330, createTextVNode as createTextVNode29, toDisplayString as toDisplayString15 } from "vue";
var _sfc_main333 = defineComponent338({
  __name: "TagsInputItemText",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(__props) {
    const props2 = __props;
    const itemContext = injectTagsInputItemContext();
    useForwardExpose();
    itemContext.textId ||= useId2(void 0, "reka-tags-input-item-text");
    return (_ctx, _cache) => {
      return openBlock329(), createBlock320(unref331(Primitive), mergeProps148(props2, {
        id: unref331(itemContext).textId
      }), {
        default: withCtx325(() => [
          renderSlot330(_ctx.$slots, "default", {}, () => [
            createTextVNode29(toDisplayString15(unref331(itemContext).displayValue.value), 1)
          ])
        ]),
        _: 3
      }, 16, ["id"]);
    };
  }
});

// node_modules/reka-ui/dist/TimeField/TimeFieldInput.js
import { defineComponent as defineComponent340, ref as ref107, computed as computed118, createBlock as createBlock322, openBlock as openBlock331, unref as unref333, mergeProps as mergeProps150, toHandlers as toHandlers3, withCtx as withCtx327, renderSlot as renderSlot332 } from "vue";

// node_modules/reka-ui/dist/TimeField/TimeFieldRoot.js
import { defineComponent as defineComponent339, toRefs as toRefs54, ref as ref106, computed as computed117, onMounted as onMounted51, watch as watch45, nextTick as nextTick32, createBlock as createBlock321, openBlock as openBlock330, unref as unref332, mergeProps as mergeProps149, withKeys as withKeys24, withCtx as withCtx326, renderSlot as renderSlot331, createVNode as createVNode63 } from "vue";
var [injectTimeFieldRootContext, provideTimeFieldRootContext] = createContext("TimeFieldRoot");
function convertValue(value, date = $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3($14e0f24ef4ac5c92$export$aa8b41735afcabd2())) {
  if (value && "day" in value) {
    return value;
  }
  return $11d87f3f76e88657$export$b21e0b124e224484(date, value);
}
var _sfc_main334 = defineComponent339({
  ...{
    inheritAttrs: false
  },
  __name: "TimeFieldRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    id: {},
    dir: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, readonly: readonly3, granularity, defaultValue, minValue, maxValue, dir: propDir, locale: propLocale } = toRefs54(props2);
    const locale = useLocale(propLocale);
    const dir = useDirection(propDir);
    const formatter = useDateFormatter(locale.value);
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const segmentElements = ref106(/* @__PURE__ */ new Set());
    const convertedMinValue = computed117(() => minValue.value ? convertValue(minValue.value) : void 0);
    const convertedMaxValue = computed117(() => maxValue.value ? convertValue(maxValue.value) : void 0);
    onMounted51(() => {
      getTimeFieldSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
    });
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: defaultValue.value,
      passive: props2.modelValue === void 0
    });
    const convertedModelValue = computed117({
      get() {
        if (isNullish(modelValue.value))
          return modelValue.value;
        return convertValue(modelValue.value);
      },
      set(newValue) {
        if (newValue)
          modelValue.value = modelValue.value && "day" in modelValue.value ? newValue : new $35ea8db9cb2ccb90$export$680ea196effce5f(newValue.hour, newValue.minute, newValue.second, modelValue.value?.millisecond);
        return newValue;
      }
    });
    const defaultDate = getDefaultTime({
      defaultPlaceholder: props2.placeholder,
      defaultValue: modelValue.value
    });
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    const convertedPlaceholder = computed117({
      get() {
        return convertValue(placeholder.value);
      },
      set(newValue) {
        if (newValue)
          placeholder.value = "day" in placeholder.value ? newValue.copy() : new $35ea8db9cb2ccb90$export$680ea196effce5f(newValue.hour, newValue.minute, newValue.second, placeholder.value?.millisecond);
        return newValue;
      }
    });
    const inferredGranularity = computed117(() => {
      if (granularity.value)
        return granularity.value;
      return "minute";
    });
    const isInvalid = computed117(() => {
      if (!modelValue.value)
        return false;
      if (convertedMinValue.value && isBefore(convertedModelValue.value, convertedMinValue.value))
        return true;
      if (convertedMaxValue.value && isBefore(convertedMaxValue.value, convertedModelValue.value))
        return true;
      return false;
    });
    const initialSegments = initializeTimeSegmentValues(inferredGranularity.value);
    const segmentValues = ref106(modelValue.value ? { ...syncTimeSegmentValues({ value: convertedModelValue.value, formatter }) } : { ...initialSegments });
    const allSegmentContent = computed117(() => createContent({
      granularity: inferredGranularity.value,
      dateRef: convertedPlaceholder.value,
      formatter,
      hideTimeZone: props2.hideTimeZone,
      hourCycle: props2.hourCycle,
      segmentValues: segmentValues.value,
      locale,
      isTimeValue: true
    }));
    const segmentContents = computed117(() => allSegmentContent.value.arr);
    const editableSegmentContents = computed117(() => segmentContents.value.filter(({ part }) => part !== "literal"));
    watch45(locale, (value) => {
      if (formatter.getLocale() !== value) {
        formatter.setLocale(value);
        nextTick32(() => {
          segmentElements.value.clear();
          getTimeFieldSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
        });
      }
    });
    watch45(convertedModelValue, (_modelValue) => {
      if (!isNullish(_modelValue) && (!$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(convertedPlaceholder.value, _modelValue) || convertedPlaceholder.value.compare(_modelValue) !== 0))
        placeholder.value = _modelValue.copy();
    });
    watch45([convertedModelValue, locale], ([_modelValue]) => {
      if (!isNullish(_modelValue)) {
        segmentValues.value = { ...syncTimeSegmentValues({ value: _modelValue, formatter }) };
      } else if (Object.values(segmentValues.value).every((value) => value === null) || isNullish(_modelValue)) {
        segmentValues.value = { ...initialSegments };
      }
    });
    const currentFocusedElement = ref106(null);
    const currentSegmentIndex = computed117(() => Array.from(segmentElements.value).findIndex((el) => el.getAttribute("data-reka-time-field-segment") === currentFocusedElement.value?.getAttribute("data-reka-time-field-segment")));
    const nextFocusableSegment = computed117(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const nextCondition = sign < 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (nextCondition)
        return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value + sign];
      return segmentToFocus;
    });
    const prevFocusableSegment = computed117(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const prevCondition = sign > 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (prevCondition)
        return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value - sign];
      return segmentToFocus;
    });
    const kbd = useKbd();
    function handleKeydown(e) {
      if (!isSegmentNavigationKey(e.key))
        return;
      if (e.key === kbd.ARROW_LEFT)
        prevFocusableSegment.value?.focus();
      if (e.key === kbd.ARROW_RIGHT)
        nextFocusableSegment.value?.focus();
    }
    function setFocusedElement(el) {
      currentFocusedElement.value = el;
    }
    provideTimeFieldRootContext({
      locale,
      modelValue: convertedModelValue,
      placeholder: convertedPlaceholder,
      disabled,
      formatter,
      hourCycle: props2.hourCycle,
      readonly: readonly3,
      segmentValues,
      isInvalid,
      segmentContents: editableSegmentContents,
      elements: segmentElements,
      setFocusedElement,
      focusNext() {
        nextFocusableSegment.value?.focus();
      }
    });
    __expose({
      /** Helper to set the focused element inside the DateField */
      setFocusedElement
    });
    return (_ctx, _cache) => {
      return openBlock330(), createBlock321(unref332(Primitive), mergeProps149(_ctx.$attrs, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        role: "group",
        "aria-disabled": unref332(disabled) ? true : void 0,
        "data-disabled": unref332(disabled) ? "" : void 0,
        "data-readonly": unref332(readonly3) ? "" : void 0,
        "data-invalid": isInvalid.value ? "" : void 0,
        dir: unref332(dir),
        onKeydown: withKeys24(handleKeydown, ["left", "right"])
      }), {
        default: withCtx326(() => [
          renderSlot331(_ctx.$slots, "default", {
            modelValue: unref332(modelValue),
            segments: segmentContents.value,
            isInvalid: isInvalid.value
          }),
          createVNode63(unref332(_sfc_main), {
            id: _ctx.id,
            as: "input",
            feature: "focusable",
            tabindex: "-1",
            value: unref332(modelValue) ? unref332(modelValue).toString() : "",
            name: _ctx.name,
            disabled: unref332(disabled),
            required: _ctx.required,
            onFocus: _cache[0] || (_cache[0] = ($event) => Array.from(segmentElements.value)?.[0]?.focus())
          }, null, 8, ["id", "value", "name", "disabled", "required"])
        ]),
        _: 3
      }, 16, ["aria-disabled", "data-disabled", "data-readonly", "data-invalid", "dir"]);
    };
  }
});

// node_modules/reka-ui/dist/TimeField/TimeFieldInput.js
var _sfc_main335 = defineComponent340({
  __name: "TimeFieldInput",
  props: {
    part: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectTimeFieldRootContext();
    const hasLeftFocus = ref107(true);
    const lastKeyZero = ref107(false);
    const {
      handleSegmentClick,
      handleSegmentKeydown,
      attributes
    } = useDateField({
      hasLeftFocus,
      lastKeyZero,
      placeholder: rootContext.placeholder,
      hourCycle: rootContext.hourCycle,
      segmentValues: rootContext.segmentValues,
      formatter: rootContext.formatter,
      part: props2.part,
      disabled: rootContext.disabled,
      readonly: rootContext.readonly,
      focusNext: rootContext.focusNext,
      modelValue: rootContext.modelValue
    });
    const disabled = computed118(() => rootContext.disabled.value);
    const readonly3 = computed118(() => rootContext.readonly.value);
    const isInvalid = computed118(() => rootContext.isInvalid.value);
    return (_ctx, _cache) => {
      return openBlock331(), createBlock322(unref333(Primitive), mergeProps150({
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, unref333(attributes), {
        contenteditable: disabled.value || readonly3.value ? false : _ctx.part !== "literal",
        "data-reka-time-field-segment": _ctx.part,
        "aria-disabled": disabled.value ? true : void 0,
        "aria-readonly": readonly3.value ? true : void 0,
        "data-disabled": disabled.value ? "" : void 0,
        "data-invalid": isInvalid.value ? "" : void 0,
        "aria-invalid": isInvalid.value ? true : void 0
      }, toHandlers3(_ctx.part !== "literal" ? {
        mousedown: unref333(handleSegmentClick),
        keydown: unref333(handleSegmentKeydown),
        focusout: () => {
          hasLeftFocus.value = true;
        },
        focusin: (e) => {
          unref333(rootContext).setFocusedElement(e.target);
        }
      } : {})), {
        default: withCtx327(() => [
          renderSlot332(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["as", "as-child", "contenteditable", "data-reka-time-field-segment", "aria-disabled", "aria-readonly", "data-disabled", "data-invalid", "aria-invalid"]);
    };
  }
});

// node_modules/reka-ui/dist/Toast/ToastAction.js
import { defineComponent as defineComponent346, createBlock as createBlock327, createCommentVNode as createCommentVNode34, openBlock as openBlock336, withCtx as withCtx332, createVNode as createVNode66, unref as unref338, renderSlot as renderSlot338 } from "vue";

// node_modules/reka-ui/dist/Toast/ToastAnnounceExclude.js
import { defineComponent as defineComponent341, createBlock as createBlock323, openBlock as openBlock332, unref as unref334, withCtx as withCtx328, renderSlot as renderSlot333 } from "vue";
var _sfc_main336 = defineComponent341({
  __name: "ToastAnnounceExclude",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock332(), createBlock323(unref334(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-reka-toast-announce-exclude": "",
        "data-reka-toast-announce-alt": _ctx.altText || void 0
      }, {
        default: withCtx328(() => [
          renderSlot333(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "data-reka-toast-announce-alt"]);
    };
  }
});

// node_modules/reka-ui/dist/Toast/ToastClose.js
import { defineComponent as defineComponent345, createBlock as createBlock326, openBlock as openBlock335, withCtx as withCtx331, createVNode as createVNode65, unref as unref337, mergeProps as mergeProps152, renderSlot as renderSlot337 } from "vue";

// node_modules/reka-ui/dist/Toast/ToastRootImpl.js
import { defineComponent as defineComponent344, ref as ref110, computed as computed119, watchEffect as watchEffect25, watch as watch46, onMounted as onMounted52, onUnmounted as onUnmounted22, createElementBlock as createElementBlock15, openBlock as openBlock334, Fragment as Fragment11, createBlock as createBlock325, createCommentVNode as createCommentVNode33, withCtx as withCtx330, createTextVNode as createTextVNode31, toDisplayString as toDisplayString17, unref as unref336, Teleport as Teleport5, createVNode as createVNode64, mergeProps as mergeProps151, withModifiers as withModifiers23, renderSlot as renderSlot336 } from "vue";

// node_modules/reka-ui/dist/Toast/ToastAnnounce.js
import { defineComponent as defineComponent343, ref as ref109, createBlock as createBlock324, createCommentVNode as createCommentVNode32, unref as unref335, openBlock as openBlock333, withCtx as withCtx329, createTextVNode as createTextVNode30, renderSlot as renderSlot335, toDisplayString as toDisplayString16 } from "vue";

// node_modules/reka-ui/dist/Toast/ToastProvider.js
import { defineComponent as defineComponent342, toRefs as toRefs55, ref as ref108, renderSlot as renderSlot334 } from "vue";
var [injectToastProviderContext, provideToastProviderContext] = createContext("ToastProvider");
var _sfc_main337 = defineComponent342({
  ...{
    inheritAttrs: false
  },
  __name: "ToastProvider",
  props: {
    label: { default: "Notification" },
    duration: { default: 5e3 },
    swipeDirection: { default: "right" },
    swipeThreshold: { default: 50 }
  },
  setup(__props) {
    const props2 = __props;
    const { label, duration, swipeDirection, swipeThreshold } = toRefs55(props2);
    useCollection({ isProvider: true });
    const viewport = ref108();
    const toastCount = ref108(0);
    const isFocusedToastEscapeKeyDownRef = ref108(false);
    const isClosePausedRef = ref108(false);
    if (props2.label && typeof props2.label === "string" && !props2.label.trim()) {
      const error = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.";
      throw new Error(error);
    }
    provideToastProviderContext({
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange(el) {
        viewport.value = el;
      },
      onToastAdd() {
        toastCount.value++;
      },
      onToastRemove() {
        toastCount.value--;
      },
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef
    });
    return (_ctx, _cache) => {
      return renderSlot334(_ctx.$slots, "default");
    };
  }
});

// node_modules/reka-ui/dist/Toast/ToastAnnounce.js
var _sfc_main338 = defineComponent343({
  __name: "ToastAnnounce",
  setup(__props) {
    const providerContext = injectToastProviderContext();
    const isAnnounced = useTimeout(1e3);
    const renderAnnounceText = ref109(false);
    useRafFn(() => {
      renderAnnounceText.value = true;
    });
    return (_ctx, _cache) => {
      return unref335(isAnnounced) || renderAnnounceText.value ? (openBlock333(), createBlock324(unref335(_sfc_main), { key: 0 }, {
        default: withCtx329(() => [
          createTextVNode30(toDisplayString16(unref335(providerContext).label.value) + " ", 1),
          renderSlot335(_ctx.$slots, "default")
        ]),
        _: 3
      })) : createCommentVNode32("", true);
    };
  }
});

// node_modules/reka-ui/dist/Toast/utils.js
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
function handleAndDispatchCustomEvent2(name, handler, detail) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    currentTarget.addEventListener(name, handler, { once: true });
  currentTarget.dispatchEvent(event);
}
function isDeltaInDirection(delta, direction, threshold = 0) {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right")
    return isDeltaX && deltaX > threshold;
  else
    return !isDeltaX && deltaY > threshold;
}
function isHTMLElement2(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent)
      textContent.push(node.textContent);
    if (isHTMLElement2(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.rekaToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.rekaToastAnnounceAlt;
          if (altText)
            textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}

// node_modules/reka-ui/dist/Toast/ToastRootImpl.js
var [injectToastRootContext, provideToastRootContext] = createContext("ToastRoot");
var _sfc_main339 = defineComponent344({
  ...{
    inheritAttrs: false
  },
  __name: "ToastRootImpl",
  props: {
    type: {},
    open: { type: Boolean, default: false },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const providerContext = injectToastProviderContext();
    const pointerStartRef = ref110(null);
    const swipeDeltaRef = ref110(null);
    const duration = computed119(
      () => typeof props2.duration === "number" ? props2.duration : providerContext.duration.value
    );
    const closeTimerStartTimeRef = ref110(0);
    const closeTimerRemainingTimeRef = ref110(duration.value);
    const closeTimerRef = ref110(0);
    const remainingTime = ref110(duration.value);
    const remainingRaf = useRafFn(() => {
      const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.value;
      remainingTime.value = Math.max(closeTimerRemainingTimeRef.value - elapsedTime, 0);
    }, { fpsLimit: 60 });
    function startTimer(duration2) {
      if (duration2 <= 0 || duration2 === Number.POSITIVE_INFINITY)
        return;
      if (!isClient)
        return;
      window.clearTimeout(closeTimerRef.value);
      closeTimerStartTimeRef.value = (/* @__PURE__ */ new Date()).getTime();
      closeTimerRef.value = window.setTimeout(handleClose, duration2);
    }
    function handleClose(event) {
      const isNonPointerEvent = event?.pointerType === "";
      const isFocusInToast = currentElement.value?.contains(getActiveElement());
      if (isFocusInToast && isNonPointerEvent)
        providerContext.viewport.value?.focus();
      if (isNonPointerEvent) {
        providerContext.isClosePausedRef.value = false;
      }
      emits("close");
    }
    const announceTextContent = computed119(() => currentElement.value ? getAnnounceTextContent(currentElement.value) : null);
    if (props2.type && !["foreground", "background"].includes(props2.type)) {
      const error = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(error);
    }
    watchEffect25((cleanupFn) => {
      const viewport = providerContext.viewport.value;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.value);
          remainingRaf.resume();
          emits("resume");
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.value;
          closeTimerRemainingTimeRef.value = closeTimerRemainingTimeRef.value - elapsedTime;
          window.clearTimeout(closeTimerRef.value);
          remainingRaf.pause();
          emits("pause");
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    });
    watch46(() => [props2.open, duration.value], () => {
      closeTimerRemainingTimeRef.value = duration.value;
      if (props2.open && !providerContext.isClosePausedRef.value)
        startTimer(duration.value);
    }, { immediate: true });
    onKeyStroke("Escape", (event) => {
      emits("escapeKeyDown", event);
      if (!event.defaultPrevented) {
        providerContext.isFocusedToastEscapeKeyDownRef.value = true;
        handleClose();
      }
    });
    onMounted52(() => {
      providerContext.onToastAdd();
    });
    onUnmounted22(() => {
      providerContext.onToastRemove();
    });
    provideToastRootContext({ onClose: handleClose });
    return (_ctx, _cache) => {
      return openBlock334(), createElementBlock15(Fragment11, null, [
        announceTextContent.value ? (openBlock334(), createBlock325(_sfc_main338, {
          key: 0,
          role: "alert",
          "aria-live": _ctx.type === "foreground" ? "assertive" : "polite",
          "aria-atomic": "true"
        }, {
          default: withCtx330(() => [
            createTextVNode31(toDisplayString17(announceTextContent.value), 1)
          ]),
          _: 1
        }, 8, ["aria-live"])) : createCommentVNode33("", true),
        unref336(providerContext).viewport.value ? (openBlock334(), createBlock325(Teleport5, {
          key: 1,
          to: unref336(providerContext).viewport.value
        }, [
          createVNode64(unref336(CollectionItem), null, {
            default: withCtx330(() => [
              createVNode64(unref336(Primitive), mergeProps151({
                ref: unref336(forwardRef),
                role: "alert",
                "aria-live": "off",
                "aria-atomic": "true",
                tabindex: "0"
              }, _ctx.$attrs, {
                as: _ctx.as,
                "as-child": _ctx.asChild,
                "data-state": _ctx.open ? "open" : "closed",
                "data-swipe-direction": unref336(providerContext).swipeDirection.value,
                style: { userSelect: "none", touchAction: "none" },
                onPointerdown: _cache[0] || (_cache[0] = withModifiers23((event) => {
                  pointerStartRef.value = { x: event.clientX, y: event.clientY };
                }, ["left"])),
                onPointermove: _cache[1] || (_cache[1] = (event) => {
                  if (!pointerStartRef.value) return;
                  const x = event.clientX - pointerStartRef.value.x;
                  const y = event.clientY - pointerStartRef.value.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.value);
                  const isHorizontalSwipe = ["left", "right"].includes(unref336(providerContext).swipeDirection.value);
                  const clamp4 = ["left", "up"].includes(unref336(providerContext).swipeDirection.value) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp4(0, x) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp4(0, y) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.value = delta;
                    unref336(handleAndDispatchCustomEvent2)(unref336(TOAST_SWIPE_MOVE), (ev) => emits("swipeMove", ev), eventDetail);
                  } else if (unref336(isDeltaInDirection)(delta, unref336(providerContext).swipeDirection.value, moveStartBuffer)) {
                    swipeDeltaRef.value = delta;
                    unref336(handleAndDispatchCustomEvent2)(unref336(TOAST_SWIPE_START), (ev) => emits("swipeStart", ev), eventDetail);
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
                    pointerStartRef.value = null;
                  }
                }),
                onPointerup: _cache[2] || (_cache[2] = (event) => {
                  const delta = swipeDeltaRef.value;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.value = null;
                  pointerStartRef.value = null;
                  if (delta) {
                    const toast = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (unref336(isDeltaInDirection)(delta, unref336(providerContext).swipeDirection.value, unref336(providerContext).swipeThreshold.value)) {
                      unref336(handleAndDispatchCustomEvent2)(unref336(TOAST_SWIPE_END), (ev) => emits("swipeEnd", ev), eventDetail);
                    } else {
                      unref336(handleAndDispatchCustomEvent2)(unref336(TOAST_SWIPE_CANCEL), (ev) => emits("swipeCancel", ev), eventDetail);
                    }
                    toast?.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }), {
                default: withCtx330(() => [
                  renderSlot336(_ctx.$slots, "default", {
                    remaining: remainingTime.value,
                    duration: duration.value
                  })
                ]),
                _: 3
              }, 16, ["as", "as-child", "data-state", "data-swipe-direction"])
            ]),
            _: 3
          })
        ], 8, ["to"])) : createCommentVNode33("", true)
      ], 64);
    };
  }
});

// node_modules/reka-ui/dist/Toast/ToastClose.js
var _sfc_main340 = defineComponent345({
  __name: "ToastClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectToastRootContext();
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock335(), createBlock326(_sfc_main336, { "as-child": "" }, {
        default: withCtx331(() => [
          createVNode65(unref337(Primitive), mergeProps152(props2, {
            ref: unref337(forwardRef),
            type: _ctx.as === "button" ? "button" : void 0,
            onClick: unref337(rootContext).onClose
          }), {
            default: withCtx331(() => [
              renderSlot337(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["type", "onClick"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Toast/ToastAction.js
var _sfc_main341 = defineComponent346({
  __name: "ToastAction",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    if (!props2.altText)
      throw new Error("Missing prop `altText` expected on `ToastAction`");
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return _ctx.altText ? (openBlock336(), createBlock327(_sfc_main336, {
        key: 0,
        "alt-text": _ctx.altText,
        "as-child": ""
      }, {
        default: withCtx332(() => [
          createVNode66(_sfc_main340, {
            ref: unref338(forwardRef),
            as: _ctx.as,
            "as-child": _ctx.asChild
          }, {
            default: withCtx332(() => [
              renderSlot338(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["as", "as-child"])
        ]),
        _: 3
      }, 8, ["alt-text"])) : createCommentVNode34("", true);
    };
  }
});

// node_modules/reka-ui/dist/Toast/ToastDescription.js
import { defineComponent as defineComponent347, createBlock as createBlock328, openBlock as openBlock337, unref as unref339, normalizeProps as normalizeProps102, guardReactiveProps as guardReactiveProps98, withCtx as withCtx333, renderSlot as renderSlot339 } from "vue";
var _sfc_main342 = defineComponent347({
  __name: "ToastDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock337(), createBlock328(unref339(Primitive), normalizeProps102(guardReactiveProps98(props2)), {
        default: withCtx333(() => [
          renderSlot339(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Toast/ToastPortal.js
import { defineComponent as defineComponent348, createBlock as createBlock329, openBlock as openBlock338, unref as unref340, normalizeProps as normalizeProps103, guardReactiveProps as guardReactiveProps99, withCtx as withCtx334, renderSlot as renderSlot340 } from "vue";
var _sfc_main343 = defineComponent348({
  __name: "ToastPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock338(), createBlock329(unref340(_sfc_main27), normalizeProps103(guardReactiveProps99(props2)), {
        default: withCtx334(() => [
          renderSlot340(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Toast/ToastRoot.js
import { defineComponent as defineComponent349, createBlock as createBlock330, openBlock as openBlock339, unref as unref341, withCtx as withCtx335, createVNode as createVNode67, mergeProps as mergeProps153, renderSlot as renderSlot341 } from "vue";
var _sfc_main344 = defineComponent349({
  __name: "ToastRoot",
  props: {
    defaultOpen: { type: Boolean, default: true },
    forceMount: { type: Boolean },
    type: { default: "foreground" },
    open: { type: Boolean, default: void 0 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef } = useForwardExpose();
    const open = useVModel(props2, "open", emits, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    return (_ctx, _cache) => {
      return openBlock339(), createBlock330(unref341(Presence), {
        present: _ctx.forceMount || unref341(open)
      }, {
        default: withCtx335(() => [
          createVNode67(_sfc_main339, mergeProps153({
            ref: unref341(forwardRef),
            open: unref341(open),
            type: _ctx.type,
            as: _ctx.as,
            "as-child": _ctx.asChild,
            duration: _ctx.duration
          }, _ctx.$attrs, {
            onClose: _cache[0] || (_cache[0] = ($event) => open.value = false),
            onPause: _cache[1] || (_cache[1] = ($event) => emits("pause")),
            onResume: _cache[2] || (_cache[2] = ($event) => emits("resume")),
            onEscapeKeyDown: _cache[3] || (_cache[3] = ($event) => emits("escapeKeyDown", $event)),
            onSwipeStart: _cache[4] || (_cache[4] = (event) => {
              emits("swipeStart", event);
              if (!event.defaultPrevented) {
                event.currentTarget.setAttribute("data-swipe", "start");
              }
            }),
            onSwipeMove: _cache[5] || (_cache[5] = (event) => {
              emits("swipeMove", event);
              if (!event.defaultPrevented) {
                const { x, y } = event.detail.delta;
                const target = event.currentTarget;
                target.setAttribute("data-swipe", "move");
                target.style.setProperty("--reka-toast-swipe-move-x", `${x}px`);
                target.style.setProperty("--reka-toast-swipe-move-y", `${y}px`);
              }
            }),
            onSwipeCancel: _cache[6] || (_cache[6] = (event) => {
              emits("swipeCancel", event);
              if (!event.defaultPrevented) {
                const target = event.currentTarget;
                target.setAttribute("data-swipe", "cancel");
                target.style.removeProperty("--reka-toast-swipe-move-x");
                target.style.removeProperty("--reka-toast-swipe-move-y");
                target.style.removeProperty("--reka-toast-swipe-end-x");
                target.style.removeProperty("--reka-toast-swipe-end-y");
              }
            }),
            onSwipeEnd: _cache[7] || (_cache[7] = (event) => {
              emits("swipeEnd", event);
              if (!event.defaultPrevented) {
                const { x, y } = event.detail.delta;
                const target = event.currentTarget;
                target.setAttribute("data-swipe", "end");
                target.style.removeProperty("--reka-toast-swipe-move-x");
                target.style.removeProperty("--reka-toast-swipe-move-y");
                target.style.setProperty("--reka-toast-swipe-end-x", `${x}px`);
                target.style.setProperty("--reka-toast-swipe-end-y", `${y}px`);
                open.value = false;
              }
            })
          }), {
            default: withCtx335(({ remaining, duration: _duration }) => [
              renderSlot341(_ctx.$slots, "default", {
                remaining,
                duration: _duration,
                open: unref341(open)
              })
            ]),
            _: 3
          }, 16, ["open", "type", "as", "as-child", "duration"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/Toast/ToastTitle.js
import { defineComponent as defineComponent350, createBlock as createBlock331, openBlock as openBlock340, unref as unref342, normalizeProps as normalizeProps104, guardReactiveProps as guardReactiveProps100, withCtx as withCtx336, renderSlot as renderSlot342 } from "vue";
var _sfc_main345 = defineComponent350({
  __name: "ToastTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock340(), createBlock331(unref342(Primitive), normalizeProps104(guardReactiveProps100(props2)), {
        default: withCtx336(() => [
          renderSlot342(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Toast/ToastViewport.js
import { defineComponent as defineComponent353, toRefs as toRefs56, computed as computed120, ref as ref111, onMounted as onMounted54, watchEffect as watchEffect26, createBlock as createBlock334, openBlock as openBlock343, unref as unref345, normalizeStyle as normalizeStyle17, withCtx as withCtx339, createCommentVNode as createCommentVNode35, createVNode as createVNode68, mergeProps as mergeProps155, renderSlot as renderSlot345 } from "vue";

// node_modules/reka-ui/dist/DismissableLayer/DismissableLayerBranch.js
import { defineComponent as defineComponent351, onMounted as onMounted53, onUnmounted as onUnmounted23, createBlock as createBlock332, openBlock as openBlock341, unref as unref343, mergeProps as mergeProps154, withCtx as withCtx337, renderSlot as renderSlot343 } from "vue";
var _sfc_main346 = defineComponent351({
  __name: "DismissableLayerBranch",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    onMounted53(() => {
      context.branches.add(currentElement.value);
    });
    onUnmounted23(() => {
      context.branches.delete(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock341(), createBlock332(unref343(Primitive), mergeProps154({ ref: unref343(forwardRef) }, props2), {
        default: withCtx337(() => [
          renderSlot343(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Toast/FocusProxy.js
import { defineComponent as defineComponent352, createBlock as createBlock333, openBlock as openBlock342, unref as unref344, withCtx as withCtx338, renderSlot as renderSlot344 } from "vue";
var _sfc_main347 = defineComponent352({
  __name: "FocusProxy",
  emits: ["focusFromOutsideViewport"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const providerContext = injectToastProviderContext();
    return (_ctx, _cache) => {
      return openBlock342(), createBlock333(unref344(_sfc_main), {
        "aria-hidden": "true",
        tabindex: "0",
        style: { "position": "fixed" },
        onFocus: _cache[0] || (_cache[0] = (event) => {
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !unref344(providerContext).viewport.value?.contains(prevFocusedElement);
          if (isFocusFromOutsideViewport) emits("focusFromOutsideViewport");
        })
      }, {
        default: withCtx338(() => [
          renderSlot344(_ctx.$slots, "default")
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Toast/ToastViewport.js
var _sfc_main348 = defineComponent353({
  ...{
    inheritAttrs: false
  },
  __name: "ToastViewport",
  props: {
    hotkey: { default: () => ["F8"] },
    label: { type: [String, Function], default: "Notifications ({hotkey})" },
    asChild: { type: Boolean },
    as: { default: "ol" }
  },
  setup(__props) {
    const props2 = __props;
    const { hotkey, label } = toRefs56(props2);
    const { forwardRef, currentElement } = useForwardExpose();
    const { CollectionSlot, getItems } = useCollection();
    const providerContext = injectToastProviderContext();
    const hasToasts = computed120(() => providerContext.toastCount.value > 0);
    const headFocusProxyRef = ref111();
    const tailFocusProxyRef = ref111();
    const hotkeyMessage = computed120(() => hotkey.value.join("+").replace(/Key/g, "").replace(/Digit/g, ""));
    onKeyStroke(hotkey.value, () => {
      currentElement.value.focus();
    });
    onMounted54(() => {
      providerContext.onViewportChange(currentElement.value);
    });
    watchEffect26((cleanupFn) => {
      const viewport = currentElement.value;
      if (hasToasts.value && viewport) {
        const handlePause = () => {
          if (!providerContext.isClosePausedRef.value) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            providerContext.isClosePausedRef.value = true;
          }
        };
        const handleResume = () => {
          if (providerContext.isClosePausedRef.value) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            providerContext.isClosePausedRef.value = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !viewport.contains(event.relatedTarget);
          if (isFocusMovingOutside)
            handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = viewport.contains(getActiveElement());
          if (!isFocusInside)
            handleResume();
        };
        const handleKeyDown = (event) => {
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = getActiveElement();
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              headFocusProxyRef.value?.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst2(sortedCandidates.slice(index + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? headFocusProxyRef.value?.focus() : tailFocusProxyRef.value?.focus();
            }
          }
        };
        viewport.addEventListener("focusin", handlePause);
        viewport.addEventListener("focusout", handleFocusOutResume);
        viewport.addEventListener("pointermove", handlePause);
        viewport.addEventListener("pointerleave", handlePointerLeaveResume);
        viewport.addEventListener("keydown", handleKeyDown);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        cleanupFn(() => {
          viewport.removeEventListener("focusin", handlePause);
          viewport.removeEventListener("focusout", handleFocusOutResume);
          viewport.removeEventListener("pointermove", handlePause);
          viewport.removeEventListener("pointerleave", handlePointerLeaveResume);
          viewport.removeEventListener("keydown", handleKeyDown);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        });
      }
    });
    function getSortedTabbableCandidates({ tabbingDirection }) {
      const toastItems = getItems().map((i) => i.ref);
      const tabbableCandidates = toastItems.map((toastNode) => {
        const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
        return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
      });
      return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
    }
    return (_ctx, _cache) => {
      return openBlock343(), createBlock334(unref345(_sfc_main346), {
        role: "region",
        "aria-label": typeof unref345(label) === "string" ? unref345(label).replace("{hotkey}", hotkeyMessage.value) : unref345(label)(hotkeyMessage.value),
        tabindex: "-1",
        style: normalizeStyle17({
          // incase list has size when empty (e.g. padding), we remove pointer events so
          // it doesn't prevent interactions with page elements that it overlays
          pointerEvents: hasToasts.value ? void 0 : "none"
        })
      }, {
        default: withCtx339(() => [
          hasToasts.value ? (openBlock343(), createBlock334(_sfc_main347, {
            key: 0,
            ref: (node) => {
              headFocusProxyRef.value = unref345(unrefElement)(node);
              return void 0;
            },
            onFocusFromOutsideViewport: _cache[0] || (_cache[0] = () => {
              const tabbableCandidates = getSortedTabbableCandidates({
                tabbingDirection: "forwards"
              });
              unref345(focusFirst2)(tabbableCandidates);
            })
          }, null, 512)) : createCommentVNode35("", true),
          createVNode68(unref345(CollectionSlot), null, {
            default: withCtx339(() => [
              createVNode68(unref345(Primitive), mergeProps155({
                ref: unref345(forwardRef),
                tabindex: "-1",
                as: _ctx.as,
                "as-child": _ctx.asChild
              }, _ctx.$attrs), {
                default: withCtx339(() => [
                  renderSlot345(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["as", "as-child"])
            ]),
            _: 3
          }),
          hasToasts.value ? (openBlock343(), createBlock334(_sfc_main347, {
            key: 1,
            ref: (node) => {
              tailFocusProxyRef.value = unref345(unrefElement)(node);
              return void 0;
            },
            onFocusFromOutsideViewport: _cache[1] || (_cache[1] = () => {
              const tabbableCandidates = getSortedTabbableCandidates({
                tabbingDirection: "backwards"
              });
              unref345(focusFirst2)(tabbableCandidates);
            })
          }, null, 512)) : createCommentVNode35("", true)
        ]),
        _: 3
      }, 8, ["aria-label", "style"]);
    };
  }
});

// node_modules/reka-ui/dist/Toggle/Toggle.js
import { defineComponent as defineComponent355, computed as computed121, createBlock as createBlock336, openBlock as openBlock345, unref as unref347, withCtx as withCtx341, renderSlot as renderSlot347, createCommentVNode as createCommentVNode37 } from "vue";

// node_modules/reka-ui/dist/ToggleGroup/ToggleGroupRoot.js
import { defineComponent as defineComponent354, toRefs as toRefs57, createBlock as createBlock335, openBlock as openBlock344, resolveDynamicComponent as resolveDynamicComponent8, unref as unref346, withCtx as withCtx340, createVNode as createVNode69, renderSlot as renderSlot346, createCommentVNode as createCommentVNode36 } from "vue";
var [injectToggleGroupRootContext, provideToggleGroupRootContext] = createContext("ToggleGroupRoot");
var _sfc_main349 = defineComponent354({
  __name: "ToggleGroupRoot",
  props: {
    rovingFocus: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    orientation: {},
    dir: {},
    loop: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { loop, rovingFocus, disabled, dir: propDir } = toRefs57(props2);
    const dir = useDirection(propDir);
    const { forwardRef, currentElement } = useForwardExpose();
    const { modelValue, changeModelValue, isSingle } = useSingleOrMultipleValue(props2, emits);
    const isFormControl = useFormControl(currentElement);
    provideToggleGroupRootContext({
      isSingle,
      modelValue,
      changeModelValue,
      dir,
      orientation: props2.orientation,
      loop,
      rovingFocus,
      disabled
    });
    return (_ctx, _cache) => {
      return openBlock344(), createBlock335(resolveDynamicComponent8(unref346(rovingFocus) ? unref346(_sfc_main50) : unref346(Primitive)), {
        "as-child": "",
        orientation: unref346(rovingFocus) ? _ctx.orientation : void 0,
        dir: unref346(dir),
        loop: unref346(rovingFocus) ? unref346(loop) : void 0
      }, {
        default: withCtx340(() => [
          createVNode69(unref346(Primitive), {
            ref: unref346(forwardRef),
            role: "group",
            "as-child": _ctx.asChild,
            as: _ctx.as
          }, {
            default: withCtx340(() => [
              renderSlot346(_ctx.$slots, "default", { modelValue: unref346(modelValue) }),
              unref346(isFormControl) && _ctx.name ? (openBlock344(), createBlock335(_sfc_main52, {
                key: 0,
                name: _ctx.name,
                required: _ctx.required,
                value: unref346(modelValue)
              }, null, 8, ["name", "required", "value"])) : createCommentVNode36("", true)
            ]),
            _: 3
          }, 8, ["as-child", "as"])
        ]),
        _: 3
      }, 8, ["orientation", "dir", "loop"]);
    };
  }
});

// node_modules/reka-ui/dist/Toggle/Toggle.js
var _sfc_main350 = defineComponent355({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null], default: void 0 },
    disabled: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const toggleGroupContext = injectToggleGroupRootContext(null);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    function togglePressed() {
      modelValue.value = !modelValue.value;
    }
    const dataState = computed121(() => {
      return modelValue.value ? "on" : "off";
    });
    const isFormControl = useFormControl(currentElement);
    return (_ctx, _cache) => {
      return openBlock345(), createBlock336(unref347(Primitive), {
        ref: unref347(forwardRef),
        type: _ctx.as === "button" ? "button" : void 0,
        "as-child": props2.asChild,
        as: _ctx.as,
        "aria-pressed": unref347(modelValue),
        "data-state": dataState.value,
        "data-disabled": _ctx.disabled ? "" : void 0,
        disabled: _ctx.disabled,
        onClick: togglePressed
      }, {
        default: withCtx341(() => [
          renderSlot347(_ctx.$slots, "default", {
            modelValue: unref347(modelValue),
            disabled: _ctx.disabled,
            pressed: unref347(modelValue),
            state: dataState.value
          }),
          unref347(isFormControl) && _ctx.name && !unref347(toggleGroupContext) ? (openBlock345(), createBlock336(_sfc_main52, {
            key: 0,
            type: "checkbox",
            name: _ctx.name,
            value: unref347(modelValue),
            required: _ctx.required
          }, null, 8, ["name", "value", "required"])) : createCommentVNode37("", true)
        ]),
        _: 3
      }, 8, ["type", "as-child", "as", "aria-pressed", "data-state", "data-disabled", "disabled"]);
    };
  }
});

// node_modules/reka-ui/dist/ToggleGroup/ToggleGroupItem.js
import { defineComponent as defineComponent356, computed as computed122, createBlock as createBlock337, openBlock as openBlock346, resolveDynamicComponent as resolveDynamicComponent9, unref as unref348, withCtx as withCtx342, createVNode as createVNode70, mergeProps as mergeProps156, renderSlot as renderSlot348, normalizeProps as normalizeProps105, guardReactiveProps as guardReactiveProps101 } from "vue";
var _sfc_main351 = defineComponent356({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectToggleGroupRootContext();
    const disabled = computed122(() => rootContext.disabled?.value || props2.disabled);
    const pressed = computed122(() => isValueEqualOrExist(rootContext.modelValue.value, props2.value));
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock346(), createBlock337(resolveDynamicComponent9(unref348(rootContext).rovingFocus.value ? unref348(_sfc_main54) : unref348(Primitive)), {
        "as-child": "",
        focusable: !disabled.value,
        active: pressed.value
      }, {
        default: withCtx342(() => [
          createVNode70(unref348(_sfc_main350), mergeProps156(props2, {
            ref: unref348(forwardRef),
            disabled: disabled.value,
            "model-value": pressed.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref348(rootContext).changeModelValue(_ctx.value))
          }), {
            default: withCtx342((slotProps) => [
              renderSlot348(_ctx.$slots, "default", normalizeProps105(guardReactiveProps101(slotProps)))
            ]),
            _: 3
          }, 16, ["disabled", "model-value"])
        ]),
        _: 3
      }, 8, ["focusable", "active"]);
    };
  }
});

// node_modules/reka-ui/dist/Toolbar/ToolbarButton.js
import { defineComponent as defineComponent357, createBlock as createBlock338, openBlock as openBlock347, unref as unref349, withCtx as withCtx343, createVNode as createVNode71, mergeProps as mergeProps157, renderSlot as renderSlot349 } from "vue";
var _sfc_main352 = defineComponent357({
  __name: "ToolbarButton",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock347(), createBlock338(unref349(_sfc_main54), {
        "as-child": "",
        focusable: !_ctx.disabled
      }, {
        default: withCtx343(() => [
          createVNode71(unref349(Primitive), mergeProps157({
            ref: unref349(forwardRef),
            type: _ctx.as === "button" ? "button" : void 0
          }, props2), {
            default: withCtx343(() => [
              renderSlot349(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["type"])
        ]),
        _: 3
      }, 8, ["focusable"]);
    };
  }
});

// node_modules/reka-ui/dist/Toolbar/ToolbarLink.js
import { defineComponent as defineComponent358, createBlock as createBlock339, openBlock as openBlock348, unref as unref350, withCtx as withCtx344, createVNode as createVNode72, mergeProps as mergeProps158, renderSlot as renderSlot350 } from "vue";
var _sfc_main353 = defineComponent358({
  __name: "ToolbarLink",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock348(), createBlock339(unref350(_sfc_main54), {
        "as-child": "",
        focusable: ""
      }, {
        default: withCtx344(() => [
          createVNode72(unref350(Primitive), mergeProps158(props2, {
            ref: unref350(forwardRef),
            onKeydown: _cache[0] || (_cache[0] = (event) => {
              if (event.key === " ") event.currentTarget?.click();
            })
          }), {
            default: withCtx344(() => [
              renderSlot350(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Toolbar/ToolbarRoot.js
import { defineComponent as defineComponent359, toRefs as toRefs58, createBlock as createBlock340, openBlock as openBlock349, unref as unref351, withCtx as withCtx345, createVNode as createVNode73, renderSlot as renderSlot351 } from "vue";
var [injectToolbarRootContext, provideToolbarRootContext] = createContext("ToolbarRoot");
var _sfc_main354 = defineComponent359({
  __name: "ToolbarRoot",
  props: {
    orientation: { default: "horizontal" },
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { orientation, dir: propDir } = toRefs58(props2);
    const dir = useDirection(propDir);
    const { forwardRef } = useForwardExpose();
    provideToolbarRootContext({ orientation, dir });
    return (_ctx, _cache) => {
      return openBlock349(), createBlock340(unref351(_sfc_main50), {
        "as-child": "",
        orientation: unref351(orientation),
        dir: unref351(dir),
        loop: _ctx.loop
      }, {
        default: withCtx345(() => [
          createVNode73(unref351(Primitive), {
            ref: unref351(forwardRef),
            role: "toolbar",
            "aria-orientation": unref351(orientation),
            "as-child": _ctx.asChild,
            as: _ctx.as
          }, {
            default: withCtx345(() => [
              renderSlot351(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["aria-orientation", "as-child", "as"])
        ]),
        _: 3
      }, 8, ["orientation", "dir", "loop"]);
    };
  }
});

// node_modules/reka-ui/dist/Toolbar/ToolbarSeparator.js
import { defineComponent as defineComponent360, createBlock as createBlock341, openBlock as openBlock350, unref as unref352, withCtx as withCtx346, renderSlot as renderSlot352 } from "vue";
var _sfc_main355 = defineComponent360({
  __name: "ToolbarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectToolbarRootContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock350(), createBlock341(_sfc_main301, {
        orientation: unref352(rootContext).orientation.value,
        "as-child": props2.asChild,
        as: _ctx.as
      }, {
        default: withCtx346(() => [
          renderSlot352(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["orientation", "as-child", "as"]);
    };
  }
});

// node_modules/reka-ui/dist/Toolbar/ToolbarToggleGroup.js
import { defineComponent as defineComponent361, createBlock as createBlock342, openBlock as openBlock351, unref as unref353, mergeProps as mergeProps159, withCtx as withCtx347, renderSlot as renderSlot353 } from "vue";
var _sfc_main356 = defineComponent361({
  __name: "ToolbarToggleGroup",
  props: {
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectToolbarRootContext();
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock351(), createBlock342(unref353(_sfc_main349), mergeProps159({ ...props2, ...unref353(emitsAsProps) }, {
        "data-orientation": unref353(rootContext).orientation.value,
        dir: unref353(rootContext).dir.value,
        "roving-focus": false
      }), {
        default: withCtx347(() => [
          renderSlot353(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["data-orientation", "dir"]);
    };
  }
});

// node_modules/reka-ui/dist/Toolbar/ToolbarToggleItem.js
import { defineComponent as defineComponent362, createBlock as createBlock343, openBlock as openBlock352, withCtx as withCtx348, createVNode as createVNode74, unref as unref354, mergeProps as mergeProps160, renderSlot as renderSlot354 } from "vue";
var _sfc_main357 = defineComponent362({
  __name: "ToolbarToggleItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock352(), createBlock343(_sfc_main352, { "as-child": "" }, {
        default: withCtx348(() => [
          createVNode74(unref354(_sfc_main351), mergeProps160(props2, { ref: unref354(forwardRef) }), {
            default: withCtx348(() => [
              renderSlot354(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Tooltip/TooltipArrow.js
import { defineComponent as defineComponent363, createBlock as createBlock344, openBlock as openBlock353, unref as unref355, normalizeProps as normalizeProps106, guardReactiveProps as guardReactiveProps102, withCtx as withCtx349, renderSlot as renderSlot355 } from "vue";
var _sfc_main358 = defineComponent363({
  __name: "TooltipArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock353(), createBlock344(unref355(_sfc_main62), normalizeProps106(guardReactiveProps102(props2)), {
        default: withCtx349(() => [
          renderSlot355(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Tooltip/TooltipContent.js
import { defineComponent as defineComponent368, createBlock as createBlock348, openBlock as openBlock357, unref as unref359, withCtx as withCtx353, resolveDynamicComponent as resolveDynamicComponent10, mergeProps as mergeProps163, renderSlot as renderSlot360 } from "vue";

// node_modules/reka-ui/dist/Tooltip/TooltipContentHoverable.js
import { defineComponent as defineComponent367, createBlock as createBlock347, openBlock as openBlock356, mergeProps as mergeProps162, unref as unref358, withCtx as withCtx352, renderSlot as renderSlot359 } from "vue";

// node_modules/reka-ui/dist/Tooltip/TooltipContentImpl.js
import { defineComponent as defineComponent366, useSlots as useSlots2, computed as computed124, onMounted as onMounted55, createBlock as createBlock346, openBlock as openBlock355, unref as unref357, withModifiers as withModifiers24, withCtx as withCtx351, createVNode as createVNode75, mergeProps as mergeProps161, renderSlot as renderSlot358, createTextVNode as createTextVNode32, toDisplayString as toDisplayString18, Comment as Comment2 } from "vue";

// node_modules/reka-ui/dist/Tooltip/utils.js
var TOOLTIP_OPEN = "tooltip.open";

// node_modules/reka-ui/dist/Tooltip/TooltipRoot.js
import { defineComponent as defineComponent365, computed as computed123, watch as watch47, ref as ref113, createBlock as createBlock345, openBlock as openBlock354, unref as unref356, withCtx as withCtx350, renderSlot as renderSlot357 } from "vue";

// node_modules/reka-ui/dist/Tooltip/TooltipProvider.js
import { defineComponent as defineComponent364, toRefs as toRefs59, ref as ref112, renderSlot as renderSlot356 } from "vue";
var [injectTooltipProviderContext, provideTooltipProviderContext] = createContext("TooltipProvider");
var _sfc_main359 = defineComponent364({
  ...{
    inheritAttrs: false
  },
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 700 },
    skipDelayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean, default: false },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean, default: false }
  },
  setup(__props) {
    const props2 = __props;
    const { delayDuration, skipDelayDuration, disableHoverableContent, disableClosingTrigger, ignoreNonKeyboardFocus, disabled } = toRefs59(props2);
    useForwardExpose();
    const isOpenDelayed = ref112(true);
    const isPointerInTransitRef = ref112(false);
    const { start: startTimer, stop: clearTimer } = useTimeoutFn(() => {
      isOpenDelayed.value = true;
    }, skipDelayDuration, { immediate: false });
    provideTooltipProviderContext({
      isOpenDelayed,
      delayDuration,
      onOpen() {
        clearTimer();
        isOpenDelayed.value = false;
      },
      onClose() {
        startTimer();
      },
      isPointerInTransitRef,
      disableHoverableContent,
      disableClosingTrigger,
      disabled,
      ignoreNonKeyboardFocus
    });
    return (_ctx, _cache) => {
      return renderSlot356(_ctx.$slots, "default");
    };
  }
});

// node_modules/reka-ui/dist/Tooltip/TooltipRoot.js
var [injectTooltipRootContext, provideTooltipRootContext] = createContext("TooltipRoot");
var _sfc_main360 = defineComponent365({
  __name: "TooltipRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    delayDuration: { default: void 0 },
    disableHoverableContent: { type: Boolean, default: void 0 },
    disableClosingTrigger: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    ignoreNonKeyboardFocus: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    useForwardExpose();
    const providerContext = injectTooltipProviderContext();
    const disableHoverableContent = computed123(() => props2.disableHoverableContent ?? providerContext.disableHoverableContent.value);
    const disableClosingTrigger = computed123(() => props2.disableClosingTrigger ?? providerContext.disableClosingTrigger.value);
    const disableTooltip = computed123(() => props2.disabled ?? providerContext.disabled.value);
    const delayDuration = computed123(() => props2.delayDuration ?? providerContext.delayDuration.value);
    const ignoreNonKeyboardFocus = computed123(() => props2.ignoreNonKeyboardFocus ?? providerContext.ignoreNonKeyboardFocus.value);
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    watch47(open, (isOpen) => {
      if (!providerContext.onClose)
        return;
      if (isOpen) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
    });
    const wasOpenDelayedRef = ref113(false);
    const trigger = ref113();
    const stateAttribute = computed123(() => {
      if (!open.value)
        return "closed";
      return wasOpenDelayedRef.value ? "delayed-open" : "instant-open";
    });
    const { start: startTimer, stop: clearTimer } = useTimeoutFn(() => {
      wasOpenDelayedRef.value = true;
      open.value = true;
    }, delayDuration, { immediate: false });
    function handleOpen() {
      clearTimer();
      wasOpenDelayedRef.value = false;
      open.value = true;
    }
    function handleClose() {
      clearTimer();
      open.value = false;
    }
    function handleDelayedOpen() {
      startTimer();
    }
    provideTooltipRootContext({
      contentId: "",
      open,
      stateAttribute,
      trigger,
      onTriggerChange(el) {
        trigger.value = el;
      },
      onTriggerEnter() {
        if (providerContext.isOpenDelayed.value)
          handleDelayedOpen();
        else handleOpen();
      },
      onTriggerLeave() {
        if (disableHoverableContent.value) {
          handleClose();
        } else {
          clearTimer();
        }
      },
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      disableClosingTrigger,
      disabled: disableTooltip,
      ignoreNonKeyboardFocus
    });
    return (_ctx, _cache) => {
      return openBlock354(), createBlock345(unref356(_sfc_main57), null, {
        default: withCtx350(() => [
          renderSlot357(_ctx.$slots, "default", { open: unref356(open) })
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Tooltip/TooltipContentImpl.js
var _sfc_main361 = defineComponent366({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: { default: 0 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean, default: true },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    arrowPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: false },
    positionStrategy: {},
    updatePositionStrategy: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectTooltipRootContext();
    const { forwardRef } = useForwardExpose();
    const slot = useSlots2();
    const defaultSlot = computed124(() => slot.default?.({}));
    const ariaLabel = computed124(() => {
      if (props2.ariaLabel)
        return props2.ariaLabel;
      let content = "";
      function recursiveTextSearch(node) {
        if (typeof node.children === "string" && node.type !== Comment2)
          content += node.children;
        else if (Array.isArray(node.children))
          node.children.forEach((child) => recursiveTextSearch(child));
      }
      defaultSlot.value?.forEach((node) => recursiveTextSearch(node));
      return content;
    });
    const popperContentProps = computed124(() => {
      const { ariaLabel: _, ...restProps } = props2;
      return restProps;
    });
    onMounted55(() => {
      useEventListener(window, "scroll", (event) => {
        const target = event.target;
        if (target?.contains(rootContext.trigger.value))
          rootContext.onClose();
      });
      useEventListener(window, TOOLTIP_OPEN, rootContext.onClose);
    });
    return (_ctx, _cache) => {
      return openBlock355(), createBlock346(unref357(_sfc_main14), {
        "as-child": "",
        "disable-outside-pointer-events": false,
        onEscapeKeyDown: _cache[0] || (_cache[0] = ($event) => emits("escapeKeyDown", $event)),
        onPointerDownOutside: _cache[1] || (_cache[1] = (event) => {
          if (unref357(rootContext).disableClosingTrigger.value && unref357(rootContext).trigger.value?.contains(event.target))
            event.preventDefault();
          emits("pointerDownOutside", event);
        }),
        onFocusOutside: _cache[2] || (_cache[2] = withModifiers24(() => {
        }, ["prevent"])),
        onDismiss: _cache[3] || (_cache[3] = ($event) => unref357(rootContext).onClose())
      }, {
        default: withCtx351(() => [
          createVNode75(unref357(_sfc_main61), mergeProps161({
            ref: unref357(forwardRef),
            "data-state": unref357(rootContext).stateAttribute.value
          }, { ..._ctx.$attrs, ...popperContentProps.value }, { style: {
            "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)",
            "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)",
            "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)",
            "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)",
            "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)"
          } }), {
            default: withCtx351(() => [
              renderSlot358(_ctx.$slots, "default"),
              createVNode75(unref357(_sfc_main), {
                id: unref357(rootContext).contentId,
                role: "tooltip"
              }, {
                default: withCtx351(() => [
                  createTextVNode32(toDisplayString18(ariaLabel.value), 1)
                ]),
                _: 1
              }, 8, ["id"])
            ]),
            _: 3
          }, 16, ["data-state"])
        ]),
        _: 3
      });
    };
  }
});

// node_modules/reka-ui/dist/Tooltip/TooltipContentHoverable.js
var _sfc_main362 = defineComponent367({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {}
  },
  setup(__props) {
    const props2 = __props;
    const forwardedProps = useForwardProps(props2);
    const { forwardRef, currentElement } = useForwardExpose();
    const { trigger, onClose } = injectTooltipRootContext();
    const providerContext = injectTooltipProviderContext();
    const { isPointerInTransit, onPointerExit } = useGraceArea(trigger, currentElement);
    providerContext.isPointerInTransitRef = isPointerInTransit;
    onPointerExit(() => {
      onClose();
    });
    return (_ctx, _cache) => {
      return openBlock356(), createBlock347(_sfc_main361, mergeProps162({ ref: unref358(forwardRef) }, unref358(forwardedProps)), {
        default: withCtx352(() => [
          renderSlot359(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Tooltip/TooltipContent.js
var _sfc_main363 = defineComponent368({
  __name: "TooltipContent",
  props: {
    forceMount: { type: Boolean },
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectTooltipRootContext();
    const forwarded = useForwardPropsEmits(props2, emits);
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock357(), createBlock348(unref359(Presence), {
        present: _ctx.forceMount || unref359(rootContext).open.value
      }, {
        default: withCtx353(() => [
          (openBlock357(), createBlock348(resolveDynamicComponent10(unref359(rootContext).disableHoverableContent.value ? _sfc_main361 : _sfc_main362), mergeProps163({ ref: unref359(forwardRef) }, unref359(forwarded)), {
            default: withCtx353(() => [
              renderSlot360(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
});

// node_modules/reka-ui/dist/Tooltip/TooltipPortal.js
import { defineComponent as defineComponent369, createBlock as createBlock349, openBlock as openBlock358, unref as unref360, normalizeProps as normalizeProps107, guardReactiveProps as guardReactiveProps103, withCtx as withCtx354, renderSlot as renderSlot361 } from "vue";
var _sfc_main364 = defineComponent369({
  __name: "TooltipPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock358(), createBlock349(unref360(_sfc_main27), normalizeProps107(guardReactiveProps103(props2)), {
        default: withCtx354(() => [
          renderSlot361(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/reka-ui/dist/Tooltip/TooltipTrigger.js
import { defineComponent as defineComponent370, ref as ref114, computed as computed125, onMounted as onMounted56, createBlock as createBlock350, openBlock as openBlock359, unref as unref361, withCtx as withCtx355, createVNode as createVNode76, mergeProps as mergeProps164, toHandlers as toHandlers4, renderSlot as renderSlot362 } from "vue";
var _sfc_main365 = defineComponent370({
  __name: "TooltipTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectTooltipRootContext();
    const providerContext = injectTooltipProviderContext();
    rootContext.contentId ||= useId2(void 0, "reka-tooltip-content");
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    const isPointerDown2 = ref114(false);
    const hasPointerMoveOpened = ref114(false);
    const tooltipListeners = computed125(() => {
      if (rootContext.disabled.value)
        return {};
      return {
        click: handleClick,
        focus: handleFocus,
        pointermove: handlePointerMove2,
        pointerleave: handlePointerLeave,
        pointerdown: handlePointerDown2,
        blur: handleBlur
      };
    });
    onMounted56(() => {
      rootContext.onTriggerChange(triggerElement.value);
    });
    function handlePointerUp2() {
      setTimeout(() => {
        isPointerDown2.value = false;
      }, 1);
    }
    function handlePointerDown2() {
      if (rootContext.open) {
        rootContext.onClose();
      }
      isPointerDown2.value = true;
      document.addEventListener("pointerup", handlePointerUp2, { once: true });
    }
    function handlePointerMove2(event) {
      if (event.pointerType === "touch")
        return;
      if (!hasPointerMoveOpened.value && !providerContext.isPointerInTransitRef.value) {
        rootContext.onTriggerEnter();
        hasPointerMoveOpened.value = true;
      }
    }
    function handlePointerLeave() {
      rootContext.onTriggerLeave();
      hasPointerMoveOpened.value = false;
    }
    function handleFocus(event) {
      if (isPointerDown2.value)
        return;
      if (rootContext.ignoreNonKeyboardFocus.value && !event.target.matches?.(":focus-visible"))
        return;
      rootContext.onOpen();
    }
    function handleBlur() {
      rootContext.onClose();
    }
    function handleClick() {
      if (!rootContext.disableClosingTrigger.value)
        rootContext.onClose();
    }
    return (_ctx, _cache) => {
      return openBlock359(), createBlock350(unref361(_sfc_main58), {
        "as-child": "",
        reference: _ctx.reference
      }, {
        default: withCtx355(() => [
          createVNode76(unref361(Primitive), mergeProps164({
            ref: unref361(forwardRef),
            "aria-describedby": unref361(rootContext).open.value ? unref361(rootContext).contentId : void 0,
            "data-state": unref361(rootContext).stateAttribute.value,
            as: _ctx.as,
            "as-child": props2.asChild,
            "data-grace-area-trigger": ""
          }, toHandlers4(tooltipListeners.value)), {
            default: withCtx355(() => [
              renderSlot362(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["aria-describedby", "data-state", "as", "as-child"])
        ]),
        _: 3
      }, 8, ["reference"]);
    };
  }
});

// node_modules/reka-ui/dist/Tree/TreeItem.js
import { defineComponent as defineComponent372, computed as computed127, createBlock as createBlock352, openBlock as openBlock361, unref as unref363, withCtx as withCtx357, createVNode as createVNode78, mergeProps as mergeProps165, withModifiers as withModifiers26, withKeys as withKeys26, renderSlot as renderSlot364 } from "vue";

// node_modules/reka-ui/dist/Tree/utils.js
function flatten(items) {
  return items.reduce((acc, item) => {
    acc.push(item);
    if (item.children)
      acc.push(...flatten(item.children));
    return acc;
  }, []);
}

// node_modules/reka-ui/dist/Tree/TreeRoot.js
import { defineComponent as defineComponent371, toRefs as toRefs60, ref as ref116, computed as computed126, createBlock as createBlock351, openBlock as openBlock360, unref as unref362, withCtx as withCtx356, createVNode as createVNode77, withKeys as withKeys25, withModifiers as withModifiers25, renderSlot as renderSlot363, nextTick as nextTick33 } from "vue";

// node_modules/reka-ui/dist/shared/useSelectionBehavior.js
import { ref as ref115 } from "vue";
function useSelectionBehavior(modelValue, props2) {
  const firstValue = ref115();
  const onSelectItem = (val, condition) => {
    if (props2.multiple && Array.isArray(modelValue.value)) {
      if (props2.selectionBehavior === "replace") {
        modelValue.value = [val];
        firstValue.value = val;
      } else {
        const index = modelValue.value.findIndex((v) => condition(v));
        if (index !== -1)
          modelValue.value = modelValue.value.filter((_, i) => i !== index);
        else
          modelValue.value = [...modelValue.value, val];
      }
    } else {
      if (props2.selectionBehavior === "replace") {
        modelValue.value = { ...val };
      } else {
        if (!Array.isArray(modelValue.value) && condition(modelValue.value))
          modelValue.value = void 0;
        else
          modelValue.value = { ...val };
      }
    }
    return modelValue.value;
  };
  function handleMultipleReplace(intent, currentElement, getItems, options) {
    if (!firstValue?.value || !props2.multiple || !Array.isArray(modelValue.value))
      return;
    const collection = getItems().filter((i) => i.ref.dataset.disabled !== "");
    const lastValue = collection.find((i) => i.ref === currentElement)?.value;
    if (!lastValue)
      return;
    let value = null;
    switch (intent) {
      case "prev":
      case "next": {
        value = findValuesBetween(options, firstValue.value, lastValue);
        break;
      }
      case "first": {
        value = findValuesBetween(options, firstValue.value, options?.[0]);
        break;
      }
      case "last": {
        value = findValuesBetween(options, firstValue.value, options?.[options.length - 1]);
        break;
      }
    }
    modelValue.value = value;
  }
  return {
    firstValue,
    onSelectItem,
    handleMultipleReplace
  };
}

// node_modules/reka-ui/dist/Tree/TreeRoot.js
var [injectTreeRootContext, provideTreeRootContext] = createContext("TreeRoot");
var _sfc_main366 = defineComponent371({
  __name: "TreeRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    items: {},
    expanded: {},
    defaultExpanded: {},
    getKey: {},
    getChildren: { type: Function, default: (val) => val.children },
    selectionBehavior: { default: "toggle" },
    multiple: { type: Boolean },
    dir: {},
    disabled: { type: Boolean },
    propagateSelect: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "ul" }
  },
  emits: ["update:modelValue", "update:expanded"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { items, multiple, disabled, propagateSelect, dir: propDir } = toRefs60(props2);
    const { handleTypeaheadSearch } = useTypeahead();
    const dir = useDirection(propDir);
    const rovingFocusGroupRef = ref116();
    const isVirtual = ref116(false);
    const virtualKeydownHook = createEventHook();
    const modelValue = useVModel(props2, "modelValue", emits, {
      // @ts-expect-error idk
      defaultValue: props2.defaultValue ?? (multiple.value ? [] : void 0),
      passive: props2.modelValue === void 0,
      deep: true
    });
    const expanded = useVModel(props2, "expanded", emits, {
      // @ts-expect-error idk
      defaultValue: props2.defaultExpanded ?? [],
      passive: props2.expanded === void 0,
      deep: true
    });
    const { onSelectItem, handleMultipleReplace } = useSelectionBehavior(modelValue, props2);
    const selectedKeys = computed126(() => {
      if (multiple.value && Array.isArray(modelValue.value))
        return modelValue.value.map((i) => props2.getKey(i));
      else
        return [props2.getKey(modelValue.value ?? {})];
    });
    function flattenItems(items2, level = 1, parentItem) {
      return items2.reduce((acc, item, index) => {
        const key = props2.getKey(item);
        const children = props2.getChildren(item);
        const isExpanded = expanded.value.includes(key);
        const flattenedItem = {
          _id: key,
          value: item,
          index,
          level,
          parentItem,
          hasChildren: !!children,
          bind: {
            "value": item,
            level,
            "aria-setsize": items2.length,
            "aria-posinset": index + 1
          }
        };
        acc.push(flattenedItem);
        if (children && isExpanded)
          acc.push(...flattenItems(children, level + 1, item));
        return acc;
      }, []);
    }
    const expandedItems = computed126(() => {
      const items2 = props2.items;
      expanded.value.map((i) => i);
      return flattenItems(items2 ?? []);
    });
    function handleKeydown(event) {
      if (isVirtual.value) {
        virtualKeydownHook.trigger(event);
      } else {
        const collections = rovingFocusGroupRef.value?.getItems() ?? [];
        handleTypeaheadSearch(event.key, collections);
      }
    }
    function handleKeydownNavigation(event) {
      if (isVirtual.value)
        return;
      const intent = MAP_KEY_TO_FOCUS_INTENT[event.key];
      nextTick33(() => {
        handleMultipleReplace(
          intent,
          getActiveElement(),
          rovingFocusGroupRef.value?.getItems,
          expandedItems.value.map((i) => i.value)
        );
      });
    }
    provideTreeRootContext({
      modelValue,
      selectedKeys,
      onSelect: (val) => {
        const condition = (baseValue) => props2.getKey(baseValue ?? {}) === props2.getKey(val);
        const exist = props2.multiple && Array.isArray(modelValue.value) ? modelValue.value?.findIndex(condition) !== -1 : void 0;
        onSelectItem(val, condition);
        if (props2.propagateSelect && props2.multiple && Array.isArray(modelValue.value)) {
          const children = flatten(props2.getChildren(val) ?? []);
          if (exist) {
            modelValue.value = [...modelValue.value].filter((i) => !children.some((child) => props2.getKey(i ?? {}) === props2.getKey(child)));
          } else {
            modelValue.value = [...modelValue.value, ...children];
          }
        }
      },
      expanded,
      onToggle(val) {
        const children = val ? props2.getChildren(val) : void 0;
        if (!children)
          return;
        const key = props2.getKey(val) ?? val;
        if (expanded.value.includes(key))
          expanded.value = expanded.value.filter((val2) => val2 !== key);
        else
          expanded.value.push(key);
      },
      getKey: props2.getKey,
      getChildren: props2.getChildren,
      items,
      expandedItems,
      disabled,
      multiple,
      dir,
      propagateSelect,
      isVirtual,
      virtualKeydownHook,
      handleMultipleReplace
    });
    return (_ctx, _cache) => {
      return openBlock360(), createBlock351(unref362(_sfc_main50), {
        ref_key: "rovingFocusGroupRef",
        ref: rovingFocusGroupRef,
        "as-child": "",
        orientation: "vertical",
        dir: unref362(dir)
      }, {
        default: withCtx356(() => [
          createVNode77(unref362(Primitive), {
            role: "tree",
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "aria-multiselectable": unref362(multiple) ? true : void 0,
            onKeydown: [
              handleKeydown,
              withKeys25(withModifiers25(handleKeydownNavigation, ["shift"]), ["up", "down"])
            ]
          }, {
            default: withCtx356(() => [
              renderSlot363(_ctx.$slots, "default", {
                flattenItems: expandedItems.value,
                modelValue: unref362(modelValue),
                expanded: unref362(expanded)
              })
            ]),
            _: 3
          }, 8, ["as", "as-child", "aria-multiselectable", "onKeydown"])
        ]),
        _: 3
      }, 8, ["dir"]);
    };
  }
});

// node_modules/reka-ui/dist/Tree/TreeItem.js
var TREE_SELECT = "tree.select";
var TREE_TOGGLE = "tree.toggle";
var _sfc_main367 = defineComponent372({
  ...{
    inheritAttrs: false
  },
  __name: "TreeItem",
  props: {
    value: {},
    level: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["select", "toggle"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectTreeRootContext();
    const { getItems } = useCollection();
    const hasChildren = computed127(() => !!rootContext.getChildren(props2.value));
    const isExpanded = computed127(() => {
      const key = rootContext.getKey(props2.value);
      return rootContext.expanded.value.includes(key);
    });
    const isSelected = computed127(() => {
      const key = rootContext.getKey(props2.value);
      return rootContext.selectedKeys.value.includes(key);
    });
    const isIndeterminate3 = computed127(() => {
      if (rootContext.propagateSelect.value && isSelected.value && hasChildren.value && Array.isArray(rootContext.modelValue.value)) {
        const children = flatten(rootContext.getChildren(props2.value) || []);
        return !children.every((child) => rootContext.modelValue.value.find((v) => rootContext.getKey(v) === rootContext.getKey(child)));
      } else {
        return void 0;
      }
    });
    function handleKeydownRight(ev) {
      if (!hasChildren.value)
        return;
      if (isExpanded.value) {
        const collection = getItems().map((i) => i.ref);
        const currentElement = getActiveElement();
        const currentIndex = collection.indexOf(currentElement);
        const list = [...collection].slice(currentIndex);
        const nextElement = list.find((el) => Number(el.getAttribute("data-indent")) === props2.level + 1);
        if (nextElement)
          nextElement.focus();
      } else {
        handleToggleCustomEvent(ev);
      }
    }
    function handleKeydownLeft(ev) {
      if (isExpanded.value) {
        handleToggleCustomEvent(ev);
      } else {
        const collection = getItems().map((i) => i.ref);
        const currentElement = getActiveElement();
        const currentIndex = collection.indexOf(currentElement);
        const list = [...collection].slice(0, currentIndex).reverse();
        const parentElement = list.find((el) => Number(el.getAttribute("data-indent")) === props2.level - 1);
        if (parentElement)
          parentElement.focus();
      }
    }
    async function handleSelect2(ev) {
      emits("select", ev);
      if (ev?.defaultPrevented)
        return;
      rootContext.onSelect(props2.value);
    }
    async function handleToggle(ev) {
      emits("toggle", ev);
      if (ev?.defaultPrevented)
        return;
      rootContext.onToggle(props2.value);
    }
    async function handleSelectCustomEvent(ev) {
      if (!ev)
        return;
      const eventDetail = { originalEvent: ev, value: props2.value, isExpanded: isExpanded.value, isSelected: isSelected.value };
      handleAndDispatchCustomEvent(TREE_SELECT, handleSelect2, eventDetail);
    }
    async function handleToggleCustomEvent(ev) {
      if (!ev)
        return;
      const eventDetail = { originalEvent: ev, value: props2.value, isExpanded: isExpanded.value, isSelected: isSelected.value };
      handleAndDispatchCustomEvent(TREE_TOGGLE, handleToggle, eventDetail);
    }
    __expose({
      isExpanded,
      isSelected,
      isIndeterminate: isIndeterminate3,
      handleToggle: () => rootContext.onToggle(props2.value),
      handleSelect: () => rootContext.onSelect(props2.value)
    });
    return (_ctx, _cache) => {
      return openBlock361(), createBlock352(unref363(_sfc_main54), {
        "as-child": "",
        value: _ctx.value,
        "allow-shift-key": ""
      }, {
        default: withCtx357(() => [
          createVNode78(unref363(Primitive), mergeProps165(_ctx.$attrs, {
            role: "treeitem",
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "aria-selected": isSelected.value,
            "aria-expanded": hasChildren.value ? isExpanded.value : void 0,
            "aria-level": _ctx.level,
            "data-indent": _ctx.level,
            "data-selected": isSelected.value ? "" : void 0,
            "data-expanded": isExpanded.value ? "" : void 0,
            onKeydown: [
              withKeys26(withModifiers26(handleSelectCustomEvent, ["self", "prevent"]), ["enter", "space"]),
              _cache[0] || (_cache[0] = withKeys26(withModifiers26((ev) => unref363(rootContext).dir.value === "ltr" ? handleKeydownRight(ev) : handleKeydownLeft(ev), ["prevent"]), ["right"])),
              _cache[1] || (_cache[1] = withKeys26(withModifiers26((ev) => unref363(rootContext).dir.value === "ltr" ? handleKeydownLeft(ev) : handleKeydownRight(ev), ["prevent"]), ["left"]))
            ],
            onClick: _cache[2] || (_cache[2] = withModifiers26((ev) => {
              handleSelectCustomEvent(ev);
              handleToggleCustomEvent(ev);
            }, ["stop"]))
          }), {
            default: withCtx357(() => [
              renderSlot364(_ctx.$slots, "default", {
                isExpanded: isExpanded.value,
                isSelected: isSelected.value,
                isIndeterminate: isIndeterminate3.value,
                handleSelect: () => unref363(rootContext).onSelect(_ctx.value),
                handleToggle: () => unref363(rootContext).onToggle(_ctx.value)
              })
            ]),
            _: 3
          }, 16, ["as", "as-child", "aria-selected", "aria-expanded", "aria-level", "data-indent", "data-selected", "data-expanded", "onKeydown"])
        ]),
        _: 3
      }, 8, ["value"]);
    };
  }
});

// node_modules/reka-ui/dist/Tree/TreeVirtualizer.js
import { defineComponent as defineComponent373, useSlots as useSlots3, computed as computed128, cloneVNode as cloneVNode3, nextTick as nextTick34, createElementBlock as createElementBlock16, openBlock as openBlock362, normalizeStyle as normalizeStyle18, unref as unref364, Fragment as Fragment12, renderList as renderList4, createBlock as createBlock353, resolveDynamicComponent as resolveDynamicComponent11 } from "vue";
var _sfc_main368 = defineComponent373({
  __name: "TreeVirtualizer",
  props: {
    overscan: {},
    estimateSize: {},
    textContent: { type: Function }
  },
  setup(__props) {
    const props2 = __props;
    const slots = useSlots3();
    const rootContext = injectTreeRootContext();
    const parentEl = useParentElement();
    const { getItems } = useCollection();
    const search = refAutoReset("", 1e3);
    const optionsWithMetadata = computed128(() => {
      const parseTextContent = (option) => {
        if (props2.textContent)
          return props2.textContent(option);
        else
          return option.toString().toLowerCase();
      };
      return rootContext.expandedItems.value.map((option, index) => ({
        index,
        textContent: parseTextContent(option.value)
      }));
    });
    rootContext.isVirtual.value = true;
    const padding = computed128(() => {
      const el = parentEl.value;
      if (!el) {
        return { start: 0, end: 0 };
      } else {
        const styles = window.getComputedStyle(el);
        return {
          start: Number.parseFloat(styles.paddingBlockStart || styles.paddingTop),
          end: Number.parseFloat(styles.paddingBlockEnd || styles.paddingBottom)
        };
      }
    });
    const virtualizer = useVirtualizer(
      {
        get scrollPaddingStart() {
          return padding.value.start;
        },
        get scrollPaddingEnd() {
          return padding.value.end;
        },
        get count() {
          return rootContext.expandedItems.value.length ?? 0;
        },
        get horizontal() {
          return false;
        },
        getItemKey(index) {
          return index + rootContext.getKey(rootContext.expandedItems.value[index].value);
        },
        estimateSize() {
          return props2.estimateSize ?? 28;
        },
        getScrollElement() {
          return parentEl.value;
        },
        overscan: props2.overscan ?? 12
      }
    );
    const virtualizedItems = computed128(() => virtualizer.value.getVirtualItems().map((item) => {
      return {
        item,
        is: cloneVNode3(slots.default({
          item: rootContext.expandedItems.value[item.index],
          virtualizer: virtualizer.value,
          virtualItem: item
        })[0], {
          "data-index": item.index,
          "style": {
            position: "absolute",
            top: 0,
            left: 0,
            transform: `translateY(${item.start}px)`,
            overflowAnchor: "none"
          }
        })
      };
    }));
    function scrollToIndexAndFocus(index) {
      virtualizer.value.scrollToIndex(index, { align: "start" });
      requestAnimationFrame(() => {
        const item = parentEl.value.querySelector(`[data-index="${index}"]`);
        if (item instanceof HTMLElement)
          item.focus();
      });
    }
    rootContext.virtualKeydownHook.on((event) => {
      const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
      const isTabKey = event.key === "Tab" && !isMetaKey;
      if (isTabKey)
        return;
      const intent = MAP_KEY_TO_FOCUS_INTENT[event.key];
      if (["first", "last"].includes(intent)) {
        event.preventDefault();
        const index = intent === "first" ? 0 : rootContext.expandedItems.value.length - 1;
        virtualizer.value.scrollToIndex(index);
        requestAnimationFrame(() => {
          const items = getItems();
          const item = intent === "first" ? items[0] : items[items.length - 1];
          item.ref.focus();
        });
      } else if (intent === "prev" && event.key !== "ArrowUp") {
        const currentElement = getActiveElement();
        const currentIndex = Number(currentElement.getAttribute("data-index"));
        const currentLevel = Number(currentElement.getAttribute("data-indent"));
        const list = rootContext.expandedItems.value.slice(0, currentIndex).map((item, index) => ({ ...item, index })).reverse();
        const parentItem = list.find((item) => item.level === currentLevel - 1);
        if (parentItem)
          scrollToIndexAndFocus(parentItem.index);
      } else if (!intent && !isMetaKey) {
        search.value += event.key;
        const currentIndex = Number(getActiveElement()?.getAttribute("data-index"));
        const currentMatch = optionsWithMetadata.value[currentIndex].textContent;
        const filteredOptions = optionsWithMetadata.value.map((i) => i.textContent);
        const next = getNextMatch(filteredOptions, search.value, currentMatch);
        const nextMatch = optionsWithMetadata.value.find((option) => option.textContent === next);
        if (nextMatch)
          scrollToIndexAndFocus(nextMatch.index);
      }
      nextTick34(() => {
        if (event.shiftKey && intent)
          rootContext.handleMultipleReplace(intent, getActiveElement(), getItems, rootContext.expandedItems.value.map((i) => i.value));
      });
    });
    return (_ctx, _cache) => {
      return openBlock362(), createElementBlock16("div", {
        "data-reka-virtualizer": "",
        style: normalizeStyle18({
          position: "relative",
          width: "100%",
          height: `${unref364(virtualizer).getTotalSize()}px`
        })
      }, [
        (openBlock362(true), createElementBlock16(Fragment12, null, renderList4(virtualizedItems.value, ({ is, item }) => {
          return openBlock362(), createBlock353(resolveDynamicComponent11(is), {
            key: item.key
          });
        }), 128))
      ], 4);
    };
  }
});

// node_modules/reka-ui/dist/Viewport/Viewport.js
import { defineComponent as defineComponent374, toRefs as toRefs61, createElementBlock as createElementBlock17, openBlock as openBlock363, Fragment as Fragment13, createVNode as createVNode79, unref as unref365, mergeProps as mergeProps166, withCtx as withCtx358, renderSlot as renderSlot365, createTextVNode as createTextVNode33 } from "vue";
var _sfc_main369 = defineComponent374({
  __name: "Viewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const { nonce: propNonce } = toRefs61(props2);
    const nonce = useNonce(propNonce);
    return (_ctx, _cache) => {
      return openBlock363(), createElementBlock17(Fragment13, null, [
        createVNode79(unref365(Primitive), mergeProps166({ ..._ctx.$attrs, ...props2 }, {
          ref: unref365(forwardRef),
          "data-reka-viewport": "",
          role: "presentation",
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            overflow: "auto"
          }
        }), {
          default: withCtx358(() => [
            renderSlot365(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16),
        createVNode79(unref365(Primitive), {
          as: "style",
          nonce: unref365(nonce)
        }, {
          default: withCtx358(() => _cache[0] || (_cache[0] = [
            createTextVNode33(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-viewport]::-webkit-scrollbar { display: none; } ")
          ])),
          _: 1
        }, 8, ["nonce"])
      ], 64);
    };
  }
});

// node_modules/reka-ui/dist/shared/withDefault.js
import { mergeProps as mergeProps167, h as h5 } from "vue";
function withDefault(WrappedComponent, options) {
  return {
    inheritAttrs: false,
    name: `${WrappedComponent.__name ?? ""}Wrapper`,
    setup(_, ctx) {
      return () => {
        const optionProps = typeof options?.props === "function" ? options?.props(ctx.attrs) : options?.props;
        const { forwardRef } = useForwardExpose();
        const mergedProps = mergeProps167(optionProps, ctx.attrs);
        return h5(WrappedComponent, { ...mergedProps, ref: forwardRef }, ctx.slots);
      };
    }
  };
}

// node_modules/reka-ui/dist/index.js
var _sfc_main370 = defineComponent375({
  __name: "DatePickerAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock364(), createBlock354(unref366(_sfc_main125), normalizeProps108(guardReactiveProps104(props2)), {
        default: withCtx359(() => [
          renderSlot366(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
export {
  _sfc_main7 as AccordionContent,
  _sfc_main8 as AccordionHeader,
  _sfc_main5 as AccordionItem,
  _sfc_main3 as AccordionRoot,
  _sfc_main10 as AccordionTrigger,
  _sfc_main13 as AlertDialogAction,
  _sfc_main21 as AlertDialogCancel,
  _sfc_main20 as AlertDialogContent,
  _sfc_main23 as AlertDialogDescription,
  _sfc_main26 as AlertDialogOverlay,
  _sfc_main28 as AlertDialogPortal,
  _sfc_main29 as AlertDialogRoot,
  _sfc_main31 as AlertDialogTitle,
  _sfc_main33 as AlertDialogTrigger,
  _sfc_main34 as AspectRatio,
  _sfc_main36 as AvatarFallback,
  _sfc_main37 as AvatarImage,
  _sfc_main35 as AvatarRoot,
  _sfc_main39 as CalendarCell,
  _sfc_main40 as CalendarCellTrigger,
  _sfc_main41 as CalendarGrid,
  _sfc_main42 as CalendarGridBody,
  _sfc_main43 as CalendarGridHead,
  _sfc_main44 as CalendarGridRow,
  _sfc_main45 as CalendarHeadCell,
  _sfc_main46 as CalendarHeader,
  _sfc_main47 as CalendarHeading,
  _sfc_main48 as CalendarNext,
  _sfc_main49 as CalendarPrev,
  _sfc_main38 as CalendarRoot,
  _sfc_main53 as CheckboxGroupRoot,
  _sfc_main56 as CheckboxIndicator,
  _sfc_main55 as CheckboxRoot,
  _sfc_main6 as CollapsibleContent,
  _sfc_main4 as CollapsibleRoot,
  _sfc_main9 as CollapsibleTrigger,
  _sfc_main59 as ComboboxAnchor,
  _sfc_main67 as ComboboxArrow,
  _sfc_main68 as ComboboxCancel,
  _sfc_main69 as ComboboxContent,
  _sfc_main70 as ComboboxEmpty,
  _sfc_main72 as ComboboxGroup,
  _sfc_main74 as ComboboxInput,
  _sfc_main76 as ComboboxItem,
  _sfc_main78 as ComboboxItemIndicator,
  _sfc_main79 as ComboboxLabel,
  _sfc_main80 as ComboboxPortal,
  _sfc_main64 as ComboboxRoot,
  _sfc_main81 as ComboboxSeparator,
  _sfc_main82 as ComboboxTrigger,
  _sfc_main83 as ComboboxViewport,
  _sfc_main85 as ComboboxVirtualizer,
  _sfc_main2 as ConfigProvider,
  _sfc_main87 as ContextMenuArrow,
  _sfc_main94 as ContextMenuCheckboxItem,
  _sfc_main99 as ContextMenuContent,
  _sfc_main101 as ContextMenuGroup,
  _sfc_main102 as ContextMenuItem,
  _sfc_main103 as ContextMenuItemIndicator,
  _sfc_main105 as ContextMenuLabel,
  _sfc_main107 as ContextMenuPortal,
  _sfc_main109 as ContextMenuRadioGroup,
  _sfc_main111 as ContextMenuRadioItem,
  _sfc_main98 as ContextMenuRoot,
  _sfc_main113 as ContextMenuSeparator,
  _sfc_main115 as ContextMenuSub,
  _sfc_main117 as ContextMenuSubContent,
  _sfc_main120 as ContextMenuSubTrigger,
  _sfc_main121 as ContextMenuTrigger,
  _sfc_main123 as DateFieldInput,
  _sfc_main122 as DateFieldRoot,
  _sfc_main370 as DatePickerAnchor,
  _sfc_main127 as DatePickerArrow,
  _sfc_main129 as DatePickerCalendar,
  _sfc_main130 as DatePickerCell,
  _sfc_main131 as DatePickerCellTrigger,
  _sfc_main133 as DatePickerClose,
  _sfc_main139 as DatePickerContent,
  _sfc_main140 as DatePickerField,
  _sfc_main141 as DatePickerGrid,
  _sfc_main142 as DatePickerGridBody,
  _sfc_main143 as DatePickerGridHead,
  _sfc_main144 as DatePickerGridRow,
  _sfc_main145 as DatePickerHeadCell,
  _sfc_main146 as DatePickerHeader,
  _sfc_main147 as DatePickerHeading,
  _sfc_main148 as DatePickerInput,
  _sfc_main149 as DatePickerNext,
  _sfc_main150 as DatePickerPrev,
  _sfc_main128 as DatePickerRoot,
  _sfc_main152 as DatePickerTrigger,
  _sfc_main154 as DateRangeFieldInput,
  _sfc_main153 as DateRangeFieldRoot,
  _sfc_main155 as DateRangePickerAnchor,
  _sfc_main156 as DateRangePickerArrow,
  _sfc_main159 as DateRangePickerCalendar,
  _sfc_main161 as DateRangePickerCell,
  _sfc_main163 as DateRangePickerCellTrigger,
  _sfc_main164 as DateRangePickerClose,
  _sfc_main165 as DateRangePickerContent,
  _sfc_main166 as DateRangePickerField,
  _sfc_main168 as DateRangePickerGrid,
  _sfc_main170 as DateRangePickerGridBody,
  _sfc_main172 as DateRangePickerGridHead,
  _sfc_main174 as DateRangePickerGridRow,
  _sfc_main176 as DateRangePickerHeadCell,
  _sfc_main178 as DateRangePickerHeader,
  _sfc_main180 as DateRangePickerHeading,
  _sfc_main181 as DateRangePickerInput,
  _sfc_main183 as DateRangePickerNext,
  _sfc_main185 as DateRangePickerPrev,
  _sfc_main157 as DateRangePickerRoot,
  _sfc_main186 as DateRangePickerTrigger,
  _sfc_main12 as DialogClose,
  _sfc_main19 as DialogContent,
  _sfc_main22 as DialogDescription,
  _sfc_main25 as DialogOverlay,
  _sfc_main187 as DialogPortal,
  _sfc_main11 as DialogRoot,
  _sfc_main30 as DialogTitle,
  _sfc_main32 as DialogTrigger,
  _sfc_main188 as DropdownMenuArrow,
  _sfc_main189 as DropdownMenuCheckboxItem,
  _sfc_main191 as DropdownMenuContent,
  _sfc_main192 as DropdownMenuGroup,
  _sfc_main193 as DropdownMenuItem,
  _sfc_main194 as DropdownMenuItemIndicator,
  _sfc_main195 as DropdownMenuLabel,
  _sfc_main196 as DropdownMenuPortal,
  _sfc_main197 as DropdownMenuRadioGroup,
  _sfc_main198 as DropdownMenuRadioItem,
  _sfc_main190 as DropdownMenuRoot,
  _sfc_main199 as DropdownMenuSeparator,
  _sfc_main200 as DropdownMenuSub,
  _sfc_main201 as DropdownMenuSubContent,
  _sfc_main202 as DropdownMenuSubTrigger,
  _sfc_main203 as DropdownMenuTrigger,
  _sfc_main205 as EditableArea,
  _sfc_main206 as EditableCancelTrigger,
  _sfc_main207 as EditableEditTrigger,
  _sfc_main208 as EditableInput,
  _sfc_main209 as EditablePreview,
  _sfc_main204 as EditableRoot,
  _sfc_main210 as EditableSubmitTrigger,
  _sfc_main15 as FocusScope,
  _sfc_main211 as HoverCardArrow,
  _sfc_main214 as HoverCardContent,
  _sfc_main215 as HoverCardPortal,
  _sfc_main212 as HoverCardRoot,
  _sfc_main216 as HoverCardTrigger,
  _sfc_main217 as Label,
  _sfc_main65 as ListboxContent,
  _sfc_main73 as ListboxFilter,
  _sfc_main71 as ListboxGroup,
  _sfc_main218 as ListboxGroupLabel,
  _sfc_main75 as ListboxItem,
  _sfc_main77 as ListboxItemIndicator,
  _sfc_main63 as ListboxRoot,
  _sfc_main84 as ListboxVirtualizer,
  _sfc_main219 as MenubarArrow,
  _sfc_main220 as MenubarCheckboxItem,
  _sfc_main223 as MenubarContent,
  _sfc_main224 as MenubarGroup,
  _sfc_main225 as MenubarItem,
  _sfc_main226 as MenubarItemIndicator,
  _sfc_main227 as MenubarLabel,
  _sfc_main222 as MenubarMenu,
  _sfc_main228 as MenubarPortal,
  _sfc_main229 as MenubarRadioGroup,
  _sfc_main230 as MenubarRadioItem,
  _sfc_main221 as MenubarRoot,
  _sfc_main231 as MenubarSeparator,
  _sfc_main232 as MenubarSub,
  _sfc_main233 as MenubarSubContent,
  _sfc_main234 as MenubarSubTrigger,
  _sfc_main235 as MenubarTrigger,
  _sfc_main239 as NavigationMenuContent,
  _sfc_main240 as NavigationMenuIndicator,
  _sfc_main237 as NavigationMenuItem,
  _sfc_main241 as NavigationMenuLink,
  _sfc_main242 as NavigationMenuList,
  _sfc_main236 as NavigationMenuRoot,
  _sfc_main243 as NavigationMenuSub,
  _sfc_main244 as NavigationMenuTrigger,
  _sfc_main245 as NavigationMenuViewport,
  _sfc_main247 as NumberFieldDecrement,
  _sfc_main248 as NumberFieldIncrement,
  _sfc_main249 as NumberFieldInput,
  _sfc_main246 as NumberFieldRoot,
  _sfc_main250 as PaginationEllipsis,
  _sfc_main252 as PaginationFirst,
  _sfc_main253 as PaginationLast,
  _sfc_main254 as PaginationList,
  _sfc_main255 as PaginationListItem,
  _sfc_main256 as PaginationNext,
  _sfc_main257 as PaginationPrev,
  _sfc_main251 as PaginationRoot,
  _sfc_main259 as PinInputInput,
  _sfc_main258 as PinInputRoot,
  _sfc_main125 as PopoverAnchor,
  _sfc_main126 as PopoverArrow,
  _sfc_main132 as PopoverClose,
  _sfc_main138 as PopoverContent,
  _sfc_main134 as PopoverPortal,
  _sfc_main124 as PopoverRoot,
  _sfc_main151 as PopoverTrigger,
  Presence,
  Primitive,
  _sfc_main261 as ProgressIndicator,
  _sfc_main260 as ProgressRoot,
  _sfc_main265 as RadioGroupIndicator,
  _sfc_main264 as RadioGroupItem,
  _sfc_main263 as RadioGroupRoot,
  _sfc_main160 as RangeCalendarCell,
  _sfc_main162 as RangeCalendarCellTrigger,
  _sfc_main167 as RangeCalendarGrid,
  _sfc_main169 as RangeCalendarGridBody,
  _sfc_main171 as RangeCalendarGridHead,
  _sfc_main173 as RangeCalendarGridRow,
  _sfc_main175 as RangeCalendarHeadCell,
  _sfc_main177 as RangeCalendarHeader,
  _sfc_main179 as RangeCalendarHeading,
  _sfc_main182 as RangeCalendarNext,
  _sfc_main184 as RangeCalendarPrev,
  _sfc_main158 as RangeCalendarRoot,
  _sfc_main50 as RovingFocusGroup,
  _sfc_main54 as RovingFocusItem,
  _sfc_main268 as ScrollAreaCorner,
  _sfc_main266 as ScrollAreaRoot,
  _sfc_main276 as ScrollAreaScrollbar,
  _sfc_main277 as ScrollAreaThumb,
  _sfc_main278 as ScrollAreaViewport,
  _sfc_main284 as SelectArrow,
  _sfc_main286 as SelectContent,
  _sfc_main287 as SelectGroup,
  _sfc_main288 as SelectIcon,
  _sfc_main289 as SelectItem,
  _sfc_main290 as SelectItemIndicator,
  _sfc_main291 as SelectItemText,
  _sfc_main292 as SelectLabel,
  _sfc_main293 as SelectPortal,
  _sfc_main280 as SelectRoot,
  _sfc_main295 as SelectScrollDownButton,
  _sfc_main296 as SelectScrollUpButton,
  _sfc_main297 as SelectSeparator,
  _sfc_main298 as SelectTrigger,
  _sfc_main299 as SelectValue,
  _sfc_main300 as SelectViewport,
  _sfc_main302 as Separator,
  _sfc_main307 as SliderRange,
  _sfc_main306 as SliderRoot,
  _sfc_main309 as SliderThumb,
  _sfc_main310 as SliderTrack,
  Slot,
  _sfc_main311 as SplitterGroup,
  _sfc_main312 as SplitterPanel,
  _sfc_main313 as SplitterResizeHandle,
  _sfc_main316 as StepperDescription,
  _sfc_main317 as StepperIndicator,
  _sfc_main315 as StepperItem,
  _sfc_main314 as StepperRoot,
  _sfc_main318 as StepperSeparator,
  _sfc_main319 as StepperTitle,
  _sfc_main320 as StepperTrigger,
  _sfc_main321 as SwitchRoot,
  _sfc_main322 as SwitchThumb,
  _sfc_main324 as TabsContent,
  _sfc_main325 as TabsIndicator,
  _sfc_main326 as TabsList,
  _sfc_main323 as TabsRoot,
  _sfc_main327 as TabsTrigger,
  _sfc_main329 as TagsInputClear,
  _sfc_main330 as TagsInputInput,
  _sfc_main331 as TagsInputItem,
  _sfc_main332 as TagsInputItemDelete,
  _sfc_main333 as TagsInputItemText,
  _sfc_main328 as TagsInputRoot,
  _sfc_main335 as TimeFieldInput,
  _sfc_main334 as TimeFieldRoot,
  _sfc_main341 as ToastAction,
  _sfc_main340 as ToastClose,
  _sfc_main342 as ToastDescription,
  _sfc_main343 as ToastPortal,
  _sfc_main337 as ToastProvider,
  _sfc_main344 as ToastRoot,
  _sfc_main345 as ToastTitle,
  _sfc_main348 as ToastViewport,
  _sfc_main350 as Toggle,
  _sfc_main351 as ToggleGroupItem,
  _sfc_main349 as ToggleGroupRoot,
  _sfc_main352 as ToolbarButton,
  _sfc_main353 as ToolbarLink,
  _sfc_main354 as ToolbarRoot,
  _sfc_main355 as ToolbarSeparator,
  _sfc_main356 as ToolbarToggleGroup,
  _sfc_main357 as ToolbarToggleItem,
  _sfc_main358 as TooltipArrow,
  _sfc_main363 as TooltipContent,
  _sfc_main364 as TooltipPortal,
  _sfc_main359 as TooltipProvider,
  _sfc_main360 as TooltipRoot,
  _sfc_main365 as TooltipTrigger,
  _sfc_main367 as TreeItem,
  _sfc_main366 as TreeRoot,
  _sfc_main368 as TreeVirtualizer,
  _sfc_main369 as Viewport,
  _sfc_main as VisuallyHidden,
  createContext,
  injectAccordionItemContext,
  injectAccordionRootContext,
  injectAlertDialogContentContext,
  injectAvatarRootContext,
  injectCalendarRootContext,
  injectCheckboxGroupRootContext,
  injectCheckboxRootContext,
  injectCollapsibleRootContext,
  injectComboboxGroupContext,
  injectListboxItemContext as injectComboboxItemContext,
  injectComboboxRootContext,
  injectConfigProviderContext,
  injectContextMenuRootContext,
  injectDateFieldRootContext,
  injectDatePickerRootContext,
  injectDateRangeFieldRootContext,
  injectDateRangePickerRootContext,
  injectDialogRootContext,
  injectDropdownMenuRootContext,
  injectEditableRootContext,
  injectHoverCardRootContext,
  injectListboxGroupContext,
  injectListboxItemContext,
  injectListboxRootContext,
  injectMenubarMenuContext,
  injectMenubarRootContext,
  injectNavigationMenuContext,
  injectNavigationMenuItemContext,
  injectNumberFieldRootContext,
  injectPaginationRootContext,
  injectPinInputRootContext,
  injectPopoverRootContext,
  injectProgressRootContext,
  injectRadioGroupItemContext,
  injectRadioGroupRootContext,
  injectRangeCalendarRootContext,
  injectScrollAreaRootContext,
  injectScrollAreaScrollbarContext,
  injectSelectGroupContext,
  injectSelectItemContext,
  injectSelectRootContext,
  injectSliderRootContext,
  injectPanelGroupContext as injectSplitterGroupContext,
  injectStepperItemContext,
  injectStepperRootContext,
  injectSwitchRootContext,
  injectTabsRootContext,
  injectTagsInputItemContext,
  injectTagsInputRootContext,
  injectTimeFieldRootContext,
  injectToastProviderContext,
  injectToggleGroupRootContext,
  injectToolbarRootContext,
  injectTooltipProviderContext,
  injectTooltipRootContext,
  injectTreeRootContext,
  useBodyScrollLock,
  useDateFormatter,
  useEmitAsProps,
  useFilter,
  useForwardExpose,
  useForwardProps,
  useForwardPropsEmits,
  useId2 as useId,
  useStateMachine,
  withDefault
};
//# sourceMappingURL=reka-ui.js.map
